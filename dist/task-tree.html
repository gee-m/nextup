<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Task Tree</title>
    <link rel="icon" type="image/svg+xml" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 32 32'%3E%3Cdefs%3E%3ClinearGradient id='g' x1='0%25' y1='0%25' x2='100%25' y2='100%25'%3E%3Cstop offset='0%25' style='stop-color:%234f46e5'/%3E%3Cstop offset='100%25' style='stop-color:%237c3aed'/%3E%3C/linearGradient%3E%3C/defs%3E%3Crect fill='url(%23g)' width='32' height='32' rx='6'/%3E%3Cpath stroke='%23fff' stroke-width='2' fill='none' d='M16 8v6m0 0l-6 4m6-4l6 4'/%3E%3Ccircle cx='16' cy='8' r='2.5' fill='%23fff'/%3E%3Ccircle cx='10' cy='18' r='2.5' fill='%23fff'/%3E%3Ccircle cx='22' cy='18' r='2.5' fill='%23fff'/%3E%3Cpath stroke='%23fff' stroke-width='1.5' fill='none' d='M10 20.5v3.5m12-3.5v3.5'/%3E%3Ccircle cx='10' cy='26' r='2' fill='%23fbbf24'/%3E%3Ccircle cx='22' cy='26' r='2' fill='%2310b981'/%3E%3C/svg%3E">
    <!-- JSZip library for .zip export/import -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <style>

/* ============================================================
   BASE.CSS (Category: styles)
   ============================================================ */

/* @order: 10 */
/* @category: styles */

* {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
}

body {
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', sans-serif;
    background: linear-gradient(135deg, #f5f7fa 0%, #e9ecef 100%);
    overflow: hidden;
}

svg {
    width: 100%;
    height: 100%;
}

#canvas-container {
    position: fixed;
    top: 65px;
    left: 0;
    right: 0;
    bottom: 0;
    cursor: grab;
}

#canvas-container.has-status-bar {
    bottom: 44px;
}

#canvas-container.dragging {
    cursor: grabbing;
}

/* Smooth animation for home jumps - Transform is GPU accelerated! */
#canvas.animating-view .task-node {
    transition: transform 0.5s cubic-bezier(0.4, 0.0, 0.2, 1);
}

/* Hide lines during animation - CSS transitions don't work on SVG line attributes */
/* This is the standard approach for non-transitionable SVG elements */
#canvas.animating-view line {
    opacity: 0;
    transition: opacity 0.15s ease-out;
}



/* ============================================================
   CONTROLS.CSS (Category: styles)
   ============================================================ */

/* @order: 20 */
/* @category: styles */

#controls {
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
    padding: 14px 24px;
    box-shadow: 0 4px 20px rgba(0,0,0,0.5);
    z-index: 100;
    display: flex;
    flex-wrap: wrap;
    gap: 10px;
    align-items: center;
}

button {
    padding: 9px 18px;
    border: none;
    border-radius: 8px;
    background: rgba(255, 255, 255, 0.95);
    color: #1a1a2e;
    cursor: pointer;
    font-size: 14px;
    font-weight: 500;
    transition: all 0.3s ease;
    box-shadow: 0 2px 8px rgba(0,0,0,0.2);
}

button:hover {
    background: white;
    transform: translateY(-1px);
    box-shadow: 0 4px 12px rgba(0,0,0,0.3);
}

button.secondary {
    background: rgba(255, 255, 255, 0.15);
    color: white;
    box-shadow: 0 2px 6px rgba(0,0,0,0.2);
    border: 1px solid rgba(255, 255, 255, 0.2);
}

button.secondary:hover {
    background: rgba(255, 255, 255, 0.25);
    box-shadow: 0 3px 10px rgba(0,0,0,0.3);
}

/* Dropdown menu for Homes button */
.dropdown {
    position: relative;
    display: inline-block;
}

.dropdown-content {
    display: none;
    position: absolute;
    top: 100%;
    left: 0;
    background: rgba(255, 255, 255, 0.98);
    min-width: 200px;
    max-height: 400px;
    overflow-y: auto;
    box-shadow: 0 8px 24px rgba(0,0,0,0.15);
    border-radius: 8px;
    margin-top: 8px;
    z-index: 1000;
    border: 1px solid rgba(0, 0, 0, 0.1);
}

.dropdown-content.show {
    display: block;
}

.dropdown-item {
    padding: 12px 16px;
    color: #333;
    cursor: pointer;
    transition: background 0.2s;
    border-bottom: 1px solid rgba(0, 0, 0, 0.08);
    display: flex;
    align-items: center;
    justify-content: space-between;
}

.dropdown-item:last-child {
    border-bottom: none;
}

.dropdown-item:hover {
    background: rgba(0, 0, 0, 0.05);
}

.dropdown-item.special {
    background: rgba(156, 39, 176, 0.1);
    font-weight: 600;
}

.dropdown-item.special:hover {
    background: rgba(156, 39, 176, 0.2);
}

.dropdown-divider {
    height: 1px;
    background: rgba(0, 0, 0, 0.1);
    margin: 4px 0;
}

.dropdown-empty {
    padding: 16px;
    color: rgba(0, 0, 0, 0.4);
    text-align: center;
    font-style: italic;
}

/* Nested submenu for context menu */
.menu-item-with-submenu {
    position: relative;
}

.menu-item-with-submenu::after {
    content: '‚ñ∂';
    margin-left: 8px;
    font-size: 10px;
}

.submenu {
    display: none;
    position: absolute;
    left: 100%;
    top: 0;
    background: rgba(255, 255, 255, 0.98);
    min-width: 180px;
    max-height: 350px;
    overflow-y: auto;
    overflow-x: hidden; /* Prevent horizontal scrollbar */
    box-shadow: 0 8px 24px rgba(0,0,0,0.15);
    border-radius: 8px;
    margin-left: -2px; /* Overlap slightly to remove gap */
    border: 1px solid rgba(0, 0, 0, 0.1);
    z-index: 1001;
    /* Add invisible padding on left to create "hover bridge" */
    padding-left: 6px;
}

/* Show submenu when hovering parent OR the submenu itself */
.menu-item-with-submenu:hover .submenu,
.submenu:hover {
    display: block;
}

/* Compensate for padding on first item */
.submenu-item:first-child {
    margin-left: -6px;
    padding-left: 14px;
    width: calc(100% + 6px);
}

.submenu-item {
    margin-left: -6px;
    padding-left: 14px;
    width: calc(100% + 6px);
}

.submenu-item {
    padding: 10px 14px;
    color: #333;
    cursor: pointer;
    transition: background 0.2s;
    border-bottom: 1px solid rgba(0, 0, 0, 0.08);
    white-space: nowrap;
}

.submenu-item:last-child {
    border-bottom: none;
}

.submenu-item:hover {
    background: rgba(0, 0, 0, 0.05);
}

.submenu-item.special {
    background: rgba(156, 39, 176, 0.1);
    font-weight: 600;
}

.submenu-item.special:hover {
    background: rgba(156, 39, 176, 0.2);
}

/* Fix margin for submenu items that have nested submenus */
.submenu-item.menu-item-with-submenu {
    margin-left: 0 !important;
    width: 100% !important;
    position: relative;
    display: block;
    cursor: pointer;
}

.submenu-item.menu-item-with-submenu > span {
    display: inline-block;
    width: 100%;
}

/* Nested submenu - uses fixed positioning to break out of overflow context */
.submenu-nested {
    display: none;
    position: fixed; /* Fixed instead of absolute to escape overflow container */
    background: rgba(255, 255, 255, 0.98);
    min-width: 200px;
    box-shadow: 0 8px 24px rgba(0,0,0,0.2);
    border-radius: 8px;
    border: 1px solid rgba(0, 0, 0, 0.1);
    z-index: 1002; /* Higher than parent submenu */
    padding: 0;
}

.submenu-item.menu-item-with-submenu:hover .submenu-nested,
.submenu-nested:hover {
    display: block !important;
}

.submenu-nested .submenu-item {
    margin-left: 0;
    padding-left: 14px;
    width: 100%;
}

.submenu-nested .submenu-item:first-child {
    margin-left: 0;
    padding-left: 14px;
    width: 100%;
}

.submenu-empty {
    padding: 12px;
    color: rgba(0, 0, 0, 0.4);
    text-align: center;
    font-style: italic;
    font-size: 12px;
}

.submenu-divider {
    height: 1px;
    background: rgba(0, 0, 0, 0.1);
    margin: 4px 0;
}

input {
    padding: 10px 16px;
    border: 2px solid rgba(255, 255, 255, 0.3);
    border-radius: 8px;
    font-size: 14px;
    flex: 1;
    max-width: 300px;
    background: rgba(255, 255, 255, 0.95);
    color: #333;
    transition: all 0.3s ease;
}

input:focus {
    outline: none;
    border-color: white;
    box-shadow: 0 0 0 3px rgba(255, 255, 255, 0.3);
    background: white;
}

#zoomLevel {
    color: white;
    font-weight: 600;
    text-shadow: 0 1px 2px rgba(0,0,0,0.1);
}

.info {
    margin-left: auto;
    font-size: 12px;
    color: #666;
}

/* Off-screen indicators for working tasks */
.offscreen-indicators {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    pointer-events: none;
    z-index: 50;
}

.offscreen-indicator {
    position: absolute;
    background: rgba(255, 213, 79, 0.85);
    border: 2px solid rgba(255, 160, 0, 0.7);
    border-radius: 50%;
    width: 40px;
    height: 40px;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 24px;
    cursor: pointer;
    pointer-events: auto;
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.25);
    transition: all 0.2s;
    backdrop-filter: blur(2px);
}

.offscreen-indicator:hover {
    background: rgba(255, 193, 7, 0.95);
    filter: brightness(1.1);
}

.offscreen-indicator.home {
    background: rgba(33, 150, 243, 0.85);
    border-color: rgba(25, 118, 210, 0.7);
}

.offscreen-indicator.home:hover {
    background: rgba(33, 150, 243, 0.95);
    filter: brightness(1.1);
}

/* Tooltip for indicators - separate element positioned via JS */
.indicator-tooltip {
    position: absolute;
    background: rgba(0, 0, 0, 0.9);
    color: white;
    padding: 6px 12px;
    border-radius: 6px;
    font-size: 13px;
    white-space: nowrap;
    pointer-events: none;
    opacity: 0;
    transition: opacity 0.2s;
    z-index: 1001;
    font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
    font-weight: 500;
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
}

.indicator-tooltip.visible {
    opacity: 1;
}

/* Toast Notification System */
.toast-container {
    position: fixed;
    bottom: 24px;
    right: 24px;
    z-index: 9999;
    display: flex;
    flex-direction: column;
    gap: 12px;
    pointer-events: none;
}

.toast {
    background: white;
    color: #333;
    padding: 14px 20px;
    border-radius: 8px;
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
    font-size: 14px;
    font-weight: 500;
    border-left: 4px solid #4caf50;
    animation: slideIn 0.3s ease, slideOut 0.3s ease 3.7s;
    pointer-events: auto;
    cursor: pointer;
}

.toast.success {
    border-left-color: #4caf50;
    background: #f1f8e9;
}

.toast.error {
    border-left-color: #f44336;
    background: #ffebee;
    color: #c62828;
}

.toast.info {
    border-left-color: #2196f3;
    background: #e3f2fd;
    color: #1565c0;
}

@keyframes slideIn {
    from {
        transform: translateX(400px);
        opacity: 0;
    }
    to {
        transform: translateX(0);
        opacity: 1;
    }
}

@keyframes slideOut {
    from {
        transform: translateX(0);
        opacity: 1;
    }
    to {
        transform: translateX(400px);
        opacity: 0;
    }
}



/* ============================================================
   TASK-NODES.CSS (Category: styles)
   ============================================================ */

/* @order: 30 */
/* @category: styles */

.task-node {
    cursor: move;
}

.task-node rect {
    stroke: #555;
    stroke-width: 2;
    transition: all 0.2s ease;
    rx: 8;
    ry: 8;
    fill: white;
    filter: drop-shadow(0 2px 4px rgba(0, 0, 0, 0.1));
}

.task-node.done rect {
    fill: linear-gradient(135deg, #d4edda 0%, #c3e6cb 100%);
    fill: #e8f5e9;
    stroke: #4caf50;
    filter: drop-shadow(0 2px 6px rgba(76, 175, 80, 0.3));
}

.task-node.working rect {
    fill: #fff8e1;
    stroke: #ff9800;
    stroke-width: 3;
    filter: drop-shadow(0 3px 8px rgba(255, 152, 0, 0.4));
}

.task-node.in-progress rect {
    /* Inherit fill from base .task-node rect (respects light/dark mode) */
    stroke: #fdd835;  /* Bright yellow border */
    stroke-width: 2.5;
    filter: drop-shadow(0 2px 6px rgba(253, 216, 53, 0.3));
}

.task-node.suggested-next rect {
    fill: #f3e5f5 !important;  /* Light purple background */
    stroke: #9c27b0 !important;  /* Purple border */
    stroke-width: 3 !important;
    filter: drop-shadow(0 3px 8px rgba(156, 39, 176, 0.4)) !important;
}

.task-node.parent-of-working rect {
    stroke: #ff9800;
    stroke-width: 3;
    filter: drop-shadow(0 0 4px rgba(255, 152, 0, 0.4));
}

.task-node.incomplete-child-of-working rect {
    stroke: #e74c3c;
    stroke-width: 2.5;
    filter: drop-shadow(0 0 2px rgba(231, 76, 60, 0.3));
}

/* Visual indicator for nodes with custom arrow attachments while dragging */
.task-node.tied rect {
    stroke: #2196f3;  /* Blue border to indicate custom attachments */
    stroke-width: 3;
    filter: drop-shadow(0 0 8px rgba(33, 150, 243, 0.5)) !important;
    animation: pulse-tied 1.5s ease-in-out infinite;
}

@keyframes pulse-tied {
    0%, 100% {
        filter: drop-shadow(0 0 8px rgba(33, 150, 243, 0.5));
    }
    50% {
        filter: drop-shadow(0 0 12px rgba(33, 150, 243, 0.7));
    }
}

/* Flash effect when arrow attachments are copied */
.task-node.attachment-copied-flash rect {
    animation: flash-copy 0.6s ease-out;
}

@keyframes flash-copy {
    0% {
        fill: #4caf50;
        filter: drop-shadow(0 0 20px rgba(76, 175, 80, 0.9)) brightness(1.3);
    }
    50% {
        fill: #8bc34a;
        filter: drop-shadow(0 0 30px rgba(76, 175, 80, 1)) brightness(1.5);
    }
    100% {
        filter: drop-shadow(0 2px 4px rgba(0, 0, 0, 0.1)) brightness(1);
    }
}

.task-node.hidden {
    display: none; /* Completely hide nodes with hidden property */
}

.task-node text {
    pointer-events: none;
    user-select: none;
    font-size: 14px;
    font-weight: 500; /* Will be overridden by inline style from app.fontWeight */
    fill: #37474f;
    font-family: 'Fira Code', 'Consolas', 'Monaco', 'Courier New', monospace;
    white-space: pre; /* Preserve whitespace (spaces, tabs) in SVG display */
}

.task-node text tspan {
    white-space: pre; /* Preserve whitespace in each line */
}

.hidden-indicator {
    cursor: pointer;
    fill: #ff6b6b;
    stroke: #c92a2a;
    stroke-width: 1;
}

.hidden-indicator-text {
    pointer-events: none;
    font-size: 12px;
    font-weight: bold;
    fill: white;
    text-anchor: middle;
    dominant-baseline: middle;
}

.hidden-indicator:hover {
    fill: #ff5252;
    stroke: #a01919;
}

.task-node:hover rect {
    filter: brightness(0.95);
    stroke-width: 2.5;
}

.text-expand-button circle {
    transition: fill 0.3s ease;
}

.text-expand-button:hover circle {
    filter: brightness(1.1);
}

.task-node.selected rect {
    stroke: #007bff;
    stroke-width: 3;
    filter: drop-shadow(0 0 4px rgba(0, 123, 255, 0.6));
}

.preview-node rect {
    fill: #e8e8ff;
    stroke: #007bff;
    stroke-width: 2;
    stroke-dasharray: 5,3;
    opacity: 0.6;
    filter: none;
}

.preview-node text {
    fill: #4a7c9e;
    opacity: 0.7;
    font-style: italic;
}

/* Custom cursor arrow for drag operations */
#canvas-container.dragging-relationship {
    cursor: none !important;
}

#canvas-container.dragging-relationship * {
    cursor: none !important;
}

.cursor-arrow {
    pointer-events: none;
    position: fixed;
    z-index: 10000;
    width: 24px;
    height: 24px;
}

.cursor-arrow path {
    stroke: #007bff;
    fill: none;
    filter: drop-shadow(0 2px 4px rgba(0,0,0,0.3));
}

.node-menu {
    position: fixed;
    background: white;
    border-radius: 8px;
    box-shadow: 0 4px 12px rgba(0,0,0,0.15);
    padding: 8px 0;
    z-index: 1000;
    min-width: 180px;
}

.node-menu button {
    display: block;
    width: 100%;
    text-align: left;
    background: none;
    color: #333;
    padding: 10px 16px;
    border-radius: 0;
}

.node-menu button:hover {
    background: #f8f9fa;
}

.node-menu .dependency-section {
    padding: 8px 16px;
    border-bottom: 1px solid #e9ecef;
    margin-bottom: 4px;
}

.node-menu .dependency-section h4 {
    margin: 0 0 8px 0;
    font-size: 12px;
    color: #666;
    text-transform: uppercase;
    font-weight: 600;
}

.node-menu .dependency-item {
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: 4px 0;
    font-size: 13px;
}

.node-menu .dependency-item span {
    color: #333;
}

.node-menu .dependency-item .remove-btn {
    background: #dc3545;
    color: white;
    border: none;
    border-radius: 3px;
    padding: 2px 6px;
    font-size: 11px;
    cursor: pointer;
    margin-left: 8px;
    min-width: 20px;
    height: 20px;
    line-height: 1;
}

.node-menu .dependency-item .remove-btn:hover {
    background: #c82333;
}



/* ============================================================
   LINKS.CSS (Category: styles)
   ============================================================ */

/* @order: 40 */
/* @category: styles */

.link {
    stroke: #90a4ae;
    stroke-width: 2;
    fill: none;
    transition: all 0.3s ease;
    /* GPU acceleration for smooth rendering */
    will-change: auto;
}

.link.dependency {
    stroke: #78909c;
    stroke-width: 2;
    stroke-dasharray: 5,5;
}

/* Hit detection lines - invisible, wide for easy clicking */
.link.dependency-hit,
.link.parent-hit,
.link.other-parent-hit {
    cursor: pointer;
    stroke: transparent;
    stroke-width: 15;
    pointer-events: stroke;
}

/* Visible line styling */
.link.parent-visible {
    stroke: #90a4ae;
    stroke-width: 2;
}

/* Hover effects - style visible line when hit line is hovered */
.link.dependency-hit:hover + .link.dependency,
.link.parent-hit:hover + .link.parent-visible,
.link.other-parent-hit:hover + .link.other-parent {
    stroke: #007bff !important;
    stroke-width: 3 !important;
}

.link.other-parent {
    stroke: #b0bec5;
    stroke-width: 1.5;
    stroke-dasharray: 3,3;
}

.link.selected {
    stroke: #007bff !important;
    stroke-width: 4 !important;
    filter: drop-shadow(0 0 3px rgba(0, 123, 255, 0.7));
}

.temp-line {
    stroke-width: 2;
    pointer-events: none;
}

.marker {
    fill: #78909c;
}

/* Link Badge Styling */
.link-badge {
    pointer-events: none;
    user-select: none;
}

/* Links Dropdown Styling */
.links-dropdown {
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
    font-size: 14px;
}



/* ============================================================
   GPU-ACCELERATION.CSS (Category: styles)
   ============================================================ */

/* @order: 45 */
/* @category: styles */

/* GPU Acceleration for frequently updated elements */
/* Uses will-change and transform to create GPU layers for smooth rendering */

/* Arrow dots - frequently updated during drag */
.arrow-dot {
    /* Force GPU compositing layer */
    transform: translateZ(0);
    /* Hint to browser that these properties will change */
    will-change: transform, cx, cy;
    /* Enable hardware acceleration */
    backface-visibility: hidden;
    /* Subpixel antialiasing for smoother rendering */
    -webkit-font-smoothing: subpixel-antialiased;
}

/* Snap indicators - updated during drag */
.snap-indicator {
    /* Force GPU layer */
    transform: translateZ(0);
    will-change: opacity, fill;
    backface-visibility: hidden;
}

/* Temp drag lines - updated on every mousemove */
.temp-line {
    /* Force GPU layer for smooth updates */
    transform: translateZ(0);
    will-change: transform, x1, y1, x2, y2;
    backface-visibility: hidden;
}

/* Parent links being dragged - arrow endpoint updates */
.parent-link {
    /* Enable GPU acceleration for arrow updates */
    will-change: auto; /* Start with auto */
    backface-visibility: hidden;
}

/* Active drag state - stronger GPU hints */
.parent-link.dragging-arrow {
    /* Force GPU layer during active drag */
    transform: translateZ(0);
    will-change: transform, d, x2, y2;
}

/* Cursor arrow - follows mouse during relationship drags */
.cursor-arrow {
    /* Force GPU layer */
    transform: translateZ(0);
    will-change: transform, left, top;
    backface-visibility: hidden;
    /* Isolate rendering to prevent repaints of other elements */
    contain: layout style paint;
}

/* Task nodes during drag */
.task-node.dragging {
    /* Force GPU layer for smooth dragging */
    transform: translateZ(0);
    will-change: transform;
    backface-visibility: hidden;
}

/* Canvas container - isolate rendering */
#canvas-container {
    /* Enable GPU rendering for entire canvas */
    transform: translateZ(0);
    backface-visibility: hidden;
    /* Isolate rendering updates */
    contain: layout style paint;
}

/* SVG canvas - GPU acceleration */
#canvas {
    /* Force GPU compositing */
    transform: translateZ(0);
    backface-visibility: hidden;
}

/* FPS Counter - overlay, frequently updated */
#fps-counter {
    /* Force GPU layer for overlay */
    transform: translateZ(0);
    will-change: contents;
    backface-visibility: hidden;
    contain: layout style paint;
}

/* Preview ghost node during Ctrl+drag */
#preview-ghost-node {
    /* Force GPU layer */
    transform: translateZ(0);
    will-change: transform, x, y;
    backface-visibility: hidden;
}

/* Box selection rectangle */
#box-selection-rect {
    /* Force GPU layer */
    transform: translateZ(0);
    will-change: transform, x, y, width, height;
    backface-visibility: hidden;
}

/* Snap indicators group - container for all snap dots */
#snap-indicators-group {
    /* Force GPU layer */
    transform: translateZ(0);
    backface-visibility: hidden;
    contain: layout style paint;
}

/* Performance: Reduce paint complexity */
/* Use contain property to isolate rendering updates */
.task-node {
    /* Isolate each task node rendering */
    contain: layout style;
}

/* Use GPU for smooth transitions */
.link,
.link.dependency,
.link.parent-visible,
.link.other-parent {
    /* Smooth GPU-accelerated transitions */
    backface-visibility: hidden;
}



/* ============================================================
   MODALS.CSS (Category: styles)
   ============================================================ */

/* @order: 50 */
/* @category: styles */

.modal {
    display: none;
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: rgba(0, 0, 0, 0.5);
    z-index: 2000;
    align-items: center;
    justify-content: center;
}

.modal.show {
    display: flex;
}

.modal-content {
    background: white;
    padding: 24px;
    border-radius: 12px;
    max-width: 500px;
    width: 90%;
    box-shadow: 0 8px 32px rgba(0, 0, 0, 0.2);
}

.modal-content h2 {
    margin: 0 0 12px 0;
    font-size: 20px;
}

.modal-content p {
    margin: 0 0 16px 0;
    color: #666;
    font-size: 14px;
}

#import-textarea {
    width: 100%;
    height: 200px;
    padding: 12px;
    border: 1px solid #ddd;
    border-radius: 6px;
    font-family: monospace;
    font-size: 12px;
    resize: vertical;
    margin-bottom: 16px;
}

.modal-buttons {
    display: flex;
    gap: 8px;
    justify-content: flex-end;
    margin-top: 16px;
}

/* Fix button visibility in modals - override toolbar button colors */
.modal-content button {
    background: rgba(33, 150, 243, 0.1);
    color: #1976d2;
    border: 1px solid rgba(33, 150, 243, 0.3);
}

.modal-content button:hover {
    background: rgba(33, 150, 243, 0.2);
    color: #1565c0;
}

.modal-content button.secondary {
    background: rgba(158, 158, 158, 0.1);
    color: #424242;
    border: 1px solid rgba(158, 158, 158, 0.3);
}

.modal-content button.secondary:hover {
    background: rgba(158, 158, 158, 0.2);
    color: #212121;
}



/* ============================================================
   STATUS-BAR.CSS (Category: styles)
   ============================================================ */

/* @order: 60 */
/* @category: styles */

#status-bar {
    position: fixed;
    bottom: 0;
    left: 0;
    right: 0;
    background: linear-gradient(135deg, #434343 0%, #000000 100%);
    color: white;
    padding: 12px 24px;
    height: 44px;
    font-size: 13px;
    z-index: 50;
    display: none;
    align-items: center;
    box-shadow: 0 -4px 16px rgba(0,0,0,0.2);
}

#status-bar.show {
    display: flex;
}

#status-bar .status-label {
    font-weight: 600;
    margin-right: 10px;
    opacity: 0.8;
}

#status-bar .status-task {
    color: #ffb74d;
    font-weight: 600;
    text-shadow: 0 1px 2px rgba(0,0,0,0.2);
}

#status-bar .status-path {
    color: #e0e0e0;
}

#status-bar .status-detail {
    margin-left: 20px;
    color: #bdbdbd;
}

#status-bar .status-warning {
    color: #ff5252;
    margin-left: 10px;
    font-weight: 600;
}

.status-btn {
    margin-left: auto; /* Push to right side */
    padding: 6px 14px;
    background: rgba(255, 255, 255, 0.1);
    border: 1px solid rgba(255, 255, 255, 0.25);
    border-radius: 4px;
    color: #fff;
    font-size: 13px;
    font-weight: 500;
    cursor: pointer;
    transition: all 0.2s ease;
    display: flex;
    align-items: center;
    gap: 4px;
}

.status-btn:hover {
    background: rgba(255, 255, 255, 0.2);
    border-color: rgba(255, 255, 255, 0.4);
    transform: translateY(-1px);
}

.status-btn:active {
    transform: translateY(0);
}

.status-btn.hidden {
    display: none;
}



/* ============================================================
   TIMER-WINDOW.CSS (Category: styles)
   ============================================================ */

/**
 * @order 65
 * @category styles
 * @description Timer window floating UI styles
 */

/* Timer window container - fixed bottom-right */
#timer-window {
    position: fixed;
    bottom: 80px; /* Above status bar */
    right: 20px;
    background: white;
    border: 2px solid #4CAF50;
    border-radius: 8px;
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
    z-index: 1000;
    font-family: 'Fira Code', 'Consolas', monospace;
    min-width: 280px;
    max-width: 350px;
    display: none; /* Hidden by default */
}

/* Timer window header */
.timer-window-header {
    background: linear-gradient(135deg, #4CAF50, #45a049);
    color: white;
    padding: 8px 12px;
    border-radius: 6px 6px 0 0;
    display: flex;
    justify-content: space-between;
    align-items: center;
    font-weight: bold;
    font-size: 14px;
}

.timer-title {
    user-select: none;
}

.timer-controls {
    display: flex;
    gap: 4px;
}

.timer-btn-play,
.timer-btn-pause,
.timer-btn-minimize,
.timer-btn-close {
    background: rgba(255, 255, 255, 0.2);
    border: none;
    color: white;
    width: 24px;
    height: 24px;
    border-radius: 4px;
    cursor: pointer;
    font-size: 14px;
    line-height: 1;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: background 0.2s;
}

.timer-btn-play:hover,
.timer-btn-pause:hover,
.timer-btn-minimize:hover,
.timer-btn-close:hover {
    background: rgba(255, 255, 255, 0.3);
}

/* Timer content area */
.timer-content {
    padding: 12px;
}

.timer-task-name {
    font-size: 13px;
    font-weight: 600;
    margin-bottom: 12px;
    color: #333;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
}

/* Timer display stats */
.timer-display {
    background: #f5f5f5;
    border-radius: 6px;
    padding: 10px;
    margin-bottom: 10px;
}

.timer-stat {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 6px;
    font-size: 12px;
}

.timer-stat:last-child {
    margin-bottom: 0;
}

.timer-label {
    color: #666;
    font-weight: 500;
}

.timer-value {
    color: #4CAF50;
    font-weight: bold;
    font-size: 14px;
    font-family: 'Courier New', monospace;
}

/* Sessions list */
.timer-sessions {
    margin-top: 10px;
    padding-top: 10px;
    border-top: 1px solid #e0e0e0;
}

.timer-sessions-label {
    font-size: 11px;
    color: #666;
    font-weight: 600;
    margin-bottom: 6px;
    text-transform: uppercase;
}

.session-item {
    font-size: 11px;
    color: #555;
    padding: 3px 0;
    line-height: 1.4;
}

/* Minimized badge view */
.timer-badge {
    padding: 10px 16px;
    font-size: 15px;
    font-weight: bold;
    color: white;
    background: linear-gradient(135deg, #4CAF50, #45a049);
    border-radius: 20px;
    cursor: pointer;
    user-select: none;
    transition: all 0.2s;
    box-shadow: 0 2px 8px rgba(76, 175, 80, 0.3);
}

.timer-badge:hover {
    transform: scale(1.08);
    box-shadow: 0 4px 12px rgba(76, 175, 80, 0.5);
}

/* Dark mode support */
body.dark-mode #timer-window {
    background: #2d2d2d;
    border-color: #4CAF50;
}

body.dark-mode .timer-task-name {
    color: #e0e0e0;
}

body.dark-mode .timer-display {
    background: #3a3a3a;
}

body.dark-mode .timer-label {
    color: #aaa;
}

body.dark-mode .session-item {
    color: #bbb;
}

body.dark-mode .timer-sessions {
    border-top-color: #444;
}



/* ============================================================
   TIME-DASHBOARD.CSS (Category: styles)
   ============================================================ */

/* @order: 66 */
/* @category: styles */

/* Time Tracking Dashboard Table */
.time-dashboard-table {
    width: 100%;
    border-collapse: collapse;
    font-size: 13px;
    background: white;
    border-radius: 8px;
    overflow: hidden;
}

.time-dashboard-table thead {
    background: linear-gradient(135deg, #f8f9fa, #e9ecef);
    border-bottom: 2px solid #dee2e6;
}

.time-dashboard-table th {
    padding: 12px 16px;
    font-weight: 600;
    color: #495057;
    text-align: center;
    user-select: none;
}

.time-dashboard-table th:hover {
    background: rgba(0, 0, 0, 0.05);
}

.time-dashboard-table tbody tr {
    border-bottom: 1px solid #f1f3f5;
    transition: background 0.15s ease;
}

.time-dashboard-table tbody tr:hover {
    background: #f8f9fa;
}

.time-dashboard-table td {
    padding: 12px 16px;
    color: #212529;
}

.time-dashboard-table tbody tr:last-child {
    border-bottom: none;
}

/* Dark mode support */
body.dark-mode .time-dashboard-table {
    background: #2d2d2d;
}

body.dark-mode .time-dashboard-table thead {
    background: linear-gradient(135deg, #3a3a3a, #2d2d2d);
    border-bottom-color: #444;
}

body.dark-mode .time-dashboard-table th {
    color: #e0e0e0;
}

body.dark-mode .time-dashboard-table tbody tr {
    border-bottom-color: #444;
}

body.dark-mode .time-dashboard-table tbody tr:hover {
    background: #3a3a3a;
}

body.dark-mode .time-dashboard-table td {
    color: #e0e0e0;
}



/* ============================================================
   DARK-MODE.CSS (Category: styles)
   ============================================================ */

/* @order: 70 */
/* @category: styles */

/* Dark Mode Styles */
body.dark-mode {
    background: #0a0a0a;
}

body.dark-mode #canvas-container {
    background: #000000;
}

/* Keep buttons white in dark mode, just add white borders */
body.dark-mode button.secondary {
    border: 1px solid rgba(255, 255, 255, 0.5);
}

body.dark-mode .task-node rect {
    fill: #2d3748;
    stroke: #4a5568;
    filter: drop-shadow(0 2px 8px rgba(0, 0, 0, 0.5));
}

body.dark-mode .task-node.done rect {
    fill: #2d4a2f;
    stroke: #48bb78;
    filter: drop-shadow(0 2px 8px rgba(72, 187, 120, 0.4));
}

body.dark-mode .task-node.working rect {
    fill: #4a3f2d;
    stroke: #ed8936;
    filter: drop-shadow(0 3px 10px rgba(237, 137, 54, 0.5));
}

body.dark-mode .task-node.in-progress rect {
    /* Inherit fill from dark mode base .task-node rect */
    stroke: #ffeb3b;  /* Bright pure yellow for dark mode */
    filter: drop-shadow(0 2px 6px rgba(255, 235, 59, 0.4));
}

body.dark-mode .task-node.parent-of-working rect {
    stroke: #ed8936;
    filter: drop-shadow(0 0 6px rgba(237, 137, 54, 0.5));
}

body.dark-mode .task-node.incomplete-child-of-working rect {
    stroke: #fc8181;
    filter: drop-shadow(0 0 4px rgba(252, 129, 129, 0.4));
}

body.dark-mode .task-node.selected rect {
    stroke: #4299e1;
    filter: drop-shadow(0 0 6px rgba(66, 153, 225, 0.7));
}

body.dark-mode .task-node text {
    fill: #e2e8f0;
}

body.dark-mode .preview-node rect {
    fill: #1a365d;
    stroke: #4299e1;
    stroke-width: 2;
    stroke-dasharray: 5,3;
    opacity: 0.7;
    filter: none;
}

body.dark-mode .preview-node text {
    fill: #90cdf4;
    opacity: 0.8;
    font-style: italic;
}

body.dark-mode .cursor-arrow path {
    stroke: #4299e1;
    fill: none;
    filter: drop-shadow(0 2px 4px rgba(0,0,0,0.5));
}

/* Dark mode: Only style VISIBLE lines, NOT hit lines */
body.dark-mode .link.dependency {
    stroke: #ffffff;
    stroke-width: 2.5;
    stroke-dasharray: 5,5;
}

body.dark-mode .link.parent-visible {
    stroke: #ffffff;
    stroke-width: 2.5;
}

body.dark-mode .link.other-parent {
    stroke: #ffffff;
    stroke-width: 2;
    stroke-dasharray: 3,3;
}

/* Keep hit lines transparent with 15px width for easy clicking */
body.dark-mode .link.dependency-hit,
body.dark-mode .link.parent-hit,
body.dark-mode .link.other-parent-hit {
    stroke: transparent;
    stroke-width: 15;
}

body.dark-mode .marker {
    fill: #ffffff;
}

body.dark-mode .link.dependency-hit:hover + .link.dependency,
body.dark-mode .link.parent-hit:hover + .link.parent-visible,
body.dark-mode .link.other-parent-hit:hover + .link.other-parent {
    stroke: #4299e1 !important;
}

body.dark-mode .link.selected {
    stroke: #4299e1 !important;
}

body.dark-mode .task-node:hover rect {
    filter: brightness(1.2);
}

/* Dark mode modal styling */
body.dark-mode .modal-content {
    background: #1e293b;
    color: #e2e8f0;
}

body.dark-mode .modal-content h2 {
    color: #f1f5f9;
}

body.dark-mode .modal-content p {
    color: #94a3b8;
}

body.dark-mode .modal-content button {
    background: rgba(59, 130, 246, 0.2);
    color: #60a5fa;
    border: 1px solid rgba(59, 130, 246, 0.4);
}

body.dark-mode .modal-content button:hover {
    background: rgba(59, 130, 246, 0.3);
    color: #93c5fd;
}

body.dark-mode .modal-content button.secondary {
    background: rgba(148, 163, 184, 0.15);
    color: #cbd5e1;
    border: 1px solid rgba(148, 163, 184, 0.3);
}

body.dark-mode .modal-content button.secondary:hover {
    background: rgba(148, 163, 184, 0.25);
    color: #e2e8f0;
}

body.dark-mode #import-textarea {
    background: #0f172a;
    color: #e2e8f0;
    border-color: #475569;
}

body.dark-mode #prompt-input {
    background: #0f172a;
    color: #e2e8f0;
    border-color: #475569;
}

body.dark-mode .node-menu {
    background: #1e293b;
    border: 1px solid #475569;
}

body.dark-mode .node-menu button {
    color: #e2e8f0;
}

body.dark-mode .node-menu button:hover {
    background: #334155;
}

body.dark-mode .node-menu .dependency-section {
    border-bottom-color: #475569;
}

body.dark-mode .node-menu .dependency-section h4 {
    color: #94a3b8;
}

body.dark-mode .node-menu .dependency-item span {
    color: #e2e8f0;
}

/* Dark mode dropdown and submenu styling */
body.dark-mode .dropdown-content {
    background: rgba(30, 41, 59, 0.98);
    border: 1px solid rgba(148, 163, 184, 0.3);
}

body.dark-mode .dropdown-item {
    color: #e2e8f0;
    border-bottom: 1px solid rgba(148, 163, 184, 0.15);
}

body.dark-mode .dropdown-item:hover {
    background: rgba(148, 163, 184, 0.2);
}

body.dark-mode .dropdown-item.special {
    background: rgba(156, 39, 176, 0.25);
}

body.dark-mode .dropdown-item.special:hover {
    background: rgba(156, 39, 176, 0.4);
}

body.dark-mode .dropdown-empty {
    color: rgba(226, 232, 240, 0.5);
}

body.dark-mode .submenu {
    background: rgba(30, 41, 59, 0.98);
    border: 1px solid rgba(148, 163, 184, 0.3);
}

body.dark-mode .submenu-item {
    color: #e2e8f0;
    border-bottom: 1px solid rgba(148, 163, 184, 0.15);
}

body.dark-mode .submenu-item:hover {
    background: rgba(148, 163, 184, 0.2);
}

body.dark-mode .submenu-item.special {
    background: rgba(156, 39, 176, 0.25);
}

body.dark-mode .submenu-item.special:hover {
    background: rgba(156, 39, 176, 0.4);
}

body.dark-mode .submenu-empty {
    color: rgba(226, 232, 240, 0.5);
}

body.dark-mode .submenu-nested {
    background: rgba(30, 41, 59, 0.98);
    border: 1px solid rgba(148, 163, 184, 0.3);
}

body.dark-mode .link-badge rect {
    fill: #1e88e5;
}

body.dark-mode .links-dropdown {
    background: #2a2a2a !important;
    border-color: #444 !important;
    color: #e0e0e0;
}

body.dark-mode .links-dropdown > div {
    border-bottom-color: #444 !important;
}

body.dark-mode .links-dropdown > div:hover {
    background-color: #333 !important;
}

/* Emoji picker dark mode */
body.dark-mode #emoji-custom-input {
    background: #0f172a;
    color: #e2e8f0;
    border-color: #475569;
}

body.dark-mode #emoji-picker-grid {
    background: #0f172a !important;
}


</style>
</head>
<body>
    <div id="controls">
        <button style="background: #9c27b0; color: white;" onclick="app.loadTestChecklist()" title="Load testing tasks for recent features">üß™ Test Checklist</button>
        <button class="secondary" onclick="app.toggleDarkMode()" id="darkModeToggle">üåô Dark Mode</button>
        <button class="secondary" onclick="app.toggleDebugCtrlMode()" id="debugCtrlToggle" title="Debug mode: All clicks/drags act as if Ctrl is pressed">üîß Debug: Ctrl OFF</button>
        <button class="secondary" onclick="app.showSettingsModal()" title="Customize appearance and behavior">‚öôÔ∏è Settings</button>
        <button class="secondary" onclick="app.showShortcutsModal()" title="View all keyboard shortcuts">‚ùì Shortcuts</button>
        <button class="secondary" onclick="app.showTimeTrackingDashboard()" title="View time tracking overview and export data">‚è±Ô∏è Time Tracking</button>
        <div class="dropdown">
            <button class="secondary" onclick="app.toggleHomesDropdown(event)" title="Quick navigation to saved homes">üè† Homes</button>
            <div id="homesDropdown" class="dropdown-content">
                <!-- Populated dynamically by renderHomesDropdown() -->
            </div>
        </div>
        <button class="secondary" onclick="app.exportData()">Export JSON</button>
        <button class="secondary" onclick="app.copyDataToClipboard(event)">Copy JSON</button>
        <button class="secondary" onclick="app.showImportModal()">Import JSON</button>
        <button class="secondary" onclick="app.repairWorkingTasks()">üîß Repair Data</button>
        <button class="secondary" onclick="app.clearAllData()">Clear All Data</button>
        <div class="info">
            <span id="shortcuts-help"></span>
        </div>
    </div>

    <div id="canvas-container">
        <svg id="canvas">
            <defs>
                <marker id="arrowhead" markerWidth="10" markerHeight="10" refX="9" refY="3" orient="auto">
                    <polygon points="0 0, 10 3, 0 6" class="marker" />
                </marker>
                <marker id="arrowhead-golden" markerWidth="10" markerHeight="10" refX="9" refY="3" orient="auto">
                    <polygon points="0 0, 10 3, 0 6" fill="#f59e0b" />
                </marker>
                <marker id="arrowhead-red" markerWidth="10" markerHeight="10" refX="9" refY="3" orient="auto">
                    <polygon points="0 0, 10 3, 0 6" fill="#f44336" />
                </marker>
                <marker id="arrowhead-green" markerWidth="10" markerHeight="10" refX="9" refY="3" orient="auto">
                    <polygon points="0 0, 10 3, 0 6" fill="#4caf50" />
                </marker>
                <marker id="arrowhead-temp-green" markerWidth="10" markerHeight="10" refX="9" refY="3" orient="auto">
                    <polygon points="0 0, 10 3, 0 6" fill="#28a745" />
                </marker>

                <!-- Priority stripe patterns for light mode (thin solid stripes) -->
                <pattern id="priority-high-light" x="0" y="0" width="8" height="8" patternUnits="userSpaceOnUse" patternTransform="rotate(45)">
                    <rect x="0" y="0" width="8" height="8" fill="#fff" />
                    <rect x="0" y="0" width="1.5" height="8" fill="#ffcdd2" />
                </pattern>
                <pattern id="priority-medium-light" x="0" y="0" width="8" height="8" patternUnits="userSpaceOnUse" patternTransform="rotate(45)">
                    <rect x="0" y="0" width="8" height="8" fill="#fff" />
                    <rect x="0" y="0" width="1.5" height="8" fill="#ffe0b2" />
                </pattern>

                <!-- Priority stripe patterns for dark mode (thin solid stripes) -->
                <pattern id="priority-high-dark" x="0" y="0" width="8" height="8" patternUnits="userSpaceOnUse" patternTransform="rotate(45)">
                    <rect x="0" y="0" width="8" height="8" fill="#2d3748" />
                    <rect x="0" y="0" width="1.5" height="8" fill="#d32f2f" />
                </pattern>
                <pattern id="priority-medium-dark" x="0" y="0" width="8" height="8" patternUnits="userSpaceOnUse" patternTransform="rotate(45)">
                    <rect x="0" y="0" width="8" height="8" fill="#2d3748" />
                    <rect x="0" y="0" width="1.5" height="8" fill="#f57c00" />
                </pattern>
            </defs>
            <g id="links"></g>
            <g id="nodes"></g>
        </svg>

        <!-- Off-screen indicators for working tasks and homes -->
        <div class="offscreen-indicators" id="offscreen-indicators"></div>
    </div>

    <div id="import-modal" class="modal">
        <div class="modal-content">
            <h2>Import Data</h2>
            <p>Choose a .zip or .json file, or paste JSON below:</p>
            <input type="file" id="import-file" accept=".zip,.json" style="width: 100%; padding: 8px; margin-bottom: 10px; border: 1px solid #ccc; border-radius: 4px;">
            <p style="text-align: center; margin: 10px 0; color: #666;">‚Äî OR ‚Äî</p>
            <textarea id="import-textarea" placeholder="Paste JSON here..."></textarea>
            <div class="modal-buttons">
                <button onclick="app.importData()">Import</button>
                <button class="secondary" onclick="app.hideImportModal()">Cancel</button>
            </div>
        </div>
    </div>

    <div id="confirm-modal" class="modal">
        <div class="modal-content">
            <h2 id="confirm-title"></h2>
            <p id="confirm-message"></p>
            <div class="modal-buttons">
                <button id="confirm-yes">Yes</button>
                <button class="secondary" id="confirm-no">Cancel</button>
            </div>
        </div>
    </div>

    <div id="alert-modal" class="modal">
        <div class="modal-content">
            <h2 id="alert-title"></h2>
            <p id="alert-message"></p>
            <div class="modal-buttons">
                <button id="alert-ok">OK</button>
            </div>
        </div>
    </div>

    <div id="prompt-modal" class="modal">
        <div class="modal-content">
            <h2 id="prompt-title"></h2>
            <p id="prompt-message"></p>
            <input type="text" id="prompt-input" placeholder="" style="width: 100%; padding: 8px; margin: 10px 0; font-size: 14px; border: 1px solid #ccc; border-radius: 4px;">
            <div class="modal-buttons">
                <button id="prompt-ok">OK</button>
                <button class="secondary" id="prompt-cancel">Cancel</button>
            </div>
        </div>
    </div>

    <div id="settings-modal" class="modal">
        <div class="modal-content" style="max-width: 600px; max-height: 85vh; overflow-y: auto; padding: 16px;">
            <h2 style="margin-bottom: 8px;">‚öôÔ∏è Settings</h2>
            <p style="color: #666; font-size: 12px; margin-bottom: 12px;">Customize appearance and behavior</p>
            <div id="settings-form"></div>

            <!-- History Management Section -->
            <div style="margin-top: 20px; padding-top: 12px; border-top: 2px solid #ddd;">
                <h3 style="margin-bottom: 10px; font-size: 15px;">üìú History Management</h3>
                <div id="history-stats" style="background: #f5f5f5; padding: 10px; border-radius: 4px; margin-bottom: 10px; font-size: 12px;">
                    <div style="margin-bottom: 6px;">
                        <strong>Current History:</strong>
                    </div>
                    <ul style="margin: 0; padding-left: 20px; font-size: 11px;">
                        <li>Undo steps: <span id="undo-count">0</span> / <span id="undo-limit">50</span></li>
                        <li>Redo steps: <span id="redo-count">0</span></li>
                        <li>Memory estimate: ~<span id="history-size">0</span> KB</li>
                    </ul>
                </div>
                <button
                    onclick="app.clearUndoHistory()"
                    style="background: #f44336; color: white; border: 1px solid #d32f2f; padding: 8px 12px; border-radius: 4px; cursor: pointer; font-size: 13px; width: 100%;"
                    onmouseover="this.style.background='#d32f2f'"
                    onmouseout="this.style.background='#f44336'">
                    üóëÔ∏è Clear Undo/Redo History
                </button>
                <p style="font-size: 11px; color: #666; margin-top: 6px; margin-bottom: 0;">
                    Removes all undo/redo history to free up storage space. This action cannot be undone.
                </p>
            </div>

            <div class="modal-buttons">
                <button onclick="app.applySettings()">Apply</button>
                <button class="secondary" onclick="app.exportSettings()">Export Settings</button>
                <button class="secondary" onclick="app.resetSettings()">Reset to Defaults</button>
                <button class="secondary" onclick="app.hideSettingsModal()">Cancel</button>
            </div>
        </div>
    </div>

    <div id="create-home-modal" class="modal">
        <div class="modal-content">
            <h2>Create New Home</h2>
            <p>Enter a name for this home bookmark:</p>
            <input type="text" id="home-name-input" placeholder="Home name..." maxlength="50" />
            <p style="font-size: 12px; color: #666; margin-top: 8px;">
                This will save your current view position and zoom level.
            </p>
            <div class="modal-buttons">
                <button onclick="app.createHomeFromModal()">Create</button>
                <button class="secondary" onclick="app.hideCreateHomeModal()">Cancel</button>
            </div>
        </div>
    </div>

    <div id="manage-homes-modal" class="modal">
        <div class="modal-content" style="max-width: 600px;">
            <h2>üè† Manage Homes</h2>
            <p style="color: #666; font-size: 13px; margin-bottom: 16px;">
                Manage your saved home bookmarks
            </p>
            <div id="homes-list" style="max-height: 400px; overflow-y: auto; margin-bottom: 20px;">
                <!-- Populated dynamically by renderManageHomesModal() -->
            </div>
            <div class="modal-buttons">
                <button class="secondary" onclick="app.hideManageHomesModal()">Close</button>
            </div>
        </div>
    </div>

    <div id="shortcuts-modal" class="modal">
        <div class="modal-content" style="max-width: 700px; max-height: 85vh; overflow-y: auto;">
            <h2>‚å®Ô∏è Keyboard Shortcuts</h2>
            <p id="shortcuts-platform-info" style="color: #666; font-size: 13px; margin-bottom: 20px;"></p>

            <div id="shortcuts-content" style="display: grid; gap: 24px;">
                <!-- Populated dynamically by showShortcutsModal() -->
            </div>

            <div class="modal-buttons" style="margin-top: 24px;">
                <button onclick="app.hideShortcutsModal()">Close</button>
            </div>
        </div>
    </div>

    <div id="time-history-modal" class="modal">
        <div class="modal-content" style="max-width: 600px; max-height: 85vh; overflow-y: auto;">
            <h2>‚è±Ô∏è Time Tracking History</h2>
            <div id="time-history-content">
                <!-- Populated dynamically by showTimeHistoryModal() -->
            </div>
            <div class="modal-buttons" style="margin-top: 20px;">
                <button onclick="app.hideTimeHistoryModal()">Close</button>
            </div>
        </div>
    </div>

    <div id="time-dashboard-modal" class="modal">
        <div class="modal-content" style="max-width: 900px; max-height: 85vh; overflow-y: auto;">
            <h2>‚è±Ô∏è Time Tracking Dashboard</h2>
            <div id="time-dashboard-content">
                <!-- Populated dynamically by showTimeTrackingDashboard() -->
            </div>
            <div class="modal-buttons" style="margin-top: 20px;">
                <button onclick="app.hideTimeTrackingDashboard()">Close</button>
            </div>
        </div>
    </div>

    <div id="emoji-picker-modal" class="modal">
        <div class="modal-content" style="max-width: 500px;">
            <h2 id="emoji-picker-title">Select Emoji Icon</h2>
            <p style="color: #666; font-size: 13px; margin-bottom: 16px;">Click an emoji or type one in the box:</p>
            <input type="text" id="emoji-custom-input" placeholder="Or type/paste an emoji..." maxlength="10" style="width: 100%; padding: 8px; margin-bottom: 16px; font-size: 24px; text-align: center; border: 1px solid #ccc; border-radius: 4px;">
            <div id="emoji-picker-grid" style="display: grid; grid-template-columns: repeat(8, 1fr); gap: 8px; max-height: 300px; overflow-y: auto; padding: 8px; background: #f5f5f5; border-radius: 4px;">
                <!-- Populated dynamically by showEmojiPicker() -->
            </div>
            <div class="modal-buttons" style="margin-top: 16px;">
                <button id="emoji-picker-ok">OK</button>
                <button class="secondary" id="emoji-picker-cancel">Cancel</button>
            </div>
        </div>
    </div>

    <div id="status-bar">
        <span class="status-label">Working on:</span>
        <span id="status-path"></span>
        <span class="status-detail" id="status-children"></span>
        <div style="display: flex; gap: 0; margin-left: auto;">
            <button id="jump-to-working-btn" class="status-btn" onclick="app.jumpToWorkingTask()" style="border-radius: 4px 0 0 4px; padding-right: 8px; margin-left: 0;">
                üéØ Jump
            </button>
            <button id="jump-dropdown-btn" class="status-btn" onclick="app.showWorkingTasksDropdown(event)" style="border-radius: 0 4px 4px 0; padding: 4px 6px; border-left: 1px solid rgba(255,255,255,0.2); min-width: auto; margin-left: 0;" title="Choose working task">
                ‚ñ≤
            </button>
        </div>
    </div>

    <!-- Timer Window (floating) -->
    <div id="timer-window"></div>

    <script>

// ============================================================
// STATE.JS (Order: 1, Category: core)
// ============================================================

// @order: 1
// @category: core
// @description: Application state object - contains all app state and methods

/**
 * Main application state object.
 *
 * All modules extend this object by adding methods via the mixin pattern.
 *
 * Structure:
 * - Core data: tasks, IDs, selection state
 * - Viewport: viewBox, zoom level
 * - Interaction: drag state, editing, selection
 * - Configuration: sizing, fonts, behavior
 * - Features: homes/bookmarks, undo/redo, multi-project
 */
const app = {
    // ========================================
    // Core Data
    // ========================================
    tasks: [],                   // Array of all task objects
    taskIdCounter: 0,            // Unique ID generator for tasks

    // ========================================
    // Viewport & Navigation
    // ========================================
    viewBox: { x: 0, y: 0, width: window.innerWidth, height: window.innerHeight - 60 },
    zoomLevel: 1,                // Current zoom level (0.2 to 4)
    minZoom: 0.2,                // Minimum zoom level
    maxZoom: 4,                  // Maximum zoom level
    zoomSpeed: 0.1,              // Keyboard zoom increment (Ctrl +/-)
    wheelZoomSpeed: 0.18,        // Wheel/trackpad zoom speed

    // ========================================
    // Selection State
    // ========================================
    selectedNode: null,          // Legacy single selection (deprecated)
    selectedTaskIds: new Set(),  // Multi-select: Set of task IDs
    lastClickedTaskId: null,     // For Shift+Click range selection
    hoveredTaskId: null,         // For hover-based priority changes
    lastWorkingTaskId: null,     // Track last selected/cycled working task for Jump button
    suggestedNextTaskId: null,   // Suggested next task to work on (shown in purple)
    selectedLine: null,          // Selected relationship line {type: 'parent'|'dependency', taskId, parentId/depId}

    // ========================================
    // Box Selection
    // ========================================
    boxSelectStart: null,        // {x, y} when Shift+Click+Drag starts on empty space
    isBoxSelecting: false,       // True during box selection drag

    // ========================================
    // Drag State
    // ========================================
    dragMode: null,              // Current drag mode: 'node'|'subtree'|'reparent'|'dependency'|'pan'|'box-select'
    dragStart: { x: 0, y: 0 },   // Mouse position when drag started (SVG coords)
    dragOriginalPos: { x: 0, y: 0 }, // Original position for click detection
    tempLine: null,              // Temporary line during dependency/reparent drag
    draggedSubtree: [],          // Array of task IDs being dragged together (subtree mode)
    subtreeOriginalPositions: {},// Original positions for subtree drag {taskId: {x, y}}
    previewNode: null,           // Preview node during reparent drag
    cursorArrow: null,           // Custom arrow cursor during relationship drags

    // ========================================
    // UI State
    // ========================================
    darkMode: false,             // Dark theme enabled
    editingTaskId: null,         // Task currently being edited inline (null if not editing)
    debugCtrlMode: false,        // Debug mode: treat all clicks/drags as if Ctrl is pressed

    // ========================================
    // Arrow Snap Points
    // ========================================
    arrowDotDrag: {
        active: false,           // Is arrow dot drag in progress?
        dotType: null,           // 'source' or 'target' (which end of arrow)
        taskId: null,            // Task being modified
        relatedTaskId: null,     // Parent (for target) or child (for source)
        edge: null,              // Current edge: 'top'|'right'|'bottom'|'left'
        normalized: 0.5,         // Position along edge (0-1)
        lastRenderTime: 0,       // For throttling renders during drag
        lastClickTime: 0,        // Track last click time for double-click detection
        lastClickedDotId: null   // Track which dot was last clicked (taskId-parentId)
    },
    hoveredArrowDot: null,       // Currently hovered arrow dot {type, taskId, relatedTaskId}
    arrowDotRadius: 15,          // Hover detection radius (px) - increased for easier detection
    arrowDotHideRadius: 30,      // Hide dot when cursor is further than this (px)
    arrowDotSize: 4,             // Default dot size (px) - very small
    arrowDotHoverSize: 5,        // Hover dot size (px) - very small
    arrowDotDragSize: 7,         // Dragging dot size (px) - small
    arrowSnapThreshold: 10,      // Snap detection threshold (px) - increased for easier snapping
    arrowDragThrottleFps: 60,    // Render throttle during drag (not used - real-time now)

    // ========================================
    // Curve Control Points (Bezier handles)
    // ========================================
    curveDotDrag: {
        active: false,           // Is curve control point drag in progress?
        taskId: null,            // Task ID
        parentId: null,          // Parent ID
        controlPoints: [],       // Array of control points being edited
        editingIndex: null,      // Index of point being dragged
        isNewPoint: false,       // True if adding new point
        initialX: 0,             // Initial position for cancel check
        initialY: 0,
        lastClickTime: 0,        // For double-click detection
        lastClickedDotId: null   // For double-click detection
    },
    hoveredCurveDot: null,       // Currently hovered curve control dot {linkType, taskId, relatedTaskId, x, y}
    curveDotRadius: 15,          // Hover detection radius (px)
    curveDotHideRadius: 40,      // Hide dot when cursor is further than this (px)
    curveDotSize: 5,             // Default dot size (px)
    curveDotHoverSize: 6,        // Hover dot size (px)
    curveDotDragSize: 8,         // Dragging dot size (px)

    // ========================================
    // Text & Typography Configuration
    // ========================================
    textLengthThreshold: 80,     // Character limit before truncation
    charWidth: 8.5,              // Pixels per character for width calculation
    nodePadding: 15,             // Left/right padding inside task rectangles
    minNodeWidth: 100,           // Minimum rectangle width
    fontFamily: "'Fira Code', 'Consolas', 'Monaco', 'Courier New', monospace",
    fontWeight: 700,             // Font weight: 400=normal, 500=medium, 600=semibold, 700=bold
    tabWidth: 4,                 // Number of spaces per tab character for SVG display

    // ========================================
    // Multiline Text Configuration
    // ========================================
    enableMultiline: true,       // Master toggle for multiline text support
    maxNodeWidth: 600,           // Maximum node width before wrapping
    maxNodeHeight: 0,            // Maximum node height (0 = unlimited)
    lineHeight: 20,              // Vertical spacing between lines (pixels)
    wordWrap: true,              // Wrap on word boundaries (vs character boundaries)

    // ========================================
    // Markdown Formatting
    // ========================================
    enableMarkdown: true,        // Parse markdown syntax in task titles
    // Supported: **bold**, *italic*, `code`, - bullets, [links](url)

    // ========================================
    // Visual Styling
    // ========================================
    arrowStyle: 'straight',      // Arrow path style: 'straight' or 'curved'
    arrowCurvature: 0.25,        // Curve intensity for curved arrows (0.1 to 0.5)
    arrowOppositeEdge: true,     // Arrows land on opposite edge (center of far side) instead of nearest edge
    arrowRoutingMode: 'direct',  // Arrow routing: 'direct' (straight/curved) or 'orthogonal' (90-degree turns)
    orthogonalCornerRadius: 15,  // Corner radius for orthogonal routing (0 = sharp corners, 30 = smooth)

    // ========================================
    // Alignment Snapping
    // ========================================
    enableSnapping: true,        // Enable alignment snapping when dragging
    snapThreshold: 10,           // Distance in pixels for snap to activate
    activeSnapLines: [],         // Current snap lines to render: [{type: 'vertical'|'horizontal', position: number, alignType: 'edge'|'center'}]

    // ========================================
    // Grid System
    // ========================================
    gridEnabled: false,          // Show grid on canvas
    gridSize: 20,                // Grid cell size in pixels
    gridSnapEnabled: true,       // Snap tasks to grid when grid is enabled
    gridColor: 'rgba(200, 200, 200, 0.2)', // Grid line color (light gray, semi-transparent)

    // ========================================
    // Homes/Bookmarks
    // ========================================
    homes: [],                   // Array of {id, name, centerX, centerY, zoomLevel, timestamp, keybind}
    homeIdCounter: 1,            // Unique ID generator for homes

    // ========================================
    // Platform Detection
    // ========================================
    isMac: navigator.platform.toUpperCase().indexOf('MAC') >= 0,
    isWindows: navigator.platform.toUpperCase().indexOf('WIN') >= 0,
    isLinux: navigator.platform.toUpperCase().indexOf('LINUX') >= 0,

    // ========================================
    // Undo/Redo System
    // ========================================
    undoStack: [],               // Array of {tasks: [], description: string, timestamp: number}
    redoStack: [],               // Array for redo operations
    maxUndoSteps: 50,            // Maximum undo history depth
    isUndoing: false,            // Flag to prevent saveSnapshot during undo/redo
    lastSnapshotTime: 0,         // For 2-second edit grouping
    lastSnapshotTaskId: null,    // For grouping edits to same task

    // ========================================
    // Performance
    // ========================================
    saveDebounceTimer: null,     // Timer for debounced saves (canvas pan, etc.)

    // FPS Counter
    showFpsCounter: true,        // Show FPS counter overlay
    fpsFrameTimes: [],           // Array of recent frame timestamps
    fpsLastFrameTime: 0,         // Last frame timestamp
    fpsCurrentFps: 0,            // Current FPS
    fpsAverageFps: 0,            // Average FPS over last second
    fpsLagThreshold: 30,         // FPS below this triggers lag warning

    // ========================================
    // User Preferences
    // ========================================
    showDeleteConfirmation: true,  // Show confirmation dialog when deleting tasks
    autoHideCompletedNodes: true,  // Auto-hide nodes when task and parent are done

    // ========================================
    // Multi-Project Support
    // ========================================
    workingTasksByRoot: {},      // { [rootTaskId]: workingTaskId } - one working task per project/root

    // ========================================
    // Copy/Paste
    // ========================================
    copiedSubtree: null,         // Clipboard for copying/pasting subtrees (not persisted)
    lastMousePosition: { x: 0, y: 0 }, // Track last mouse position for Ctrl+V paste location

    // ========================================
    // Time Tracking
    // ========================================
    timerState: {
        isRunning: false,        // Is a timer currently running?
        taskId: null,            // ID of task being timed
        sessionStartTime: null,  // Unix timestamp when current session started
        intervalId: null         // setInterval ID for updating display
    },
    timerWindowMinimized: false, // Is timer window minimized to badge?
    autoStartTimer: true,        // Auto-start timer when marking task as "working"

    // ========================================
    // Methods will be added by module mixins
    // ========================================
    // Utils: platform.js, svg.js, cycle-detection.js
    // Data: persistence.js, undo-redo.js, import-export.js, clipboard.js
    // Core: tasks.js, status.js, relationships.js
    // Rendering: golden-path.js, indicators.js, nodes.js, links.js, render.js
    // Interactions: mouse.js, keyboard.js, drag.js, edit.js
    // UI: modals.js, context-menu.js, status-bar.js, settings.js, shortcuts.js, test-checklist.js, toast.js
    // Navigation: viewport.js, homes.js, jump.js, text-lock.js
};

console.log('‚úì App state initialized');



// ============================================================
// CONFIG.JS (Order: 2, Category: core)
// ============================================================

// @order: 2
// @category: core
// @description: Default configuration values and settings definitions

/**
 * Configuration Definitions
 *
 * Defines all user-customizable settings with metadata for the Settings modal.
 * Each config has:
 * - type: 'number' | 'text' | 'select' | 'checkbox'
 * - label: Display label in UI
 * - default: Default value
 * - description: Help text explaining the setting
 * - min/max: For number inputs
 * - options: For select dropdowns
 *
 * These are used by settings.js to generate the Settings modal UI.
 */

// Default configuration values (defined in state.js, documented here for reference)
const DEFAULT_CONFIG = {
    // Text & Typography
    charWidth: 8.5,
    nodePadding: 15,
    minNodeWidth: 100,
    maxNodeWidth: 600,
    maxNodeHeight: 0,
    lineHeight: 20,
    textLengthThreshold: 80,
    fontFamily: "'Fira Code', 'Consolas', 'Monaco', 'Courier New', monospace",
    fontWeight: 700,
    enableMultiline: true,
    wordWrap: true,

    // Visual Styling
    arrowStyle: 'straight',
    arrowCurvature: 0.25,

    // Zoom & Navigation
    minZoom: 0.2,
    maxZoom: 4,
    zoomSpeed: 0.1,
    wheelZoomSpeed: 0.18,

    // Behavior
    showDeleteConfirmation: true,
    autoHideCompletedNodes: true,
    maxUndoSteps: 50,
};

// Configuration metadata for Settings UI (used by settings.js)
const CONFIG_DEFINITIONS = {
    // Text & Typography Section
    textAndTypography: {
        label: 'üìù Text & Typography',
        settings: {
            fontFamily: {
                type: 'text',
                label: 'Font Family',
                default: DEFAULT_CONFIG.fontFamily,
                description: 'CSS font family stack for task text'
            },
            fontWeight: {
                type: 'select',
                label: 'Font Weight',
                default: 700,
                options: [
                    { value: 400, label: 'Normal (400)' },
                    { value: 500, label: 'Medium (500)' },
                    { value: 600, label: 'Semibold (600)' },
                    { value: 700, label: 'Bold (700)' }
                ],
                description: 'Text boldness'
            },
            charWidth: {
                type: 'number',
                label: 'Character Width (px)',
                default: DEFAULT_CONFIG.charWidth,
                min: 5,
                max: 15,
                step: 0.1,
                description: 'Pixels per character for node width calculation'
            },
            nodePadding: {
                type: 'number',
                label: 'Node Padding (px)',
                default: DEFAULT_CONFIG.nodePadding,
                min: 5,
                max: 30,
                description: 'Left/right padding inside task rectangles'
            },
            minNodeWidth: {
                type: 'number',
                label: 'Min Node Width (px)',
                default: DEFAULT_CONFIG.minNodeWidth,
                min: 50,
                max: 200,
                description: 'Minimum rectangle width'
            },
            textLengthThreshold: {
                type: 'number',
                label: 'Text Truncation Limit',
                default: DEFAULT_CONFIG.textLengthThreshold,
                min: 20,
                max: 200,
                description: 'Character limit before truncation'
            }
        }
    },

    // Multiline Text Section
    multilineText: {
        label: 'üìÑ Multiline Text',
        settings: {
            enableMultiline: {
                type: 'checkbox',
                label: 'Enable Multiline',
                default: DEFAULT_CONFIG.enableMultiline,
                description: 'Allow task text to wrap to multiple lines'
            },
            maxNodeWidth: {
                type: 'number',
                label: 'Max Node Width (px)',
                default: DEFAULT_CONFIG.maxNodeWidth,
                min: 100,
                max: 1000,
                description: 'Maximum node width before text wrapping'
            },
            maxNodeHeight: {
                type: 'number',
                label: 'Max Node Height (px, 0=unlimited)',
                default: DEFAULT_CONFIG.maxNodeHeight,
                min: 0,
                max: 500,
                description: 'Maximum node height (0 = unlimited)'
            },
            lineHeight: {
                type: 'number',
                label: 'Line Height (px)',
                default: DEFAULT_CONFIG.lineHeight,
                min: 12,
                max: 40,
                description: 'Vertical spacing between text lines'
            },
            wordWrap: {
                type: 'checkbox',
                label: 'Word Wrap',
                default: DEFAULT_CONFIG.wordWrap,
                description: 'Wrap on word boundaries (vs character boundaries)'
            }
        }
    },

    // Visual Styling Section
    visualStyling: {
        label: 'üé® Visual Styling',
        settings: {
            arrowStyle: {
                type: 'select',
                label: 'Arrow Style',
                default: DEFAULT_CONFIG.arrowStyle,
                options: [
                    { value: 'straight', label: 'Straight' },
                    { value: 'curved', label: 'Curved' }
                ],
                description: 'Relationship line style'
            },
            arrowCurvature: {
                type: 'number',
                label: 'Arrow Curvature',
                default: DEFAULT_CONFIG.arrowCurvature,
                min: 0.1,
                max: 0.5,
                step: 0.05,
                description: 'Curve intensity for curved arrows (0.1 to 0.5)'
            }
        }
    },

    // Zoom & Navigation Section
    zoomAndNavigation: {
        label: 'üîç Zoom & Navigation',
        settings: {
            minZoom: {
                type: 'number',
                label: 'Min Zoom',
                default: DEFAULT_CONFIG.minZoom,
                min: 0.1,
                max: 1,
                step: 0.1,
                description: 'Minimum zoom level'
            },
            maxZoom: {
                type: 'number',
                label: 'Max Zoom',
                default: DEFAULT_CONFIG.maxZoom,
                min: 2,
                max: 10,
                description: 'Maximum zoom level'
            },
            zoomSpeed: {
                type: 'number',
                label: 'Keyboard Zoom Speed',
                default: DEFAULT_CONFIG.zoomSpeed,
                min: 0.05,
                max: 0.3,
                step: 0.05,
                description: 'Zoom increment for Ctrl +/-'
            },
            wheelZoomSpeed: {
                type: 'number',
                label: 'Wheel Zoom Speed',
                default: DEFAULT_CONFIG.wheelZoomSpeed,
                min: 0.05,
                max: 0.5,
                step: 0.01,
                description: 'Zoom speed for wheel/trackpad'
            }
        }
    },

    // Behavior Section
    behavior: {
        label: '‚öôÔ∏è Behavior',
        settings: {
            showDeleteConfirmation: {
                type: 'checkbox',
                label: 'Show Delete Confirmation',
                default: DEFAULT_CONFIG.showDeleteConfirmation,
                description: 'Show confirmation dialog when deleting tasks'
            },
            autoHideCompletedNodes: {
                type: 'checkbox',
                label: 'Auto-Hide Completed',
                default: DEFAULT_CONFIG.autoHideCompletedNodes,
                description: 'Auto-hide nodes when task and parent are done'
            },
            maxUndoSteps: {
                type: 'number',
                label: 'Max Undo Steps',
                default: DEFAULT_CONFIG.maxUndoSteps,
                min: 10,
                max: 200,
                description: 'Maximum undo/redo history depth'
            }
        }
    }
};

console.log('‚úì Configuration loaded');



// ============================================================
// UTILS/PLATFORM.JS (Order: 5, Category: Utils)
// ============================================================

/**
 * @order 5
 * @category Utils
 * @description Platform detection and keyboard symbol utilities
 *
 * This module provides:
 * - Platform detection (Mac, Windows, Linux)
 * - Platform-specific keyboard modifier symbols (‚åò, Ctrl, ‚å•, Alt, ‚áß)
 * - Helper functions to get correct key names/symbols for UI display
 *
 * All functions are added as methods to the app object.
 */

// Platform detection (set once on app initialization)
// These are properties on the app object (not functions)
app.isMac = navigator.platform.toUpperCase().indexOf('MAC') >= 0;
app.isWindows = navigator.platform.toUpperCase().indexOf('WIN') >= 0;
app.isLinux = navigator.platform.toUpperCase().indexOf('LINUX') >= 0;

/**
 * Get platform-specific modifier key symbol/name
 * @param {boolean} short - If true, returns symbol (‚åò/Ctrl); if false, returns name (Cmd/Ctrl)
 * @returns {string} Modifier key representation
 */
app.getModifierKey = function(short = false) {
    // Returns the primary modifier key symbol/name for current platform
    // short = true: Returns '‚åò' or 'Ctrl'
    // short = false: Returns 'Cmd' or 'Ctrl'
    if (this.isMac) {
        return short ? '‚åò' : 'Cmd';
    }
    return 'Ctrl';
};

/**
 * Get platform-specific alt key symbol/name
 * @param {boolean} short - If true, returns symbol (‚å•/Alt); if false, returns name (Option/Alt)
 * @returns {string} Alt key representation
 */
app.getAltKey = function(short = false) {
    // Returns the Alt/Option key symbol/name for current platform
    // short = true: Returns '‚å•' or 'Alt'
    // short = false: Returns 'Option' or 'Alt'
    if (this.isMac) {
        return short ? '‚å•' : 'Option';
    }
    return 'Alt';
};

/**
 * Get platform-specific shift key symbol/name
 * @param {boolean} short - If true, returns symbol (‚áß/Shift); if false, returns name (Shift)
 * @returns {string} Shift key representation
 */
app.getShiftKey = function(short = false) {
    // Returns the Shift key symbol/name for current platform
    // short = true: Returns '‚áß' or 'Shift'
    // short = false: Returns 'Shift' (same on all platforms)
    return short && this.isMac ? '‚áß' : 'Shift';
};

console.log('[platform.js] Platform detection and keyboard utilities loaded');



// ============================================================
// UTILS/SVG.JS (Order: 6, Category: Utils)
// ============================================================

/**
 * @order 6
 * @category Utils
 * @description SVG coordinate transformation utilities
 *
 * This module provides:
 * - getSVGPoint() - Converts screen coordinates to SVG user space coordinates
 *
 * CRITICAL: This function accounts for zoom, pan, and viewBox transformations.
 * All mouse event handlers must use this to get accurate SVG coordinates.
 *
 * Implementation uses getScreenCTM() which handles all transformations automatically.
 */

/**
 * Convert screen coordinates (clientX, clientY) to SVG user space coordinates
 * @param {MouseEvent} e - Mouse event with clientX and clientY properties
 * @returns {Object} {x, y} coordinates in SVG user space
 */
app.getSVGPoint = function(e) {
    const svg = document.getElementById('canvas');
    const pt = svg.createSVGPoint();

    // Use raw screen coordinates - getScreenCTM handles all transformations
    pt.x = e.clientX;
    pt.y = e.clientY;

    // Transform from screen space to SVG user space
    const screenCTM = svg.getScreenCTM();
    if (screenCTM) {
        const transformed = pt.matrixTransform(screenCTM.inverse());

        // DEFENSIVE: Log if we get NaN coordinates
        if (!isFinite(transformed.x) || !isFinite(transformed.y)) {
            console.error('getSVGPoint returned NaN!', {
                clientX: e.clientX,
                clientY: e.clientY,
                screenCTM: screenCTM,
                transformed: transformed
            });
        }

        return transformed;
    }

    // DEFENSIVE: If no screenCTM, log warning
    console.warn('getScreenCTM returned null, returning untransformed point');
    return pt;
};

console.log('[svg.js] SVG coordinate utilities loaded');



// ============================================================
// UTILS/URL-HELPERS.JS (Order: 7, Category: utils)
// ============================================================

/**
 * @module utils/url-helpers
 * @order 7
 * @category utils
 *
 * URL extraction, validation, and formatting utilities
 *
 * KEY FUNCTIONS:
 *
 * extractURLsFromText(text) - Extract URLs from text
 * - Matches http://, https://, file:///, mailto: protocols
 * - Returns array of URL strings
 * - Cleans up trailing punctuation (., , ; : ! ?)
 * - Used during task editing to auto-detect pasted URLs
 *
 * removeURLsFromText(text) - Remove all URLs from text
 * - Removes http://, https://, file:///, mailto: URLs
 * - Cleans up extra whitespace
 * - Normalizes multiple blank lines to single
 * - Used to clean task title after extracting URLs
 *
 * shortenURL(url, maxLength) - Shorten URL for display
 * - Defaults to 30 character limit
 * - Removes protocol prefix for cleaner display
 * - Adds "..." ellipsis if truncated
 * - Used in link icons and context menus
 *
 * isValidURL(url) - Validate URL format
 * - Uses URL() constructor for validation
 * - Checks for allowed protocols: http:, https:, file:, mailto:
 * - Returns boolean
 * - Used before attaching links to tasks
 *
 * USAGE EXAMPLE:
 * const text = "Check out https://example.com for info";
 * const urls = app.extractURLsFromText(text);  // ["https://example.com"]
 * const clean = app.removeURLsFromText(text);  // "Check out for info"
 * const valid = app.isValidURL(urls[0]);       // true
 * const short = app.shortenURL(urls[0], 20);   // "example.com"
 */

// URL extraction and formatting utilities
app.extractURLsFromText = function(text) {
    // Match http://, https://, file:///, mailto: protocols
    const urlPattern = /(https?:\/\/[^\s]+)|(file:\/\/\/[^\s]+)|(mailto:[^\s]+)/gi;
    const matches = text.match(urlPattern) || [];

    // Clean up URLs (remove trailing punctuation like periods, commas)
    return matches.map(url => url.replace(/[.,;:!?)\]]+$/, ''));
};

app.removeURLsFromText = function(text) {
    // Remove all URLs from text
    const urlPattern = /(https?:\/\/[^\s]+)|(file:\/\/\/[^\s]+)|(mailto:[^\s]+)/gi;
    let cleanText = text.replace(urlPattern, '');

    // Clean up excessive blank lines (collapse multiple newlines)
    // Preserve leading/trailing whitespace - don't trim
    cleanText = cleanText.replace(/\n\s*\n+/g, '\n'); // Multiple blank lines ‚Üí single

    return cleanText;
};

app.shortenURL = function(url, maxLength = 30) {
    if (url.length <= maxLength) return url;

    // Remove protocol for display
    let display = url.replace(/^(https?:\/\/|file:\/\/\/|mailto:)/, '');

    if (display.length > maxLength) {
        return display.substring(0, maxLength - 3) + '...';
    }

    return display;
};

app.isValidURL = function(url) {
    try {
        const u = new URL(url);
        return ['http:', 'https:', 'file:', 'mailto:'].includes(u.protocol);
    } catch {
        return false;
    }
};

console.log('[url-helpers.js] URL extraction and formatting utilities loaded');



// ============================================================
// UTILS/CONSTANTS.JS (Order: 8, Category: Utils)
// ============================================================

/**
 * @module utils/constants
 * @order 8
 * @category Utils
 *
 * Application-wide constants
 * Eliminates magic numbers and provides single source of truth
 */

/**
 * Interaction Constants
 * Controls how user input is interpreted
 */
app.INTERACTION = {
    /**
     * Minimum pixels to move before drag activates
     * Used to distinguish between click and drag
     */
    DRAG_THRESHOLD_PX: 5,

    /**
     * Delay before click menu appears (ms)
     * Allows time for double-click detection
     */
    CLICK_DELAY_MS: 200,

    /**
     * Maximum time between clicks for double-click (ms)
     */
    DOUBLE_CLICK_MAX_MS: 300,

    /**
     * Paste offset distance (px)
     * How far to offset pasted tasks from original
     */
    PASTE_OFFSET_X: 100,
    PASTE_OFFSET_Y: 100,
};

/**
 * Animation Durations (milliseconds)
 * Controls timing for smooth viewport animations
 */
app.ANIMATION = {
    /** Zoom out duration for viewport animation */
    ZOOM_OUT_MS: 300,

    /** Pan/move duration for viewport animation */
    PAN_MS: 500,

    /** Zoom in duration for viewport animation */
    ZOOM_IN_MS: 500,

    /** Total animation time (zoom out + pan + zoom in) */
    TOTAL_MS: 1300,

    /**
     * Easing function for smooth animations
     * Ease-in-out quadratic curve
     * @param {number} t - Progress from 0 to 1
     * @returns {number} Eased value
     */
    EASING: (t) => t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t,
};

/**
 * UI Display Constants
 * Controls visual presentation
 */
app.UI = {
    /**
     * Default title truncation length
     * Note: Some contexts use app.textLengthThreshold from config
     */
    TITLE_MAX_LENGTH: 30,

    /**
     * Toast message durations by severity (ms)
     */
    TOAST_DURATION: {
        SUCCESS: 2000,   // Quick confirmation
        INFO: 3000,      // Standard information
        WARNING: 3000,   // User attention needed
        ERROR: 4000,     // Critical issues need more time
    },

    /**
     * Modal z-index for layering
     */
    MODAL_Z_INDEX: 1000,

    /**
     * Dropdown z-index (higher than modal)
     */
    DROPDOWN_Z_INDEX: 1100,
};

/**
 * Canvas/Rendering Constants
 * Controls how tasks are displayed
 */
app.CANVAS = {
    /**
     * Default viewBox dimensions
     */
    DEFAULT_WIDTH: 2000,
    DEFAULT_HEIGHT: 1500,

    /**
     * Zoom limits
     */
    MIN_ZOOM: 0.1,
    MAX_ZOOM: 3.0,

    /**
     * Grid snap distance (px)
     * Currently unused but reserved for future grid feature
     */
    GRID_SNAP: 10,
};

/**
 * Data/Storage Constants
 */
app.STORAGE = {
    /**
     * localStorage key prefix
     */
    KEY_PREFIX: 'task-tree-',

    /**
     * Maximum undo/redo stack size
     * Note: App has maxUndoSteps config that may override
     */
    MAX_UNDO_STEPS: 50,

    /**
     * Undo snapshot grouping time window (ms)
     * Edits within this window get grouped into one undo step
     */
    UNDO_GROUP_WINDOW_MS: 2000,
};

/**
 * Feature Flags
 * Quick toggles for experimental features
 */
app.FEATURES = {
    /**
     * Enable performance logging
     */
    DEBUG_PERFORMANCE: false,

    /**
     * Enable verbose console logging
     */
    DEBUG_VERBOSE: false,
};

console.log('[constants.js] Application constants loaded');



// ============================================================
// UTILS/GEOMETRY.JS (Order: 9, Category: Utils)
// ============================================================

/**
 * @module utils/geometry
 * @order 9
 * @category Utils
 *
 * Geometry utilities for arrow snap points and edge calculations
 */

Object.assign(app, {
    /**
     * Constrain a point to the nearest edge of a rectangle
     * Returns which edge and the normalized position (0-1) along that edge
     *
     * @param {number} mouseX - Mouse X position in SVG coordinates
     * @param {number} mouseY - Mouse Y position in SVG coordinates
     * @param {number} rectX - Rectangle center X
     * @param {number} rectY - Rectangle center Y
     * @param {number} rectWidth - Rectangle width
     * @param {number} rectHeight - Rectangle height
     * @returns {{edge: string, normalized: number}} Edge and normalized position
     */
    constrainToRectEdge(mouseX, mouseY, rectX, rectY, rectWidth, rectHeight) {
        // DEFENSIVE: Check for invalid inputs
        if (!isFinite(mouseX) || !isFinite(mouseY) || !isFinite(rectX) || !isFinite(rectY) ||
            !isFinite(rectWidth) || !isFinite(rectHeight)) {
            console.warn('[constrainToRectEdge] Invalid inputs:', { mouseX, mouseY, rectX, rectY, rectWidth, rectHeight });
            return { edge: 'top', normalized: 0.5 };
        }

        // Rectangle bounds
        const left = rectX - rectWidth / 2;
        const right = rectX + rectWidth / 2;
        const top = rectY - rectHeight / 2;
        const bottom = rectY + rectHeight / 2;

        // Calculate distances to each edge
        const distToTop = Math.abs(mouseY - top);
        const distToBottom = Math.abs(mouseY - bottom);
        const distToLeft = Math.abs(mouseX - left);
        const distToRight = Math.abs(mouseX - right);

        // Find closest edge
        const minDist = Math.min(distToTop, distToBottom, distToLeft, distToRight);

        let edge, normalized;

        if (minDist === distToTop) {
            edge = 'top';
            // Normalized position along top edge (0 = left, 1 = right)
            normalized = (mouseX - left) / rectWidth;
        } else if (minDist === distToBottom) {
            edge = 'bottom';
            // Normalized position along bottom edge (0 = left, 1 = right)
            normalized = (mouseX - left) / rectWidth;
        } else if (minDist === distToLeft) {
            edge = 'left';
            // Normalized position along left edge (0 = top, 1 = bottom)
            normalized = (mouseY - top) / rectHeight;
        } else {
            edge = 'right';
            // Normalized position along right edge (0 = top, 1 = bottom)
            normalized = (mouseY - top) / rectHeight;
        }

        // Clamp normalized to [0, 1]
        normalized = Math.max(0, Math.min(1, normalized));

        return { edge, normalized };
    },

    /**
     * Convert edge + normalized position back to absolute SVG coordinates
     *
     * @param {string} edge - 'top', 'right', 'bottom', or 'left'
     * @param {number} normalized - Position along edge (0-1)
     * @param {number} rectX - Rectangle center X
     * @param {number} rectY - Rectangle center Y
     * @param {number} rectWidth - Rectangle width
     * @param {number} rectHeight - Rectangle height
     * @returns {{x: number, y: number}} Absolute position
     */
    denormalizeEdgePosition(edge, normalized, rectX, rectY, rectWidth, rectHeight) {
        // DEFENSIVE: Check for invalid inputs
        if (!isFinite(normalized) || !isFinite(rectX) || !isFinite(rectY) ||
            !isFinite(rectWidth) || !isFinite(rectHeight)) {
            console.warn('[denormalizeEdgePosition] Invalid inputs:', { edge, normalized, rectX, rectY, rectWidth, rectHeight });
            return { x: rectX, y: rectY };
        }

        // Clamp normalized to [0, 1]
        normalized = Math.max(0, Math.min(1, normalized));

        const left = rectX - rectWidth / 2;
        const right = rectX + rectWidth / 2;
        const top = rectY - rectHeight / 2;
        const bottom = rectY + rectHeight / 2;

        let x, y;

        switch (edge) {
            case 'top':
                x = left + normalized * rectWidth;
                y = top;
                break;
            case 'bottom':
                x = left + normalized * rectWidth;
                y = bottom;
                break;
            case 'left':
                x = left;
                y = top + normalized * rectHeight;
                break;
            case 'right':
                x = right;
                y = top + normalized * rectHeight;
                break;
            default:
                console.warn('[denormalizeEdgePosition] Unknown edge:', edge);
                x = rectX;
                y = rectY;
        }

        return { x, y };
    },

    /**
     * Get all 8 snap positions for a rectangle (4 corners + 4 midpoints)
     *
     * @param {number} rectX - Rectangle center X
     * @param {number} rectY - Rectangle center Y
     * @param {number} rectWidth - Rectangle width
     * @param {number} rectHeight - Rectangle height
     * @returns {Array<{edge: string, normalized: number}>} Array of snap positions
     */
    getSnapPositions(rectX, rectY, rectWidth, rectHeight) {
        // DEFENSIVE: Guard against invalid inputs
        if (!isFinite(rectX) || !isFinite(rectY) || !isFinite(rectWidth) || !isFinite(rectHeight)) {
            console.warn('[getSnapPositions] Invalid inputs:', { rectX, rectY, rectWidth, rectHeight });
            return [];
        }

        return [
            // Top edge
            { edge: 'top', normalized: 0.0 },   // Top-left corner
            { edge: 'top', normalized: 0.5 },   // Top midpoint
            { edge: 'top', normalized: 1.0 },   // Top-right corner

            // Right edge
            { edge: 'right', normalized: 0.5 }, // Right midpoint

            // Bottom edge
            { edge: 'bottom', normalized: 1.0 }, // Bottom-right corner
            { edge: 'bottom', normalized: 0.5 }, // Bottom midpoint
            { edge: 'bottom', normalized: 0.0 }, // Bottom-left corner

            // Left edge
            { edge: 'left', normalized: 0.5 }   // Left midpoint
        ];
    },

    /**
     * Find nearest snap position within threshold
     *
     * @param {{edge: string, normalized: number}} currentPos - Current position
     * @param {Array<{edge: string, normalized: number}>} snapPositions - Available snap positions
     * @param {number} rectX - Rectangle center X
     * @param {number} rectY - Rectangle center Y
     * @param {number} rectWidth - Rectangle width
     * @param {number} rectHeight - Rectangle height
     * @param {number} threshold - Snap threshold in pixels (default 3)
     * @returns {{edge: string, normalized: number}|null} Snap position or null
     */
    findNearestSnap(currentPos, snapPositions, rectX, rectY, rectWidth, rectHeight, threshold = 3) {
        // DEFENSIVE: Validate inputs
        if (!currentPos || !snapPositions || !Array.isArray(snapPositions)) {
            console.warn('[findNearestSnap] Invalid inputs:', { currentPos, snapPositions });
            return null;
        }

        // Convert current position to absolute coordinates
        const currentAbsolute = this.denormalizeEdgePosition(
            currentPos.edge, currentPos.normalized,
            rectX, rectY, rectWidth, rectHeight
        );

        let nearestSnap = null;
        let minDistance = Infinity;

        // Find snaps on the same edge only
        const sameEdgeSnaps = snapPositions.filter(snap => snap.edge === currentPos.edge);

        sameEdgeSnaps.forEach(snap => {
            const snapAbsolute = this.denormalizeEdgePosition(
                snap.edge, snap.normalized,
                rectX, rectY, rectWidth, rectHeight
            );

            const distance = Math.sqrt(
                Math.pow(snapAbsolute.x - currentAbsolute.x, 2) +
                Math.pow(snapAbsolute.y - currentAbsolute.y, 2)
            );

            if (distance <= threshold && distance < minDistance) {
                minDistance = distance;
                nearestSnap = snap;
            }
        });

        return nearestSnap;
    },

    /**
     * Check if a point is within radius of another point
     * PERF: Uses squared distance to avoid Math.sqrt()
     *
     * @param {number} x1 - First point X
     * @param {number} y1 - First point Y
     * @param {number} x2 - Second point X
     * @param {number} y2 - Second point Y
     * @param {number} radius - Detection radius in pixels
     * @returns {boolean} True if within radius
     */
    isPointNearPosition(x1, y1, x2, y2, radius) {
        // DEFENSIVE: Check for NaN
        if (!isFinite(x1) || !isFinite(y1) || !isFinite(x2) || !isFinite(y2) || !isFinite(radius)) {
            return false;
        }

        // PERF: Compare squared distances to avoid Math.sqrt()
        const dx = x2 - x1;
        const dy = y2 - y1;
        const distanceSquared = dx * dx + dy * dy;
        const radiusSquared = radius * radius;

        return distanceSquared <= radiusSquared;
    },

    /**
     * Calculate pixel distance between two edge positions
     * Used for snap threshold detection
     *
     * @param {{edge: string, normalized: number}} pos1 - First position
     * @param {{edge: string, normalized: number}} pos2 - Second position
     * @param {number} rectX - Rectangle center X
     * @param {number} rectY - Rectangle center Y
     * @param {number} rectWidth - Rectangle width
     * @param {number} rectHeight - Rectangle height
     * @returns {number} Distance in pixels
     */
    calculateEdgeDistance(pos1, pos2, rectX, rectY, rectWidth, rectHeight) {
        // DEFENSIVE: Validate inputs
        if (!pos1 || !pos2) {
            console.warn('[calculateEdgeDistance] Invalid positions:', { pos1, pos2 });
            return Infinity;
        }

        const abs1 = this.denormalizeEdgePosition(pos1.edge, pos1.normalized, rectX, rectY, rectWidth, rectHeight);
        const abs2 = this.denormalizeEdgePosition(pos2.edge, pos2.normalized, rectX, rectY, rectWidth, rectHeight);

        const dx = abs2.x - abs1.x;
        const dy = abs2.y - abs1.y;

        return Math.sqrt(dx * dx + dy * dy);
    }
});



// ============================================================
// UTILS/MARKDOWN.JS (Order: 9, Category: Utils)
// ============================================================

/**
 * @module utils/markdown
 * @order 9
 * @category Utils
 * @description Lightweight markdown parser for task titles
 *
 * Supported syntax:
 * - **bold** ‚Üí bold text
 * - *italic* ‚Üí italic text
 * - `code` ‚Üí monospace code
 * - [text](url) ‚Üí clickable link
 * - "- " at line start ‚Üí "‚Ä¢ " bullet
 *
 * Returns tokens array: [{text, format, url?}, ...]
 * Formats: 'normal', 'bold', 'italic', 'code', 'link'
 */

Object.assign(app, {
    /**
     * Parse markdown syntax in a line of text
     * @param {string} line - Line of text with markdown
     * @returns {Array} Array of tokens: [{text, format, url?}, ...]
     */
    parseMarkdown(line) {
        if (!this.enableMarkdown || !line) {
            return [{ text: line || '', format: 'normal' }];
        }

        // Handle bullet points (including indented sub-bullets)
        // Match: optional whitespace + (- or *) + space
        // Preserves leading whitespace for indentation
        line = line.replace(/^(\s*)([-*])\s/, '$1‚Ä¢ ');

        const tokens = [];
        let remaining = line;
        let pos = 0;

        // Regex patterns for markdown syntax
        const patterns = [
            // Bold: **text**
            { regex: /\*\*(.+?)\*\*/,  format: 'bold' },
            // Code: `text`
            { regex: /`(.+?)`/,        format: 'code' },
            // Link: [text](url)
            { regex: /\[([^\]]+)\]\(([^)]+)\)/, format: 'link' },
            // Italic: *text* (must come after bold to avoid matching ** as two italics)
            { regex: /\*(.+?)\*/,      format: 'italic' }
        ];

        while (remaining.length > 0) {
            let earliestMatch = null;
            let earliestIndex = Infinity;
            let earliestPattern = null;

            // Find the earliest match
            for (const pattern of patterns) {
                const match = remaining.match(pattern.regex);
                if (match && match.index < earliestIndex) {
                    earliestMatch = match;
                    earliestIndex = match.index;
                    earliestPattern = pattern;
                }
            }

            if (!earliestMatch) {
                // No more markdown - add remaining text as normal
                if (remaining.length > 0) {
                    tokens.push({ text: remaining, format: 'normal' });
                }
                break;
            }

            // Add text before the match as normal
            if (earliestIndex > 0) {
                tokens.push({
                    text: remaining.substring(0, earliestIndex),
                    format: 'normal'
                });
            }

            // Add the formatted token
            if (earliestPattern.format === 'link') {
                tokens.push({
                    text: earliestMatch[1],  // Link text
                    format: 'link',
                    url: earliestMatch[2]    // URL
                });
            } else {
                tokens.push({
                    text: earliestMatch[1],  // Content inside markdown
                    format: earliestPattern.format
                });
            }

            // Continue with remaining text
            remaining = remaining.substring(earliestIndex + earliestMatch[0].length);
        }

        // If no tokens were created, return the original text as normal
        if (tokens.length === 0) {
            return [{ text: line, format: 'normal' }];
        }

        return tokens;
    }
});

console.log('[markdown.js] Markdown parsing module loaded');



// ============================================================
// UTILS/TASK-HELPERS.JS (Order: 9, Category: Utils)
// ============================================================

/**
 * @module utils/task-helpers
 * @order 9
 * @category Utils
 *
 * Task manipulation and validation utilities
 * Centralizes common task operations to eliminate code duplication
 */

Object.assign(app, {
    /**
     * Validate task has finite coordinates
     * Prevents NaN/Infinity rendering bugs
     *
     * @param {Object} task - Task object to validate
     * @returns {boolean} true if coordinates are valid, false otherwise
     */
    validateTaskCoordinates(task) {
        if (!task) {
            console.error('[VALIDATION] Cannot validate null/undefined task');
            return false;
        }

        if (!isFinite(task.x) || !isFinite(task.y)) {
            console.error(
                `[VALIDATION] Task ${task.id} "${task.title || 'Untitled'}" has invalid coords: (${task.x}, ${task.y})`
            );
            return false;
        }

        return true;
    },

    /**
     * Truncate title to maximum length with ellipsis
     *
     * @param {string} title - Task title to truncate
     * @param {number} maxLength - Maximum characters (default 30)
     * @returns {string} Truncated title with '...' if needed
     */
    truncateTitle(title, maxLength = 30) {
        if (!title) return '';
        if (typeof title !== 'string') return String(title);
        if (title.length <= maxLength) return title;
        return title.substring(0, maxLength - 3) + '...';
    },

    /**
     * Find task by ID with null safety
     * Prevents crashes from undefined task access
     *
     * @param {Array} tasks - Tasks array
     * @param {number} id - Task ID to find
     * @returns {Object|null} Task object or null if not found
     */
    findTaskById(tasks, id) {
        if (!tasks || !Array.isArray(tasks)) {
            console.warn('[TASK-HELPERS] findTaskById called with invalid tasks array');
            return null;
        }
        return tasks.find(t => t.id === id) || null;
    },

    /**
     * Get safe task title for display
     * Handles null/undefined tasks and empty titles
     *
     * @param {Object} task - Task object
     * @param {number} maxLength - Max length before truncation (default 30)
     * @returns {string} Safe display title
     */
    getTaskDisplayTitle(task, maxLength = 30) {
        if (!task) return 'Untitled';
        if (!task.title || task.title.trim() === '') return 'Untitled';
        return this.truncateTitle(task.title, maxLength);
    },

    /**
     * Get all ancestor tasks (parents, grandparents, etc.)
     * Useful for hierarchy traversal
     *
     * @param {Array} tasks - All tasks
     * @param {Object} task - Starting task
     * @returns {Array} Array of ancestor tasks (parent first, root last)
     */
    getAncestors(tasks, task) {
        const ancestors = [];
        let current = task;

        while (current && current.mainParent !== null) {
            const parent = this.findTaskById(tasks, current.mainParent);
            if (!parent) break; // Circular reference protection
            if (ancestors.includes(parent)) break; // Additional safety
            ancestors.push(parent);
            current = parent;
        }

        return ancestors;
    },

    /**
     * Get all descendant tasks (children, grandchildren, etc.)
     * Useful for subtree operations
     *
     * @param {Array} tasks - All tasks
     * @param {Object} task - Starting task
     * @param {boolean} includeHidden - Include hidden descendants (default false)
     * @returns {Array} Array of descendant tasks
     */
    getDescendants(tasks, task, includeHidden = false) {
        const descendants = [];
        const toProcess = [...(task.children || [])];
        const processed = new Set();

        while (toProcess.length > 0) {
            const childId = toProcess.shift();

            // Circular reference protection
            if (processed.has(childId)) continue;
            processed.add(childId);

            const child = this.findTaskById(tasks, childId);
            if (!child) continue;
            if (!includeHidden && child.hidden) continue;

            descendants.push(child);

            // Add grandchildren
            if (child.children) {
                toProcess.push(...child.children);
            }
        }

        return descendants;
    },

    /**
     * Check if task has any incomplete children
     * Used for status indicators
     *
     * @param {Array} tasks - All tasks
     * @param {Object} task - Parent task to check
     * @returns {boolean} true if has incomplete children
     */
    hasIncompleteChildren(tasks, task) {
        if (!task.children || task.children.length === 0) return false;

        for (const childId of task.children) {
            const child = this.findTaskById(tasks, childId);
            if (!child) continue;
            if (child.hidden) continue;
            if (child.status !== 'done') return true;
        }

        return false;
    },

    /**
     * Count visible children by status
     * Used for progress indicators
     *
     * @param {Array} tasks - All tasks
     * @param {Object} task - Parent task
     * @returns {Object} { total, done, pending, working }
     */
    countChildrenByStatus(tasks, task) {
        const counts = { total: 0, done: 0, pending: 0, working: 0 };

        if (!task.children) return counts;

        for (const childId of task.children) {
            const child = this.findTaskById(tasks, childId);
            if (!child || child.hidden) continue;

            counts.total++;
            if (child.currentlyWorking) {
                counts.working++;
            } else if (child.status === 'done') {
                counts.done++;
            } else {
                counts.pending++;
            }
        }

        return counts;
    },

    /**
     * Format task path for display (e.g., "Root > Parent > Task")
     * Used in status bar and tooltips
     *
     * @param {Array} tasks - All tasks
     * @param {Object} task - Task to format path for
     * @param {string} separator - Path separator (default ' > ')
     * @param {number} maxTitleLength - Max length per title (default 20)
     * @returns {string} Formatted path string
     */
    formatTaskPath(tasks, task, separator = ' > ', maxTitleLength = 20) {
        const ancestors = this.getAncestors(tasks, task);
        const path = [...ancestors.reverse(), task];

        return path
            .map(t => this.truncateTitle(t.title || 'Untitled', maxTitleLength))
            .join(separator);
    },
});

console.log('[task-helpers.js] Task validation and manipulation helpers loaded');



// ============================================================
// DATA/UNDO-REDO.JS (Order: 10, Category: Data)
// ============================================================

/**
 * @order 10
 * @category Data
 * @description Undo/Redo system implementation
 *
 * This module provides:
 * - saveSnapshot() - Captures current state before modifications (with smart grouping)
 * - undo() - Restores previous state from undoStack
 * - redo() - Restores future state from redoStack
 * - enforceUndoLimit() - Trims undo history to configured limit
 * - clearUndoHistory() - Clears all undo/redo history (with confirmation)
 *
 * SNAPSHOT-BASED APPROACH:
 * - undoStack: Array of {tasks, description, timestamp} snapshots (max 50)
 * - redoStack: Array of snapshots for redo operations
 * - isUndoing: Flag to prevent recursive snapshots during undo/redo
 *
 * SMART GROUPING:
 * - Edits to same task within 2 seconds are grouped (prevents char-by-char undo)
 * - Detected by taskId parameter and timestamp comparison
 *
 * INTEGRATION CHECKLIST (19 integration points):
 * See inline comments in saveSnapshot() for complete list of integrated operations
 *
 * IMPORTANT: New operations that modify tasks MUST call saveSnapshot() BEFORE modification
 */

/**
 * Save current state to undo stack before modifying tasks
 * @param {string} description - Human-readable action description
 * @param {number|null} taskId - Optional task ID for smart grouping of repeated edits
 */
app.saveSnapshot = function(description, taskId = null) {
    // SNAPSHOT MECHANISM:
    // Call this BEFORE modifying this.tasks to save current state for undo
    // Creates deep clone of tasks array and stores it in undoStack
    // Clears redoStack (new action invalidates future states)
    //
    // PARAMETERS:
    // - description: Human-readable action description (e.g., "Created task")
    // - taskId: Optional - for smart grouping of repeated edits to same task
    //
    // SMART GROUPING:
    // If editing same task within 2 seconds, replaces last snapshot instead
    // of creating new one (prevents character-by-character undo when typing)

    // Don't save during undo/redo operations (prevents infinite loops)
    if (this.isUndoing) return;

    const now = Date.now();
    const timeSinceLastSnapshot = now - this.lastSnapshotTime;

    // Smart grouping: Replace last snapshot if editing same task within 2 seconds
    const shouldGroup =
        taskId !== null &&
        taskId === this.lastSnapshotTaskId &&
        timeSinceLastSnapshot < 2000 &&
        this.undoStack.length > 0 &&
        this.undoStack[this.undoStack.length - 1].description.startsWith('Edited task');

    if (shouldGroup) {
        // Replace the last snapshot instead of creating a new one
        this.undoStack[this.undoStack.length - 1] = {
            tasks: JSON.parse(JSON.stringify(this.tasks)),
            description: description,
            timestamp: now
        };
    } else {
        // Create new snapshot
        const snapshot = {
            tasks: JSON.parse(JSON.stringify(this.tasks)),
            description: description,
            timestamp: now
        };

        this.undoStack.push(snapshot);

        // Enforce undo limit
        this.enforceUndoLimit();
    }

    // Clear redo stack when new action is performed
    this.redoStack = [];

    // Update tracking for grouping
    this.lastSnapshotTime = now;
    this.lastSnapshotTaskId = taskId;
};

// ========================================================================
// ‚ö†Ô∏è UNDO/REDO INTEGRATION CHECKLIST ‚ö†Ô∏è
// ========================================================================
// When adding a NEW operation that modifies task data, you MUST call
// this.saveSnapshot("Description") BEFORE the modification.
//
// CURRENT INTEGRATION POINTS (19 total):
// ‚úÖ addChildTask() - line 1878
// ‚úÖ addRootTaskAtPosition() - line 1949
// ‚úÖ cycleStatus() - lines 1981+ (3 state transitions)
// ‚úÖ toggleDone() - lines 2050+ (done ‚Üî pending, also has flow-state logic)
// ‚úÖ toggleHidden() - line ~2180
// ‚úÖ deleteTask() - line ~2220
// ‚úÖ finishEditing() - line ~2430 (with smart grouping)
// ‚úÖ clearAllData() - line ~2450
// ‚úÖ importData() - line ~2950
// ‚úÖ Right-click menu creation - line ~4875
// ‚úÖ Move subtree - line 2454
// ‚úÖ Move single task - line 2473
// ‚úÖ addDependency() - lines 2579, 2596 (add & remove toggle)
// ‚úÖ removeDependency() - line 2608
// ‚ùå Canvas panning - INTENTIONALLY NOT UNDOABLE (viewport navigation)
//
// TYPES OF OPERATIONS:
// 1. Content Modification (MUST be undoable):
//    - Create/delete tasks
//    - Edit task properties
//    - Change relationships (parent/child, dependencies)
//    - Change task positions (moves individual tasks/subtrees)
//    - Change status (pending/working/done)
//    - Bulk operations (import, clear all)
//
// 2. Viewport Navigation (NOT undoable - doesn't clear redo stack):
//    - Pan canvas
//    - Zoom in/out
//    - Fit to screen
//
// HOW TO ADD UNDO TO A NEW OPERATION:
// 1. Identify: Is this a content modification or viewport navigation?
// 2. If content modification: Add this.saveSnapshot("Action description")
//    BEFORE modifying this.tasks
// 3. Use descriptive text: "Created task", "Deleted task 'Title'", etc.
// 4. For repeated edits to same task: Pass taskId as 2nd param for grouping
// 5. Update this checklist with the new integration point
// 6. Update README.md operation count and list
//
// TESTING YOUR INTEGRATION:
// 1. Perform the new operation
// 2. Press Ctrl+Z ‚Üí Should undo the operation
// 3. Press Ctrl+Shift+Z ‚Üí Should redo the operation
// 4. Do operation, pan canvas, undo ‚Üí Redo should still work (redo not cleared)
// ========================================================================

// Development helper: Detect if tasks array was modified without snapshot
// Uncomment during development to catch missing saveSnapshot() calls
/*
app._trackTasksModification = function() {
    const currentHash = JSON.stringify(this.tasks.map(t => ({id: t.id, title: t.title, status: t.status})));
    if (this._lastTasksHash && this._lastTasksHash !== currentHash && !this.isUndoing) {
        console.warn('‚ö†Ô∏è UNDO/REDO WARNING: tasks array modified without saveSnapshot() call!');
        console.warn('Current stack:', new Error().stack);
    }
    this._lastTasksHash = currentHash;
};
*/

/**
 * Trim undoStack to enforce user-configured limit
 * Called after adding new snapshot and when user changes maxUndoSteps in Settings
 */
app.enforceUndoLimit = function() {
    // Trim undoStack if it exceeds user-configured limit
    // Called after adding new snapshot and when user changes maxUndoSteps in Settings
    while (this.undoStack.length > this.maxUndoSteps) {
        this.undoStack.shift(); // Remove oldest snapshot
    }
};

/**
 * Clear all undo/redo history (with confirmation dialog)
 * Called from Settings modal
 */
app.clearUndoHistory = function() {
    // Clear all undo/redo history (called from Settings modal)
    const undoCount = this.undoStack.length;
    const redoCount = this.redoStack.length;

    if (undoCount === 0 && redoCount === 0) {
        this.showToast('History is already empty', 'info');
        return;
    }

    // Show confirmation dialog
    this.showConfirm(
        'Clear Undo/Redo History?',
        `This will remove ${undoCount} undo steps and ${redoCount} redo steps. This action cannot be undone.`,
        () => {
            // On confirm
            this.undoStack = [];
            this.redoStack = [];
            this.saveToStorage();
            this.updateStatusBar();
            this.showToast(`‚úì History cleared (${undoCount + redoCount} steps removed)`, 'success');

            // Update stats in settings modal if it's open
            const modal = document.getElementById('settings-modal');
            if (modal && modal.classList.contains('show')) {
                document.getElementById('undo-count').textContent = '0';
                document.getElementById('redo-count').textContent = '0';
                document.getElementById('history-size').textContent = '0';
            }
        }
    );
};

/**
 * Undo the last operation
 * Restores previous state from undoStack and saves current state to redoStack
 */
app.undo = function() {
    // UNDO MECHANISM:
    // 1. Save current state to redoStack (so we can redo later)
    // 2. Pop snapshot from undoStack (the previous state)
    // 3. Restore tasks array from snapshot (deep clone)
    // 4. isUndoing flag prevents saveSnapshot() from being called during this process
    //    (otherwise saveToStorage() would trigger saveSnapshot() ‚Üí clear redoStack!)

    if (this.undoStack.length === 0) {
        this.showToast('Nothing to undo', 'error');
        return;
    }

    // Save current state to redo stack (so redo can restore it)
    this.isUndoing = true;  // Prevents saveSnapshot() from clearing redoStack
    const currentState = {
        tasks: JSON.parse(JSON.stringify(this.tasks)),  // Deep clone
        description: 'Current state',
        timestamp: Date.now()
    };
    this.redoStack.push(currentState);

    // Restore previous state from undo stack
    const snapshot = this.undoStack.pop();
    this.tasks = JSON.parse(JSON.stringify(snapshot.tasks));  // Deep clone

    this.isUndoing = false;
    this.saveToStorage();  // Persist both stacks to localStorage
    this.render();
    this.updateStatusBar();

    // Show what was undone
    const desc = snapshot.description.length > 50
        ? snapshot.description.substring(0, 47) + '...'
        : snapshot.description;
    this.showToast(`‚úì Undone: ${desc}`, 'success');
};

/**
 * Redo the last undone operation
 * Restores future state from redoStack and saves current state to undoStack
 */
app.redo = function() {
    // REDO MECHANISM:
    // 1. Save current state to undoStack (so we can undo the redo)
    // 2. Pop snapshot from redoStack (the "future" state we undid earlier)
    // 3. Restore tasks array from snapshot (deep clone)
    // 4. isUndoing flag prevents saveSnapshot() during this process
    //
    // SYMMETRY WITH UNDO:
    // - undo() moves snapshots: undoStack ‚Üí redoStack
    // - redo() moves snapshots: redoStack ‚Üí undoStack
    // Both save current state to opposite stack before restoring

    if (this.redoStack.length === 0) {
        this.showToast('Nothing to redo', 'error');
        return;
    }

    // Save current state to undo stack (so we can undo this redo)
    this.isUndoing = true;  // Prevents saveSnapshot() from clearing stacks
    const currentState = {
        tasks: JSON.parse(JSON.stringify(this.tasks)),  // Deep clone
        description: 'Current state',
        timestamp: Date.now()
    };
    this.undoStack.push(currentState);

    // Restore "future" state from redo stack
    const snapshot = this.redoStack.pop();
    this.tasks = JSON.parse(JSON.stringify(snapshot.tasks));  // Deep clone

    this.isUndoing = false;
    this.saveToStorage();  // Persist both stacks to localStorage
    this.render();
    this.updateStatusBar();

    // Show what was redone
    const desc = snapshot.description.length > 50
        ? snapshot.description.substring(0, 47) + '...'
        : snapshot.description;
    this.showToast(`‚úì Redone: ${desc}`, 'success');
};

console.log('[undo-redo.js] Undo/redo system loaded');



// ============================================================
// UTILS/TIMER.JS (Order: 10, Category: Utils)
// ============================================================

/**
 * @module utils/timer
 * @order 10
 * @category Utils
 * @description Time tracking utilities for task sessions
 */

Object.assign(app, {
    /**
     * Start a timer session for a task
     * @param {number} taskId - Task to start timing
     */
    startTimer(taskId) {
        const task = this.tasks.find(t => t.id === taskId);
        if (!task) {
            console.error(`[Timer] Task ${taskId} not found`);
            return;
        }

        // Stop any existing timer first
        if (this.timerState.isRunning) {
            this.stopTimer();
        }

        // Initialize timeTracking if needed
        if (!task.timeTracking) {
            task.timeTracking = {
                totalSeconds: 0,
                sessions: []
            };
        }

        // Start new session
        this.timerState.isRunning = true;
        this.timerState.taskId = taskId;
        this.timerState.sessionStartTime = Date.now();

        // Start interval to update UI every second
        this.timerState.intervalId = setInterval(() => {
            this.updateTimerDisplay();
        }, 1000);

        this.updateTimerDisplay();
        console.log(`[Timer] Started for task ${taskId}`);
    },

    /**
     * Stop the current timer session and save it
     */
    stopTimer() {
        if (!this.timerState.isRunning) {
            return; // No timer running
        }

        const taskId = this.timerState.taskId;
        const task = this.tasks.find(t => t.id === taskId);

        if (task && task.timeTracking) {
            const endTime = Date.now();
            const duration = Math.floor((endTime - this.timerState.sessionStartTime) / 1000); // seconds

            // Save session
            const session = {
                startTime: this.timerState.sessionStartTime,
                endTime: endTime,
                duration: duration
            };
            task.timeTracking.sessions.push(session);
            task.timeTracking.totalSeconds += duration;

            console.log(`[Timer] Stopped. Session: ${this.formatDuration(duration)}, Total: ${this.formatDuration(task.timeTracking.totalSeconds)}`);
        }

        // Clear interval
        if (this.timerState.intervalId) {
            clearInterval(this.timerState.intervalId);
            this.timerState.intervalId = null;
        }

        // Reset state
        this.timerState.isRunning = false;
        this.timerState.taskId = null;
        this.timerState.sessionStartTime = null;

        this.updateTimerDisplay();
        this.saveToStorage();
    },

    /**
     * Get current elapsed time in seconds for active session
     * @returns {number} Elapsed seconds
     */
    getCurrentSessionSeconds() {
        if (!this.timerState.isRunning) {
            return 0;
        }
        return Math.floor((Date.now() - this.timerState.sessionStartTime) / 1000);
    },

    /**
     * Get total time (including current session) for a task
     * @param {number} taskId - Task ID
     * @returns {number} Total seconds
     */
    getTotalTimeForTask(taskId) {
        const task = this.tasks.find(t => t.id === taskId);
        if (!task || !task.timeTracking) {
            return 0;
        }

        let total = task.timeTracking.totalSeconds;

        // Add current session if task is being timed
        if (this.timerState.isRunning && this.timerState.taskId === taskId) {
            total += this.getCurrentSessionSeconds();
        }

        return total;
    },

    /**
     * Format duration as HH:MM:SS
     * @param {number} seconds - Duration in seconds
     * @returns {string} Formatted duration
     */
    formatDuration(seconds) {
        const hours = Math.floor(seconds / 3600);
        const mins = Math.floor((seconds % 3600) / 60);
        const secs = seconds % 60;

        const pad = (n) => n.toString().padStart(2, '0');
        return `${pad(hours)}:${pad(mins)}:${pad(secs)}`;
    },

    /**
     * Format duration in compact form for badges (e.g., "2h 15m" or "15m")
     * @param {number} seconds - Duration in seconds
     * @returns {string} Compact formatted duration
     */
    formatDurationCompact(seconds) {
        const hours = Math.floor(seconds / 3600);
        const mins = Math.floor((seconds % 3600) / 60);

        if (hours > 0) {
            return mins > 0 ? `${hours}h ${mins}m` : `${hours}h`;
        } else if (mins > 0) {
            return `${mins}m`;
        } else {
            return '<1m';
        }
    },

    /**
     * Format timestamp as relative time (e.g., "2 hours ago")
     * @param {number} timestamp - Unix timestamp
     * @returns {string} Relative time string
     */
    formatRelativeTime(timestamp) {
        const now = Date.now();
        const diff = now - timestamp;
        const seconds = Math.floor(diff / 1000);
        const minutes = Math.floor(seconds / 60);
        const hours = Math.floor(minutes / 60);
        const days = Math.floor(hours / 24);

        if (seconds < 60) return 'just now';
        if (minutes < 60) return `${minutes} minute${minutes !== 1 ? 's' : ''} ago`;
        if (hours < 24) return `${hours} hour${hours !== 1 ? 's' : ''} ago`;
        if (days < 7) return `${days} day${days !== 1 ? 's' : ''} ago`;

        // Older than a week, show date
        const date = new Date(timestamp);
        return date.toLocaleDateString();
    },

    /**
     * Update timer window display (to be implemented in timer-window.js)
     */
    updateTimerDisplay() {
        // This will be implemented by timer-window.js
        // Placeholder for now
    }
});

console.log('[timer.js] Time tracking utilities loaded');



// ============================================================
// DATA/IMAGE-STORE.JS (Order: 11, Category: Data)
// ============================================================

/**
 * @order 11.5
 * @category Data
 * @description IndexedDB image storage for task images
 *
 * Provides binary image storage separate from localStorage
 * Uses IndexedDB for ~50MB+ capacity (hundreds of images)
 *
 * KEY FUNCTIONS:
 * - initImageStore() - Initialize IndexedDB database
 * - saveImage(blob, id) - Store image blob with optional custom ID
 * - getImage(id) - Retrieve image blob by ID
 * - deleteImage(id) - Delete image from store
 * - getAllImages() - Get all stored images (for export)
 * - clearAllImages() - Delete all images (for import/reset)
 */

Object.assign(app, {
    imageStore: null,  // IndexedDB database reference
    imageCache: new Map(),  // In-memory cache for loaded images (blob URLs)

    /**
     * Initialize IndexedDB for image storage
     * Called on app startup
     */
    async initImageStore() {
        return new Promise((resolve, reject) => {
            const request = indexedDB.open('TaskTreeImages', 1);

            request.onerror = () => {
                console.error('Failed to open IndexedDB:', request.error);
                this.showToast('‚ö†Ô∏è Image storage unavailable', 'warning', 3000);
                reject(request.error);
            };

            request.onsuccess = () => {
                this.imageStore = request.result;
                console.log('[image-store.js] IndexedDB initialized');
                resolve();
            };

            request.onupgradeneeded = (event) => {
                const db = event.target.result;

                // Create object store for images
                if (!db.objectStoreNames.contains('images')) {
                    const objectStore = db.createObjectStore('images', { keyPath: 'id' });
                    objectStore.createIndex('taskId', 'taskId', { unique: false });
                    console.log('[image-store.js] Created images object store');
                }
            };
        });
    },

    /**
     * Save image to IndexedDB
     * @param {Blob} blob - Image blob data
     * @param {string} id - Optional custom ID (defaults to generated ID)
     * @returns {Promise<string>} - Image ID
     */
    async saveImage(blob, id = null) {
        if (!this.imageStore) {
            await this.initImageStore();
        }

        // Generate ID if not provided
        const imageId = id || `img_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;

        return new Promise((resolve, reject) => {
            const transaction = this.imageStore.transaction(['images'], 'readwrite');
            const objectStore = transaction.objectStore('images');

            const imageData = {
                id: imageId,
                blob: blob,
                type: blob.type,
                size: blob.size,
                timestamp: Date.now()
            };

            const request = objectStore.put(imageData);

            request.onsuccess = () => {
                console.log(`[image-store.js] Saved image: ${imageId} (${Math.round(blob.size / 1024)}KB)`);
                resolve(imageId);
            };

            request.onerror = () => {
                console.error('Failed to save image:', request.error);
                reject(request.error);
            };
        });
    },

    /**
     * Get image from IndexedDB
     * @param {string} id - Image ID
     * @returns {Promise<Blob|null>} - Image blob or null if not found
     */
    async getImage(id) {
        if (!this.imageStore) {
            await this.initImageStore();
        }

        // Check cache first
        if (this.imageCache.has(id)) {
            const cachedUrl = this.imageCache.get(id);
            // Verify blob URL is still valid
            try {
                await fetch(cachedUrl);
                return cachedUrl;
            } catch {
                // Blob URL expired, remove from cache
                this.imageCache.delete(id);
            }
        }

        return new Promise((resolve, reject) => {
            const transaction = this.imageStore.transaction(['images'], 'readonly');
            const objectStore = transaction.objectStore('images');
            const request = objectStore.get(id);

            request.onsuccess = () => {
                if (request.result) {
                    const blob = request.result.blob;
                    // Create blob URL and cache it
                    const blobUrl = URL.createObjectURL(blob);
                    this.imageCache.set(id, blobUrl);
                    resolve(blobUrl);
                } else {
                    console.warn(`[image-store.js] Image not found: ${id}`);
                    resolve(null);
                }
            };

            request.onerror = () => {
                console.error('Failed to get image:', request.error);
                reject(request.error);
            };
        });
    },

    /**
     * Delete image from IndexedDB
     * @param {string} id - Image ID
     * @returns {Promise<boolean>} - Success status
     */
    async deleteImage(id) {
        if (!this.imageStore) {
            await this.initImageStore();
        }

        // Remove from cache
        if (this.imageCache.has(id)) {
            const blobUrl = this.imageCache.get(id);
            URL.revokeObjectURL(blobUrl);
            this.imageCache.delete(id);
        }

        return new Promise((resolve, reject) => {
            const transaction = this.imageStore.transaction(['images'], 'readwrite');
            const objectStore = transaction.objectStore('images');
            const request = objectStore.delete(id);

            request.onsuccess = () => {
                console.log(`[image-store.js] Deleted image: ${id}`);
                resolve(true);
            };

            request.onerror = () => {
                console.error('Failed to delete image:', request.error);
                reject(request.error);
            };
        });
    },

    /**
     * Get all images (for export)
     * @returns {Promise<Array>} - Array of {id, blob, type, size}
     */
    async getAllImages() {
        if (!this.imageStore) {
            await this.initImageStore();
        }

        return new Promise((resolve, reject) => {
            const transaction = this.imageStore.transaction(['images'], 'readonly');
            const objectStore = transaction.objectStore('images');
            const request = objectStore.getAll();

            request.onsuccess = () => {
                resolve(request.result);
            };

            request.onerror = () => {
                console.error('Failed to get all images:', request.error);
                reject(request.error);
            };
        });
    },

    /**
     * Clear all images (for import/reset)
     * @returns {Promise<boolean>} - Success status
     */
    async clearAllImages() {
        if (!this.imageStore) {
            await this.initImageStore();
        }

        // Clear cache
        this.imageCache.forEach(blobUrl => URL.revokeObjectURL(blobUrl));
        this.imageCache.clear();

        return new Promise((resolve, reject) => {
            const transaction = this.imageStore.transaction(['images'], 'readwrite');
            const objectStore = transaction.objectStore('images');
            const request = objectStore.clear();

            request.onsuccess = () => {
                console.log('[image-store.js] Cleared all images');
                resolve(true);
            };

            request.onerror = () => {
                console.error('Failed to clear images:', request.error);
                reject(request.error);
            };
        });
    },

    /**
     * Get storage usage stats
     * @returns {Promise<{count: number, totalSize: number}>}
     */
    async getImageStats() {
        const images = await this.getAllImages();
        const totalSize = images.reduce((sum, img) => sum + img.size, 0);
        return {
            count: images.length,
            totalSize: totalSize,
            totalSizeMB: (totalSize / (1024 * 1024)).toFixed(2)
        };
    }
});

console.log('[image-store.js] Image storage module loaded');



// ============================================================
// DATA/PERSISTENCE.JS (Order: 11, Category: Data)
// ============================================================

/**
 * @order 11
 * @category Data
 * @description localStorage persistence layer
 *
 * This module provides:
 * - saveToStorage() - Saves complete app state to localStorage
 * - loadFromStorage() - Loads app state from localStorage on init
 *
 * PERSISTED STATE (Complete list):
 * - tasks: Array of all task objects
 * - taskIdCounter: Next available task ID
 * - workingTasksByRoot: Multi-project working state tracking
 * - darkMode, zoomLevel, viewBox position: View state
 * - homes, homeIdCounter: Named bookmarks system
 * - All user preferences/configuration (textLengthThreshold, charWidth, etc.)
 * - undoStack, redoStack: Undo/redo history
 *
 * ERROR HANDLING:
 * - QuotaExceededError: Automatically trims undo history to last 10 and retries
 * - Shows toast notification when history is trimmed
 *
 * MIGRATION:
 * - loadFromStorage() includes migration logic for old "origin" system ‚Üí "Homes" system
 * - Uses ?? operator for proper defaults (handles null/undefined correctly)
 */

/**
 * Save complete app state to localStorage
 * Automatically called after every state modification
 * Handles QuotaExceededError by trimming undo history
 */
app.saveToStorage = function() {
    try {
        localStorage.setItem('taskTree', JSON.stringify({
            // Task data
            tasks: this.tasks,
            taskIdCounter: this.taskIdCounter,
            // Multi-project working state
            workingTasksByRoot: this.workingTasksByRoot,
            // View state
            darkMode: this.darkMode,
            zoomLevel: this.zoomLevel,
            viewBoxX: this.viewBox.x,
            viewBoxY: this.viewBox.y,
            // Homes - named bookmarks
            homes: this.homes,
            homeIdCounter: this.homeIdCounter,
            // User preferences & configuration
            textLengthThreshold: this.textLengthThreshold,
            charWidth: this.charWidth,
            nodePadding: this.nodePadding,
            wheelZoomSpeed: this.wheelZoomSpeed,
            minNodeWidth: this.minNodeWidth,
            fontFamily: this.fontFamily,
            fontWeight: this.fontWeight,
            showDeleteConfirmation: this.showDeleteConfirmation,
            autoHideCompletedNodes: this.autoHideCompletedNodes,
            enableMultiline: this.enableMultiline,
            maxNodeWidth: this.maxNodeWidth,
            maxNodeHeight: this.maxNodeHeight,
            lineHeight: this.lineHeight,
            wordWrap: this.wordWrap,
            arrowStyle: this.arrowStyle,
            arrowCurvature: this.arrowCurvature,
            arrowOppositeEdge: this.arrowOppositeEdge,
            arrowRoutingMode: this.arrowRoutingMode,
            orthogonalCornerRadius: this.orthogonalCornerRadius,
            enableSnapping: this.enableSnapping,
            snapThreshold: this.snapThreshold,
            // Undo/redo history
            undoStack: this.undoStack,
            redoStack: this.redoStack
        }));
    } catch (e) {
        // Handle quota exceeded error
        if (e.name === 'QuotaExceededError') {
            // Trim undo history and try again
            this.undoStack = this.undoStack.slice(-10); // Keep only last 10
            this.redoStack = [];
            try {
                localStorage.setItem('taskTree', JSON.stringify({
                    tasks: this.tasks,
                    taskIdCounter: this.taskIdCounter,
                    workingTasksByRoot: this.workingTasksByRoot,
                    darkMode: this.darkMode,
                    zoomLevel: this.zoomLevel,
                    viewBoxX: this.viewBox.x,
                    viewBoxY: this.viewBox.y,
                    homes: this.homes,
                    homeIdCounter: this.homeIdCounter,
                    textLengthThreshold: this.textLengthThreshold,
                    charWidth: this.charWidth,
                    nodePadding: this.nodePadding,
                    wheelZoomSpeed: this.wheelZoomSpeed,
                    minNodeWidth: this.minNodeWidth,
                    fontFamily: this.fontFamily,
                    fontWeight: this.fontWeight,
                    showDeleteConfirmation: this.showDeleteConfirmation,
                    autoHideCompletedNodes: this.autoHideCompletedNodes,
                    enableMultiline: this.enableMultiline,
                    maxNodeWidth: this.maxNodeWidth,
                    maxNodeHeight: this.maxNodeHeight,
                    lineHeight: this.lineHeight,
                    wordWrap: this.wordWrap,
                    arrowStyle: this.arrowStyle,
                    arrowCurvature: this.arrowCurvature,
                    arrowOppositeEdge: this.arrowOppositeEdge,
                    arrowRoutingMode: this.arrowRoutingMode,
                    orthogonalCornerRadius: this.orthogonalCornerRadius,
                    enableSnapping: this.enableSnapping,
                    snapThreshold: this.snapThreshold,
                    undoStack: this.undoStack,
                    redoStack: this.redoStack
                }));
                this.showToast('Undo history trimmed due to storage limits', 'error', 3000);
            } catch (e2) {
                console.error('Storage error:', e2);
            }
        }
    }
};

/**
 * Load complete app state from localStorage
 * Called once during app.init()
 * Includes migration logic for old data formats
 */
app.loadFromStorage = function() {
    const data = localStorage.getItem('taskTree');
    if (data) {
        const parsed = JSON.parse(data);
        // Task data
        this.tasks = parsed.tasks || [];
        this.taskIdCounter = parsed.taskIdCounter || 0;

        // MIGRATION: Fix tasks with missing or invalid x/y coordinates
        this.tasks.forEach((task, index) => {
            if (typeof task.x !== 'number' || isNaN(task.x)) {
                task.x = 100 + (index * 150); // Spread tasks horizontally
            }
            if (typeof task.y !== 'number' || isNaN(task.y)) {
                task.y = 300;
            }
        });
        // Multi-project working state
        this.workingTasksByRoot = parsed.workingTasksByRoot || {};
        // View state
        this.darkMode = parsed.darkMode || false;
        this.zoomLevel = parsed.zoomLevel || 1;
        // Restore viewBox position if saved
        if (parsed.viewBoxX !== undefined && parsed.viewBoxY !== undefined) {
            this.viewBox.x = parsed.viewBoxX;
            this.viewBox.y = parsed.viewBoxY;
        }
        // Homes - load and migrate from old origin system
        this.homes = parsed.homes || [];
        this.homeIdCounter = parsed.homeIdCounter || 1;

        // MIGRATION: Add default icon to homes that don't have one
        this.homes.forEach(home => {
            if (!home.icon) {
                home.icon = 'üè†';
            }
        });

        // MIGRATION: Convert old origin system to "Origin Home"
        if (parsed.originMarked && this.homes.length === 0) {
            this.homes.push({
                id: this.homeIdCounter++,
                name: "Origin Home",
                centerX: parsed.originX || 0,
                centerY: parsed.originY || 0,
                zoomLevel: parsed.originZoomLevel || 1,
                timestamp: Date.now(),
                icon: 'üè†'
            });
            // Save immediately to persist migration
            setTimeout(() => {
                this.saveToStorage();
                this.showToast('‚úì Migrated to Homes system', 'info', 2000);
            }, 100);
        }

        // User preferences & configuration (use ?? for proper defaults)
        this.textLengthThreshold = parsed.textLengthThreshold ?? 80;
        this.charWidth = parsed.charWidth ?? 8.5;
        this.nodePadding = parsed.nodePadding ?? 15;
        this.wheelZoomSpeed = parsed.wheelZoomSpeed ?? 0.18;
        this.minNodeWidth = parsed.minNodeWidth ?? 100;
        this.fontFamily = parsed.fontFamily ?? "'Fira Code', 'Consolas', 'Monaco', 'Courier New', monospace";
        this.fontWeight = parsed.fontWeight ?? 700;
        this.showDeleteConfirmation = parsed.showDeleteConfirmation ?? true;
        this.autoHideCompletedNodes = parsed.autoHideCompletedNodes ?? true;
        this.enableMultiline = parsed.enableMultiline ?? true;
        this.maxNodeWidth = parsed.maxNodeWidth ?? 600;
        this.maxNodeHeight = parsed.maxNodeHeight ?? 0;
        this.lineHeight = parsed.lineHeight ?? 20;
        this.wordWrap = parsed.wordWrap ?? true;
        this.arrowStyle = parsed.arrowStyle ?? 'straight';
        this.arrowCurvature = parsed.arrowCurvature ?? 0.25;
        this.arrowOppositeEdge = parsed.arrowOppositeEdge ?? true;
        this.arrowRoutingMode = parsed.arrowRoutingMode ?? 'direct';
        this.orthogonalCornerRadius = parsed.orthogonalCornerRadius ?? 15;
        this.enableSnapping = parsed.enableSnapping ?? true;
        this.snapThreshold = parsed.snapThreshold ?? 10;
        // Undo/redo history
        this.undoStack = parsed.undoStack || [];
        this.redoStack = parsed.redoStack || [];

        // Update dark mode button and apply dark mode
        const darkModeBtn = document.getElementById('darkModeToggle');
        if (this.darkMode) {
            document.body.classList.add('dark-mode');
            if (darkModeBtn) darkModeBtn.textContent = '‚òÄÔ∏è Light Mode';
        } else {
            document.body.classList.remove('dark-mode');
            if (darkModeBtn) darkModeBtn.textContent = 'üåô Dark Mode';
        }

        // Update zoom display
        this.updateZoomDisplay();

        // Update text length input
        const textLengthInput = document.getElementById('textLengthInput');
        if (textLengthInput) {
            textLengthInput.value = this.textLengthThreshold;
        }
    }
};

/**
 * Debounced save for performance optimization
 * Used for operations that happen frequently (like canvas panning, zooming)
 * Waits 'delay' ms after last call before actually saving
 * Prevents excessive localStorage writes during rapid interactions
 * @param {number} delay - Milliseconds to wait before saving (default: 500)
 */
app.debouncedSaveToStorage = function(delay = 500) {
    // Clear existing timer if any
    if (this.saveDebounceTimer) {
        clearTimeout(this.saveDebounceTimer);
    }

    // Set new timer
    this.saveDebounceTimer = setTimeout(() => {
        this.saveToStorage();
        this.saveDebounceTimer = null;
    }, delay);
};

console.log('[persistence.js] localStorage persistence layer loaded');



// ============================================================
// DATA/IMPORT-EXPORT.JS (Order: 12, Category: Data)
// ============================================================

/**
 * @order 12
 * @category Data
 * @description JSON import/export functionality
 *
 * This module provides:
 * - exportData() - Downloads complete app state as JSON file
 * - copyDataToClipboard() - Copies JSON to clipboard with visual feedback
 * - importData() - Imports JSON from textarea (with validation)
 * - showImportModal() - Shows import modal
 * - hideImportModal() - Hides import modal
 *
 * EXPORT FORMAT:
 * - Complete localStorage snapshot (same format as saveToStorage)
 * - Filename: task-tree-YYYY-MM-DD.json
 *
 * IMPORT VALIDATION:
 * - Checks for valid JSON format
 * - Validates required fields (tasks array must exist)
 * - Creates undo snapshot before import (can undo accidental import)
 * - Shows success/error notifications
 *
 * UI INTEGRATION:
 * - Called from control panel buttons
 * - Import modal defined in HTML (id="import-modal")
 */

/**
 * Export complete app state as downloadable .zip file containing:
 * - tasks.json: All task data and settings
 * - images/: Folder with all images from IndexedDB
 * Filename format: task-tree-YYYY-MM-DD.zip
 */
app.exportData = async function() {
    try {
        // Get all images from IndexedDB
        const images = await this.getAllImages();

        // If no images, export as JSON for backwards compatibility
        if (images.length === 0) {
            const json = localStorage.getItem('taskTree') || '{}';
            const blob = new Blob([json], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `task-tree-${new Date().toISOString().slice(0,10)}.json`;
            a.click();
            URL.revokeObjectURL(url);
            this.showToast('‚úì Exported as JSON', 'success', 2000);
            return;
        }

        // Create .zip with JSZip
        const zip = new JSZip();

        // Add tasks.json
        const json = localStorage.getItem('taskTree') || '{}';
        zip.file('tasks.json', json);

        // Add images folder
        const imagesFolder = zip.folder('images');
        for (const image of images) {
            // Save each image with its ID as filename
            const extension = image.type.split('/')[1] || 'png';
            imagesFolder.file(`${image.id}.${extension}`, image.blob);
        }

        // Generate .zip blob
        const zipBlob = await zip.generateAsync({
            type: 'blob',
            compression: 'DEFLATE',
            compressionOptions: { level: 6 }
        });

        // Download .zip file
        const url = URL.createObjectURL(zipBlob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `task-tree-${new Date().toISOString().slice(0,10)}.zip`;
        a.click();
        URL.revokeObjectURL(url);

        const sizeMB = (zipBlob.size / 1024 / 1024).toFixed(2);
        this.showToast(`‚úì Exported .zip (${sizeMB}MB, ${images.length} images)`, 'success', 3000);
    } catch (error) {
        console.error('Export error:', error);
        this.showToast(`‚ùå Export failed: ${error.message}`, 'error', 3000);
    }
};

/**
 * Copy complete app state JSON to clipboard
 * Shows visual feedback on button (green + "Copied!" text)
 * @param {Event} e - Click event from button
 */
app.copyDataToClipboard = function(e) {
    const json = localStorage.getItem('taskTree') || '{}';
    navigator.clipboard.writeText(json).then(() => {
        // Show brief feedback
        const btn = e.target;
        const originalText = btn.textContent;
        btn.textContent = 'Copied!';
        btn.style.background = '#28a745';
        setTimeout(() => {
            btn.textContent = originalText;
            btn.style.background = '';
        }, 1500);
    }).catch(err => {
        this.showAlert('Copy Failed', 'Failed to copy to clipboard: ' + err.message);
    });
};

/**
 * Show import modal for uploading files or pasting JSON data
 * Clears textarea and file input, displays modal
 */
app.showImportModal = function() {
    const modal = document.getElementById('import-modal');
    modal.classList.add('show');
    document.getElementById('import-textarea').value = '';
    document.getElementById('import-file').value = '';
};

/**
 * Hide import modal
 */
app.hideImportModal = function() {
    const modal = document.getElementById('import-modal');
    modal.classList.remove('show');
};

/**
 * Import data from file (.zip or .json) or pasted JSON
 * Handles .zip files with images, backwards compatible with .json
 * Validates format, creates undo snapshot, and loads data
 */
app.importData = async function() {
    try {
        const fileInput = document.getElementById('import-file');
        const textarea = document.getElementById('import-textarea');

        // Check if file was selected
        if (fileInput.files.length > 0) {
            const file = fileInput.files[0];

            if (file.name.endsWith('.zip')) {
                // Handle .zip file
                await this.importZipFile(file);
            } else if (file.name.endsWith('.json')) {
                // Handle .json file
                const text = await file.text();
                await this.importJsonData(text);
            } else {
                this.showAlert('Import Error', 'Please select a .zip or .json file.');
                return;
            }
        } else {
            // Check if JSON was pasted
            const json = textarea.value.trim();
            if (!json) {
                this.showAlert('Import Error', 'Please select a file or paste JSON data.');
                return;
            }
            await this.importJsonData(json);
        }

        this.hideImportModal();
    } catch (error) {
        console.error('Import error:', error);
        this.showAlert('Import Error', error.message);
    }
};

/**
 * Import .zip file containing tasks.json and images folder
 * @param {File} file - .zip file
 */
app.importZipFile = async function(file) {
    try {
        // Load .zip file
        const zip = await JSZip.loadAsync(file);

        // Extract tasks.json
        const tasksFile = zip.file('tasks.json');
        if (!tasksFile) {
            throw new Error('.zip must contain tasks.json file');
        }

        const jsonText = await tasksFile.async('text');
        const parsed = JSON.parse(jsonText);

        if (!parsed.tasks || !Array.isArray(parsed.tasks)) {
            throw new Error('Invalid task tree format in tasks.json');
        }

        // Clear existing images
        await this.clearAllImages();

        // Import images from images/ folder
        const imagesFolder = zip.folder('images');
        if (imagesFolder) {
            const imageFiles = [];
            imagesFolder.forEach((relativePath, file) => {
                imageFiles.push({ path: relativePath, file: file });
            });

            for (const { path, file } of imageFiles) {
                const blob = await file.async('blob');
                const imageId = path.split('.')[0]; // Extract ID from filename
                await this.saveImage(blob, imageId);
            }

            console.log(`[import-export.js] Imported ${imageFiles.length} images`);
        }

        // Save snapshot before importing
        const taskCount = parsed.tasks.length;
        this.saveSnapshot(`Imported ${taskCount} task${taskCount !== 1 ? 's' : ''} from .zip`);

        // Save and load
        localStorage.setItem('taskTree', jsonText);
        this.loadFromStorage();
        this.updateStatusBar();
        this.render();

        const imageCount = imagesFolder ? Object.keys(zip.folder('images').files).length : 0;
        this.showAlert('Success', `Imported ${taskCount} tasks and ${imageCount} images!`);
    } catch (error) {
        throw new Error(`Failed to import .zip: ${error.message}`);
    }
};

/**
 * Import JSON data from text string
 * @param {string} json - JSON string
 */
app.importJsonData = async function(json) {
    try {
        // Validate JSON
        const parsed = JSON.parse(json);
        if (!parsed.tasks || !Array.isArray(parsed.tasks)) {
            throw new Error('Invalid task tree format');
        }

        // Save snapshot before importing
        const taskCount = parsed.tasks.length;
        this.saveSnapshot(`Imported ${taskCount} task${taskCount !== 1 ? 's' : ''} from JSON`);

        // Save and load
        localStorage.setItem('taskTree', json);
        this.loadFromStorage();
        this.updateStatusBar();
        this.render();

        this.showAlert('Success', `Imported ${taskCount} tasks!`);
    } catch (error) {
        throw new Error(`Invalid JSON data: ${error.message}`);
    }
};

console.log('[import-export.js] JSON import/export functionality loaded');



// ============================================================
// DATA/CLIPBOARD.JS (Order: 13, Category: Data)
// ============================================================

/**
 * @order 13
 * @category Data
 * @description Copy/paste subtree operations
 *
 * This module provides:
 * - copySubtree() - Copies task and all descendants to internal clipboard
 * - pasteSubtree() - Pastes copied subtree at specified position or as child
 * - pasteFromClipboard() - Reads JSON from system clipboard and pastes (cross-app support)
 *
 * CLIPBOARD FORMAT:
 * {
 *   version: 1,
 *   rootId: number,
 *   subtree: Array<Task>,
 *   metadata: { nodeCount, timestamp, sourceApp }
 * }
 *
 * COPY BEHAVIOR:
 * - Deep clones all tasks in subtree
 * - Cleans external references (dependencies/parents outside subtree)
 * - Resets working state and hidden flags
 * - Preserves relative positions
 *
 * PASTE BEHAVIOR:
 * - Generates new IDs for all tasks
 * - Remaps all internal references (children, dependencies, parents)
 * - Offsets positions to avoid overlap
 * - Can paste as root task or as child of existing task
 * - Creates undo snapshot before paste
 *
 * VALIDATION (pasteFromClipboard):
 * - Checks for Clipboard API availability
 * - Validates JSON format
 * - Validates required fields (version, subtree, rootId, metadata)
 * - Validates each task structure
 * - Shows detailed error messages
 */

/**
 * Copy task and all descendants to clipboard
 * @param {number} taskId - Root task ID to copy
 */
app.copySubtree = function(taskId) {
    const rootTask = this.tasks.find(t => t.id === taskId);
    if (!rootTask) return;

    // 1. Collect all descendants recursively
    const subtreeTasks = [];
    const subtreeIds = new Set();

    const collectNode = (id) => {
        if (subtreeIds.has(id)) return;

        const task = this.tasks.find(t => t.id === id);
        if (!task) return;

        subtreeIds.add(id);
        subtreeTasks.push(task);

        // Recurse into children
        task.children.forEach(childId => collectNode(childId));
    };

    collectNode(taskId);

    // 2. Clean and prepare tasks for clipboard
    const cleanedTasks = subtreeTasks.map(task => {
        const cleaned = JSON.parse(JSON.stringify(task));  // Deep clone

        // Clean external references
        cleaned.mainParent = task.id === taskId ? null : task.mainParent;
        cleaned.otherParents = cleaned.otherParents.filter(id => subtreeIds.has(id));
        cleaned.dependencies = cleaned.dependencies.filter(id => subtreeIds.has(id));
        cleaned.currentlyWorking = false;  // Never copy working state
        cleaned.hidden = false;  // Reset hidden state

        // Remove runtime velocity properties
        delete cleaned.vx;
        delete cleaned.vy;

        return cleaned;
    });

    // 3. Store in clipboard with metadata
    this.copiedSubtree = {
        version: 1,
        rootId: taskId,
        subtree: cleanedTasks,
        metadata: {
            nodeCount: cleanedTasks.length,
            timestamp: Date.now(),
            sourceApp: 'Task Tree'
        }
    };

    // 4. Also copy to system clipboard for cross-app support
    const clipboardJSON = JSON.stringify(this.copiedSubtree, null, 2);
    navigator.clipboard.writeText(clipboardJSON).then(() => {
        const nodeWord = cleanedTasks.length === 1 ? 'node' : 'nodes';
        this.showToast(`‚úì Copied ${cleanedTasks.length} ${nodeWord} to clipboard`, 'success', 2000);
    }).catch(err => {
        // Fallback: Still show success even if system clipboard fails
        const nodeWord = cleanedTasks.length === 1 ? 'node' : 'nodes';
        this.showToast(`‚úì Copied ${cleanedTasks.length} ${nodeWord}`, 'success', 2000);
    });
};

/**
 * Paste copied subtree at specified position or as child
 * @param {number|null} parentId - If provided, paste as child; if null, paste as root
 * @param {number|null} x - X coordinate for paste (if null, uses auto-offset)
 * @param {number|null} y - Y coordinate for paste (if null, uses auto-offset)
 */
app.pasteSubtree = function(parentId = null, x = null, y = null) {
    if (!this.copiedSubtree) {
        this.showToast('‚ùå Clipboard empty - copy a subtree first', 'error', 2000);
        return;
    }

    const clipboard = this.copiedSubtree;
    const oldRootId = clipboard.rootId;

    this.saveSnapshot(`Pasted subtree (${clipboard.metadata.nodeCount} nodes)`);

    // 1. Create ID mapping (oldId ‚Üí newId)
    const idMap = new Map();
    clipboard.subtree.forEach(task => {
        idMap.set(task.id, this.taskIdCounter++);
    });

    // 2. Find root task to calculate position offset
    const oldRoot = clipboard.subtree.find(t => t.id === oldRootId);

    // Determine paste position
    let newRootX, newRootY;
    if (x !== null && y !== null) {
        // Explicit position provided
        newRootX = x;
        newRootY = y;
    } else {
        // Auto-offset: place 300px right, 100px down from original
        newRootX = oldRoot.x + 300;
        newRootY = oldRoot.y + 100;
    }

    const deltaX = newRootX - oldRoot.x;
    const deltaY = newRootY - oldRoot.y;

    // 3. Clone, remap IDs, and adjust positions
    const newTasks = clipboard.subtree.map(oldTask => {
        const newTask = { ...oldTask };

        // Remap ID
        newTask.id = idMap.get(oldTask.id);

        // Remap parent (if pasting as root, clear mainParent)
        if (oldTask.id === oldRootId && parentId !== null) {
            newTask.mainParent = parentId;
        } else if (oldTask.id === oldRootId) {
            newTask.mainParent = null;
        } else {
            newTask.mainParent = idMap.get(oldTask.mainParent);
        }

        // Remap children, otherParents, dependencies
        newTask.children = oldTask.children.map(childId => idMap.get(childId)).filter(id => id !== undefined);
        newTask.otherParents = oldTask.otherParents.map(parentId => idMap.get(parentId)).filter(id => id !== undefined);
        newTask.dependencies = oldTask.dependencies.map(depId => idMap.get(depId)).filter(id => id !== undefined);

        // Adjust position
        newTask.x = oldTask.x + deltaX;
        newTask.y = oldTask.y + deltaY;

        // Reset runtime properties
        newTask.vx = 0;
        newTask.vy = 0;
        newTask.currentlyWorking = false;
        newTask.hidden = false;

        return newTask;
    });

    // 4. Add to tasks array
    this.tasks.push(...newTasks);

    // 5. If pasting as child, update parent
    if (parentId !== null) {
        const parent = this.tasks.find(t => t.id === parentId);
        if (parent) {
            parent.children.push(idMap.get(oldRootId));
        }
    }

    this.saveToStorage();
    this.updateStatusBar();
    this.render();

    const nodeWord = newTasks.length === 1 ? 'node' : 'nodes';
    this.showToast(`‚úì Pasted ${newTasks.length} ${nodeWord}`, 'success', 2000);
};

/**
 * Read system clipboard and paste if it contains valid subtree JSON
 * Supports cross-app subtree sharing
 * @param {number|null} parentId - If provided, paste as child; if null, paste as root
 * @param {number|null} x - X coordinate for paste
 * @param {number|null} y - Y coordinate for paste
 */
app.pasteFromClipboard = async function(parentId = null, x = null, y = null) {
    // Read clipboard and paste if it contains valid subtree JSON
    try {
        // Check if Clipboard API is available
        if (!navigator.clipboard || !navigator.clipboard.readText) {
            this.showToast('‚ùå Clipboard API not available in this browser', 'error', 3000);
            return;
        }

        // Read clipboard text
        const clipboardText = await navigator.clipboard.readText();

        if (!clipboardText || clipboardText.trim() === '') {
            this.showToast('‚ùå Clipboard is empty', 'error', 2000);
            return;
        }

        // Try to parse as JSON
        let clipboardData;
        try {
            clipboardData = JSON.parse(clipboardText);
        } catch (parseError) {
            this.showToast('‚ùå Clipboard does not contain valid JSON', 'error', 3000);
            return;
        }

        // Validate subtree format
        if (!clipboardData.version || !clipboardData.subtree || !Array.isArray(clipboardData.subtree) || !clipboardData.rootId || !clipboardData.metadata) {
            this.showToast('‚ùå Clipboard JSON is not a valid subtree format', 'error', 3000);
            return;
        }

        // Validate each task has required fields
        for (const task of clipboardData.subtree) {
            if (typeof task.id !== 'number' || !task.title || typeof task.x !== 'number' || typeof task.y !== 'number') {
                this.showToast('‚ùå Invalid task format in subtree', 'error', 3000);
                return;
            }
        }

        // Check rootId exists in subtree
        if (!clipboardData.subtree.find(t => t.id === clipboardData.rootId)) {
            this.showToast('‚ùå Root task not found in subtree', 'error', 3000);
            return;
        }

        // Valid subtree! Store temporarily and paste
        this.copiedSubtree = clipboardData;
        this.pasteSubtree(parentId, x, y);

        // Show success message mentioning import
        const nodeCount = clipboardData.metadata.nodeCount || clipboardData.subtree.length;
        const nodeWord = nodeCount === 1 ? 'node' : 'nodes';
        this.showToast(`üìã Imported and pasted ${nodeCount} ${nodeWord} from clipboard`, 'success', 3000);

    } catch (error) {
        console.error('Paste from clipboard error:', error);
        this.showToast(`‚ùå Failed to read clipboard: ${error.message}`, 'error', 3000);
    }
};

/**
 * Paste image from clipboard as a new task node
 * @param {number|null} parentId - Optional parent task ID
 * @param {number} x - X coordinate
 * @param {number} y - Y coordinate
 */
app.pasteImage = async function(parentId = null, x = null, y = null) {
    try {
        // Check if Clipboard API is available
        if (!navigator.clipboard || !navigator.clipboard.read) {
            this.showToast('‚ùå Clipboard API not available in this browser', 'error', 3000);
            return;
        }

        // Read clipboard
        const clipboardItems = await navigator.clipboard.read();

        // Find first image item
        let imageBlob = null;
        for (const item of clipboardItems) {
            for (const type of item.types) {
                if (type.startsWith('image/')) {
                    imageBlob = await item.getType(type);
                    break;
                }
            }
            if (imageBlob) break;
        }

        if (!imageBlob) {
            this.showToast('‚ùå No image found in clipboard', 'error', 2000);
            return;
        }

        // Check image size (limit to 5MB)
        const MAX_SIZE = 5 * 1024 * 1024; // 5MB
        if (imageBlob.size > MAX_SIZE) {
            this.showToast(`‚ùå Image too large (${(imageBlob.size / 1024 / 1024).toFixed(1)}MB). Max 5MB.`, 'error', 3000);
            return;
        }

        // Save image to IndexedDB
        const imageId = await this.saveImage(imageBlob);

        // Get original image dimensions
        const blobUrl = URL.createObjectURL(imageBlob);
        const img = new Image();
        await new Promise((resolve) => {
            img.onload = resolve;
            img.src = blobUrl;
        });
        const imageWidth = img.naturalWidth;
        const imageHeight = img.naturalHeight;
        URL.revokeObjectURL(blobUrl);

        // Create new task with image
        if (x === null || y === null) {
            x = this.viewBox.x + this.viewBox.width / 2;
            y = this.viewBox.y + this.viewBox.height / 2;
        }

        const snapped = this.snapPointToGrid(x, y);

        this.saveSnapshot(`Pasted image`);

        const newTask = {
            id: this.taskIdCounter++,
            title: '',  // Empty title for image-only nodes
            x: snapped.x,
            y: snapped.y,
            vx: 0,
            vy: 0,
            mainParent: parentId,
            otherParents: [],
            children: [],
            dependencies: [],
            status: 'pending',
            currentlyWorking: false,
            hidden: false,
            textExpanded: false,
            textLocked: false,
            links: [],
            imageId: imageId,  // Reference to IndexedDB image
            imageWidth: imageWidth,  // Original width
            imageHeight: imageHeight,  // Original height
            priority: 'normal',
            customAttachPoints: {},
            customSourcePoints: {},
            timeTracking: {
                totalSeconds: 0,
                sessions: []
            }
        };

        this.tasks.push(newTask);

        // If pasting as child, update parent's children array
        if (parentId !== null) {
            const parent = this.tasks.find(t => t.id === parentId);
            if (parent) {
                parent.children.push(newTask.id);
            }
        }

        this.saveToStorage();
        this.render();

        const sizeMB = (imageBlob.size / 1024 / 1024).toFixed(2);
        this.showToast(`‚úì Pasted image (${sizeMB}MB)`, 'success', 2000);

    } catch (error) {
        console.error('Paste image error:', error);
        this.showToast(`‚ùå Failed to paste image: ${error.message}`, 'error', 3000);
    }
};

/**
 * Smart paste - auto-detects clipboard content type
 * Tries image first, falls back to subtree/JSON
 * @param {number|null} parentId - Optional parent task ID
 * @param {number} x - X coordinate
 * @param {number} y - Y coordinate
 */
app.smartPaste = async function(parentId = null, x = null, y = null) {
    try {
        // Use last mouse position if not specified
        if (x === null || y === null) {
            x = this.lastMousePosition.x;
            y = this.lastMousePosition.y;
        }

        // Check if Clipboard API is available
        if (!navigator.clipboard || !navigator.clipboard.read) {
            // Fall back to subtree paste
            if (this.copiedSubtree) {
                this.pasteSubtree(parentId, x, y);
            } else {
                this.showToast('‚ùå Clipboard empty', 'error', 2000);
            }
            return;
        }

        // Read clipboard
        const clipboardItems = await navigator.clipboard.read();

        // Check for image first
        let hasImage = false;
        for (const item of clipboardItems) {
            if (item.types.some(type => type.startsWith('image/'))) {
                hasImage = true;
                break;
            }
        }

        if (hasImage) {
            // Paste image
            await this.pasteImage(parentId, x, y);
        } else {
            // No image - try subtree paste
            if (this.copiedSubtree) {
                this.pasteSubtree(parentId, x, y);
            } else {
                this.showToast('‚ùå Clipboard empty - copy a subtree first (Ctrl+C)', 'error', 2000);
            }
        }
    } catch (error) {
        console.error('Smart paste error:', error);
        // Fall back to subtree paste on error
        if (this.copiedSubtree) {
            this.pasteSubtree(parentId, x, y);
        } else {
            this.showToast('‚ùå Clipboard empty', 'error', 2000);
        }
    }
};

console.log('[clipboard.js] Copy/paste subtree operations loaded');



// ============================================================
// UTILS/CYCLE-DETECTION.JS (Order: 14, Category: Utils)
// ============================================================

/**
 * @order 14
 * @category Utils
 * @description Dependency cycle detection
 *
 * This module provides:
 * - wouldCreateCycle() - Checks if adding a dependency would create a circular dependency
 *
 * ALGORITHM: Breadth-first search (BFS)
 * - Start from the target task (toId)
 * - Follow all dependency chains
 * - If we reach the source task (fromId), a cycle exists
 *
 * USAGE: Called before adding dependencies via Alt+drag
 * Prevents: A ‚Üí B ‚Üí C ‚Üí A (circular dependency)
 */

/**
 * Check if adding a dependency from‚Üíto would create a cycle
 * @param {number} fromId - Task that will depend on toId
 * @param {number} toId - Task that fromId will depend on
 * @returns {boolean} True if cycle would be created, false otherwise
 */
app.wouldCreateCycle = function(fromId, toId) {
    // Check if adding dependency from->to would create a cycle
    const visited = new Set();
    const queue = [toId];

    while (queue.length > 0) {
        const current = queue.shift();
        if (current === fromId) return true;
        if (visited.has(current)) continue;

        visited.add(current);
        const task = this.tasks.find(t => t.id === current);
        if (task) {
            queue.push(...task.dependencies);
        }
    }

    return false;
};

console.log('[cycle-detection.js] Dependency cycle detection loaded');



// ============================================================
// CORE/TASKS.JS (Order: 15, Category: Core)
// ============================================================

/**
 * @order 15
 * @category Core Domain Logic
 * @description Task CRUD operations - creation, deletion, and tree traversal
 *
 * Functions extracted from task-tree.html (lines 1878-2453):
 * - addChildTask() - Create child task and auto-start editing
 * - createChildAtPosition() - Create child at specific coordinates
 * - addRootTaskAtPosition() - Create root task at specific coordinates
 * - deleteTask() - Delete task and all descendants with confirmation
 * - deleteMultipleTasks() - Bulk delete selected tasks
 * - getDescendants() - Recursively get all descendants
 * - getRootTask() - Find root task of tree
 * - getAncestors() - Get all ancestors up to root
 * - getPathToRoot() - Get title path from task to root
 */

Object.assign(app, {
    addChildTask(parentId) {
        this.saveSnapshot(`Created child task 'New Task'`);

        const parent = this.tasks.find(t => t.id === parentId);

        // DEFENSIVE: Check parent coordinates
        if (!parent) {
            console.error(`addChildTask: parent ${parentId} not found!`);
            return;
        }
        if (!isFinite(parent.x) || !isFinite(parent.y)) {
            console.error(`addChildTask: parent ${parentId} has invalid coords: (${parent.x}, ${parent.y})`);
            console.trace('Stack trace:');
        }

        // Calculate position with random offset
        const rawX = parent.x + Math.random() * 200 - 100;
        const rawY = parent.y + 150 + Math.random() * 50;
        const snapped = this.snapPointToGrid(rawX, rawY);

        const task = {
            id: this.taskIdCounter++,
            title: 'New Task',
            x: snapped.x,
            y: snapped.y,
            vx: 0,
            vy: 0,
            mainParent: parentId,
            otherParents: [],
            children: [],
            dependencies: [],
            status: 'pending',
            hidden: false,
            currentlyWorking: false,
            textExpanded: false,
            textLocked: false,
            links: [],  // Array of URLs attached to this task
            priority: 'normal',  // Priority: 'high', 'medium', 'normal'
            customAttachPoints: {},  // Custom arrow attachment points { [parentId]: { edge, normalized } }
            customSourcePoints: {},  // Custom arrow source points { [childId]: { edge, normalized } }
            timeTracking: {      // Time tracking data
                totalSeconds: 0,
                sessions: []
            }
        };

        parent.children.push(task.id);
        this.tasks.push(task);
        this.saveToStorage();
        this.updateStatusBar();
        this.render();

        // Auto-start editing the new task
        setTimeout(() => this.startEditing(task.id), 50);
    },

    createChildAtPosition({ parentId, x, y }) {
        const parent = this.tasks.find(t => t.id === parentId);
        if (!parent) return;

        // DEFENSIVE: Log and validate coordinates
        if (!isFinite(x) || !isFinite(y)) {
            console.error(`createChildAtPosition called with invalid coords: (${x}, ${y})`);
            console.trace('Stack trace:');
            // Use parent coords as fallback
            x = parent.x + 100;
            y = parent.y + 100;
        }

        // Snap to grid if enabled
        const snapped = this.snapPointToGrid(x, y);

        this.saveSnapshot(`Created child task`);

        const task = {
            id: this.taskIdCounter++,
            title: '',  // Empty - user will edit immediately
            x: snapped.x,
            y: snapped.y,
            vx: 0,
            vy: 0,
            mainParent: parentId,
            otherParents: [],
            children: [],
            dependencies: [],
            status: 'pending',
            hidden: false,
            currentlyWorking: false,
            textExpanded: false,
            textLocked: false,
            links: [],  // Array of URLs attached to this task
            priority: 'normal',  // Priority: 'high', 'medium', 'normal'
            customAttachPoints: {},  // Custom arrow attachment points { [parentId]: { edge, normalized } }
            customSourcePoints: {},  // Custom arrow source points { [childId]: { edge, normalized } }
            timeTracking: {      // Time tracking data
                totalSeconds: 0,
                sessions: []
            }
        };

        parent.children.push(task.id);
        this.tasks.push(task);
        this.saveToStorage();
        this.updateStatusBar();
        this.render();

        // Auto-start editing the new task
        setTimeout(() => this.startEditing(task.id), 50);
        this.showToast('Child task created', 'success', 2000);
    },

    addRootTaskAtPosition(x, y) {
        // DEFENSIVE: Log and validate coordinates
        if (!isFinite(x) || !isFinite(y)) {
            console.error(`addRootTaskAtPosition called with invalid coords: (${x}, ${y})`);
            console.trace('Stack trace:');
            // Use default coordinates as fallback
            x = 400;
            y = 300;
        }

        // Snap to grid if enabled
        const snapped = this.snapPointToGrid(x, y);

        this.saveSnapshot(`Created root task`);

        const newTask = {
            id: this.taskIdCounter++,
            title: '',  // Empty - user will edit immediately
            x: snapped.x,
            y: snapped.y,
            vx: 0,
            vy: 0,
            mainParent: null,
            otherParents: [],
            children: [],
            dependencies: [],
            status: 'pending',
            currentlyWorking: false,
            hidden: false,
            textExpanded: false,
            textLocked: false,
            links: [],  // Array of URLs attached to this task
            imageId: null,  // Reference to image in IndexedDB
            imageWidth: null,  // Original image width in pixels
            imageHeight: null,  // Original image height in pixels
            priority: 'normal',  // Priority: 'high', 'medium', 'normal'
            customAttachPoints: {},  // Custom arrow attachment points { [parentId]: { edge, normalized } }
            customSourcePoints: {},  // Custom arrow source points { [childId]: { edge, normalized } }
            timeTracking: {      // Time tracking data
                totalSeconds: 0,
                sessions: []
            }
        };

        this.tasks.push(newTask);
        this.saveToStorage();
        this.render();

        // Auto-start editing the new task
        setTimeout(() => this.startEditing(newTask.id), 50);
        this.showToast('Root task created', 'success', 2000);
    },

    deleteTask(taskId) {
        const task = this.tasks.find(t => t.id === taskId);
        const taskTitle = task ? task.title : 'task';

        const performDelete = () => {
            // Save snapshot before deletion
            const truncatedTitle = taskTitle.length > 30 ? taskTitle.substring(0, 27) + '...' : taskTitle;
            this.saveSnapshot(`Deleted task '${truncatedTitle}'`);

            const descendants = this.getDescendants(taskId);
            const toDelete = [taskId, ...descendants];

            // Remove from parents' children arrays
            this.tasks.forEach(task => {
                task.children = task.children.filter(id => !toDelete.includes(id));
                task.dependencies = task.dependencies.filter(id => !toDelete.includes(id));
                task.otherParents = task.otherParents.filter(id => !toDelete.includes(id));
            });

            // Remove tasks
            this.tasks = this.tasks.filter(t => !toDelete.includes(t.id));

            // Clean up working log if deleted task was working
            Object.keys(this.workingTasksByRoot).forEach(rootId => {
                if (toDelete.includes(this.workingTasksByRoot[rootId])) {
                    delete this.workingTasksByRoot[rootId];
                }
            });

            this.saveToStorage();
            this.updateStatusBar();
            this.render();
        };

        if (this.showDeleteConfirmation) {
            this.showConfirm(
                'Delete Task',
                'Delete this task and all its children? This can be undone with Ctrl+Z.',
                performDelete
            );
        } else {
            performDelete();
        }
    },

    deleteMultipleTasks(taskIds) {
        // Delete multiple selected tasks with confirmation
        const performDelete = () => {
            this.saveSnapshot(`Deleted ${taskIds.length} tasks`);

            // Collect all tasks to delete (including descendants of each selected task)
            let toDelete = new Set();
            taskIds.forEach(taskId => {
                toDelete.add(taskId);
                this.getDescendants(taskId).forEach(descendantId => {
                    toDelete.add(descendantId);
                });
            });
            const toDeleteArray = Array.from(toDelete);

            // Remove from parents' children arrays
            this.tasks.forEach(task => {
                task.children = task.children.filter(id => !toDeleteArray.includes(id));
                task.dependencies = task.dependencies.filter(id => !toDeleteArray.includes(id));
                task.otherParents = task.otherParents.filter(id => !toDeleteArray.includes(id));
            });

            // Remove tasks
            this.tasks = this.tasks.filter(t => !toDeleteArray.includes(t.id));
            this.selectedTaskIds.clear();

            this.saveToStorage();
            this.updateStatusBar();
            this.render();
        };

        if (this.showDeleteConfirmation) {
            this.showConfirm(
                `Delete ${taskIds.length} Tasks`,
                `Delete ${taskIds.length} selected tasks and all their children? This can be undone with Ctrl+Z.`,
                performDelete
            );
        } else {
            performDelete();
        }
    },

    getDescendants(taskId) {
        const task = this.tasks.find(t => t.id === taskId);
        if (!task) return [];

        let descendants = [];
        task.children.forEach(childId => {
            descendants.push(childId);
            descendants = descendants.concat(this.getDescendants(childId));
        });
        return descendants;
    },

    getRootTask(taskId) {
        // Find the root task of the tree containing this task
        let task = this.tasks.find(t => t.id === taskId);
        if (!task) return null;

        // Traverse up the parent chain to find root
        while (task.mainParent !== null) {
            task = this.tasks.find(t => t.id === task.mainParent);
            if (!task) return null;
        }
        return task;
    },

    getAncestors(taskId) {
        const task = this.tasks.find(t => t.id === taskId);
        if (!task || task.mainParent === null) return [];

        const ancestors = [task.mainParent];
        ancestors.push(...this.getAncestors(task.mainParent));
        return ancestors;
    },

    getPathToRoot(taskId) {
        const path = [];
        let currentId = taskId;

        while (currentId !== null) {
            const task = this.tasks.find(t => t.id === currentId);
            if (!task) break;
            path.unshift(task.title);
            currentId = task.mainParent;
        }

        return path;
    },

    getSubtreeSize(taskId) {
        // Count the number of nodes in a subtree (including root)
        let count = 0;
        const counted = new Set();

        const countNode = (id) => {
            if (counted.has(id)) return;
            const task = this.tasks.find(t => t.id === id);
            if (!task) return;

            counted.add(id);
            count++;
            task.children.forEach(childId => countNode(childId));
        };

        countNode(taskId);
        return count;
    },

    /**
     * Remove image from a task
     * @param {number} taskId - Task ID
     */
    async removeTaskImage(taskId) {
        const task = this.tasks.find(t => t.id === taskId);
        if (!task || !task.imageId) {
            this.showToast('‚ùå Task has no image', 'error', 2000);
            return;
        }

        const imageId = task.imageId;

        // Save snapshot
        this.saveSnapshot(`Removed image from "${this.truncateTitle(task.title, 20)}"`);

        // Delete from IndexedDB
        await this.deleteImage(imageId);

        // Clear reference from task
        task.imageId = null;

        // If task title is just the image indicator, clear it
        if (task.title === 'üñºÔ∏è') {
            task.title = '';
        }

        this.saveToStorage();
        this.render();
        this.showToast('‚úì Image removed', 'success', 2000);
    }
});



// ============================================================
// CORE/STATUS.JS (Order: 16, Category: Core)
// ============================================================

/**
 * @order 16
 * @category Core Domain Logic
 * @description Task status management - working state, completion, priority, visibility
 *
 * Functions extracted from task-tree.html (lines 1981-2564):
 * - cycleStatus() - Cycle task status: pending ‚Üí working ‚Üí done ‚Üí pending
 * - toggleDone() - Toggle done status with flow state
 * - toggleWorking() - Toggle working state only (no status change)
 * - setPriority() - Set task priority (high/medium/normal)
 * - cyclePriority() - Cycle through priority levels
 * - selectNode() - Select a task node (single selection)
 * - toggleHiddenSelf() - Hide/show the task itself
 * - toggleHidden() - Hide/show all descendants
 * - getHiddenChildrenCount() - Count hidden children
 * - autoCollapseCompleted() - Auto-hide completed subtrees
 * - clearCompleted() - Remove all done tasks
 * - toggleDarkMode() - Toggle dark mode
 * - repairWorkingTasks() - Fix multiple working tasks bug
 */

Object.assign(app, {
    cycleStatus(taskId) {
        const task = this.tasks.find(t => t.id === taskId);
        const truncatedTitle = task.title.length > 30 ? task.title.substring(0, 27) + '...' : task.title;

        if ((task.status === 'pending' || task.status === 'in_progress') && !task.currentlyWorking) {
            // Pending/In Progress ‚Üí Working
            this.saveSnapshot(`Started working on '${truncatedTitle}'`);

            // Multi-project: Only clear working in SAME root tree
            const root = this.getRootTask(taskId);
            const rootId = root ? root.id : null;

            const previousWorkingId = this.workingTasksByRoot[rootId];
            if (previousWorkingId) {
                const prevTask = this.tasks.find(t => t.id === previousWorkingId);
                if (prevTask) {
                    prevTask.currentlyWorking = false;
                    if (!prevTask.textLocked) {
                        prevTask.textExpanded = false;
                    }
                    // Stop timer for previous working task
                    if (this.autoStartTimer && this.timerState.taskId === previousWorkingId) {
                        this.stopTimer();
                    }
                }
            }

            task.currentlyWorking = true;
            if (rootId) {
                this.workingTasksByRoot[rootId] = taskId;
            }
            // Track this as the last working task for Jump button
            this.lastWorkingTaskId = taskId;

            // Clear suggestion when user starts working on a task
            this.suggestedNextTaskId = null;

            // Auto-start timer when marking task as working
            if (this.autoStartTimer) {
                this.startTimer(taskId);
            }
        } else if (task.currentlyWorking) {
            // Working ‚Üí Done
            this.saveSnapshot(`Marked '${truncatedTitle}' as done`);

            const root = this.getRootTask(taskId);
            const rootId = root ? root.id : null;

            task.currentlyWorking = false;
            task.status = 'done';

            // Stop timer when task is marked as done
            if (this.autoStartTimer && this.timerState.taskId === taskId) {
                this.stopTimer();
            }

            // Update working log
            if (rootId) {
                delete this.workingTasksByRoot[rootId];
            }

            // Collapse text if unlocked
            if (!task.textLocked) {
                task.textExpanded = false;
            }

            // Flow state: Suggest parent task as next to work on (shown in purple)
            if (task.mainParent !== null) {
                const parent = this.tasks.find(t => t.id === task.mainParent);
                if (parent && parent.status !== 'done' && !parent.currentlyWorking) {
                    // Set parent as suggested next task
                    this.suggestedNextTaskId = parent.id;
                    const parentTitle = parent.title.length > 30 ? parent.title.substring(0, 27) + '...' : parent.title;
                    this.showToast(`üí° Suggested next: ${parentTitle} (shown in purple)`, 'info', 3000);
                }
            }
        } else if (task.status === 'done') {
            // Done ‚Üí Pending
            this.saveSnapshot(`Marked '${truncatedTitle}' as pending`);
            task.status = 'pending';
        }

        this.autoCollapseCompleted(taskId);
        this.updateStatusBar();
        this.saveToStorage();
        this.render();
    },

    toggleDone(taskId) {
        const task = this.tasks.find(t => t.id === taskId);
        const truncatedTitle = task.title.length > 30 ? task.title.substring(0, 27) + '...' : task.title;
        const wasWorking = task.currentlyWorking;

        if (task.status === 'done') {
            // Done ‚Üí Pending
            this.saveSnapshot(`Marked '${truncatedTitle}' as pending`);
            task.status = 'pending';
        } else {
            // Pending/Working ‚Üí Done
            this.saveSnapshot(`Marked '${truncatedTitle}' as done`);

            const root = this.getRootTask(taskId);
            const rootId = root ? root.id : null;

            task.currentlyWorking = false;  // Stop working when marking done
            task.status = 'done';

            // Update working log
            if (rootId && wasWorking) {
                delete this.workingTasksByRoot[rootId];
            }

            // Stop timer when task is marked as done
            if (this.autoStartTimer && this.timerState.taskId === taskId) {
                this.stopTimer();
            }

            // Flow state: Suggest parent task as next to work on (shown in purple)
            if (task.mainParent !== null) {
                const parent = this.tasks.find(t => t.id === task.mainParent);
                if (parent && parent.status !== 'done' && !parent.currentlyWorking) {
                    // Set parent as suggested next task
                    this.suggestedNextTaskId = parent.id;
                    const parentTitle = parent.title.length > 30 ? parent.title.substring(0, 27) + '...' : parent.title;
                    this.showToast(`üí° Suggested next: ${parentTitle} (shown in purple)`, 'info', 3000);
                }
            }
        }

        // Check if parent subtree is all done
        this.autoCollapseCompleted(taskId);
        this.saveToStorage();
        this.updateStatusBar();
        this.render();
    },

    /**
     * Mark task as "in progress" (started but not currently active)
     * Stops timer and sets status to in_progress
     */
    markAsInProgress(taskId) {
        const task = this.tasks.find(t => t.id === taskId);
        if (!task) return;

        const truncatedTitle = task.title.length > 30 ? task.title.substring(0, 27) + '...' : task.title;
        this.saveSnapshot(`Marked '${truncatedTitle}' as in progress`);

        // Stop working state
        task.currentlyWorking = false;
        if (!task.textLocked) {
            task.textExpanded = false;
        }

        // Set status to in_progress
        task.status = 'in_progress';

        // Stop timer
        if (this.autoStartTimer && this.timerState.taskId === taskId) {
            this.stopTimer();
        }

        // Clear from working log
        const root = this.getRootTask(taskId);
        const rootId = root ? root.id : null;
        if (rootId) {
            delete this.workingTasksByRoot[rootId];
        }

        this.saveToStorage();
        this.updateStatusBar();
        this.render();
    },

    toggleWorking(taskId) {
        const task = this.tasks.find(t => t.id === taskId);
        const root = this.getRootTask(taskId);
        const rootId = root ? root.id : null;

        if (task.currentlyWorking) {
            // Stop working on this task
            task.currentlyWorking = false;
            if (rootId) {
                delete this.workingTasksByRoot[rootId];
            }
            // Collapse text if unlocked
            if (!task.textLocked) {
                task.textExpanded = false;
            }
            // Stop timer when stopping work
            if (this.autoStartTimer && this.timerState.taskId === taskId) {
                this.stopTimer();
            }

            // If task is done and has a parent, suggest parent as next task (purple)
            if (task.status === 'done' && task.mainParent !== null) {
                const parent = this.tasks.find(t => t.id === task.mainParent);
                if (parent && parent.status !== 'done' && !parent.currentlyWorking) {
                    this.suggestedNextTaskId = parent.id;
                    const parentTitle = parent.title.length > 30 ? parent.title.substring(0, 27) + '...' : parent.title;
                    this.showToast(`üí° Suggested next: ${parentTitle} (shown in purple)`, 'info', 3000);
                }
            }
        } else {
            // Start working - unwork previous in same root only
            const previousWorkingId = this.workingTasksByRoot[rootId];
            if (previousWorkingId) {
                const prevTask = this.tasks.find(t => t.id === previousWorkingId);
                if (prevTask) {
                    prevTask.currentlyWorking = false;
                    if (!prevTask.textLocked) {
                        prevTask.textExpanded = false;
                    }
                    // Stop timer for previous working task
                    if (this.autoStartTimer && this.timerState.taskId === previousWorkingId) {
                        this.stopTimer();
                    }
                }
            }

            task.currentlyWorking = true;
            if (rootId) {
                this.workingTasksByRoot[rootId] = taskId;
            }
            // Track this as the last working task for Jump button
            this.lastWorkingTaskId = taskId;

            // Clear suggestion when user starts working on a task
            this.suggestedNextTaskId = null;

            // Auto-start timer when starting work
            if (this.autoStartTimer) {
                this.startTimer(taskId);
            }
        }
        this.saveToStorage();
        this.updateStatusBar();
        this.render();
    },

    setPriority(taskId, priority) {
        const task = this.tasks.find(t => t.id === taskId);
        if (!task) return;

        const truncatedTitle = task.title.length > 30 ? task.title.substring(0, 27) + '...' : task.title;
        const priorityLabel = priority === 'high' ? 'High' : priority === 'medium' ? 'Medium' : 'Normal';

        this.saveSnapshot(`Set priority of '${truncatedTitle}' to ${priorityLabel}`);

        task.priority = priority;
        this.saveToStorage();
        this.render();

        // Show toast notification
        const emoji = priority === 'high' ? 'üî¥' : priority === 'medium' ? 'üü†' : '‚ö™';
        this.showToast(`${emoji} Priority set to ${priorityLabel}`, 'success', 2000);
    },

    cyclePriority(taskId) {
        const task = this.tasks.find(t => t.id === taskId);
        if (!task) return;

        // Cycle: null/normal ‚Üí medium ‚Üí high ‚Üí normal
        const nextPriority = !task.priority || task.priority === 'normal' ? 'medium' :
                             task.priority === 'medium' ? 'high' : 'normal';

        this.setPriority(taskId, nextPriority);
    },

    setArrowRouting(taskId, routing) {
        const task = this.tasks.find(t => t.id === taskId);
        if (!task) return;

        const truncatedTitle = task.title.length > 30 ? task.title.substring(0, 27) + '...' : task.title;
        const routingLabel = routing === 'direct' ? 'Direct' : routing === 'orthogonal' ? 'Orthogonal' : 'Inherit';

        this.saveSnapshot(`Set arrow routing of '${truncatedTitle}' to ${routingLabel}`);

        task.arrowRouting = routing;
        this.saveToStorage();
        this.render();

        // Show toast notification
        const emoji = routing === 'direct' ? '‚ÜóÔ∏è' : routing === 'orthogonal' ? '‚Ü™Ô∏è' : '‚öôÔ∏è';
        this.showToast(`${emoji} Arrow routing set to ${routingLabel}`, 'success', 2000);
    },

    /**
     * Get effective arrow routing mode for a node's OUTGOING arrows (to its children)
     * If node has 'inherit' or no setting, walks up parent chain until finding a setting
     * Falls back to global arrowRoutingMode if no ancestor has a setting
     * @param {Object} task - Parent task whose outgoing arrow style to determine
     * @returns {string} 'direct' or 'orthogonal'
     */
    getEffectiveArrowRouting(task) {
        // If task has explicit routing (not 'inherit'), use it
        if (task.arrowRouting && task.arrowRouting !== 'inherit') {
            return task.arrowRouting;
        }

        // Otherwise, walk up parent chain to find a setting
        let current = task.mainParent;
        while (current !== null) {
            const parent = this.tasks.find(t => t.id === current);
            if (!parent) break;

            if (parent.arrowRouting && parent.arrowRouting !== 'inherit') {
                return parent.arrowRouting;
            }

            current = parent.mainParent;
        }

        // No parent has a setting, use global default
        return this.arrowRoutingMode;
    },

    selectNode(taskId) {
        // Single-node selection (clears others)
        this.selectedTaskIds.clear();
        this.selectedTaskIds.add(taskId);
        this.lastClickedTaskId = taskId;

        // If selecting a working task, track it for Jump button
        const task = this.tasks.find(t => t.id === taskId);
        if (task && task.currentlyWorking) {
            this.lastWorkingTaskId = taskId;
            console.log(`[selectNode] Updated lastWorkingTaskId to ${taskId} (${task.title})`);
        } else if (task) {
            console.log(`[selectNode] Task ${taskId} (${task.title}) is not working, not updating lastWorkingTaskId`);
        }

        // Defer render to next frame to avoid breaking double-click
        requestAnimationFrame(() => this.render());
    },

    toggleHiddenSelf(taskId) {
        // Hide/show the node itself (not its children)
        const task = this.tasks.find(t => t.id === taskId);
        if (!task || task.mainParent === null) {
            // Can't hide root tasks - they have no parent
            return;
        }

        const truncatedTitle = task.title.length > 30 ? task.title.substring(0, 27) + '...' : task.title;
        this.saveSnapshot(task.hidden ? `Showed '${truncatedTitle}'` : `Hid '${truncatedTitle}'`);

        task.hidden = !task.hidden;

        this.saveToStorage();
        this.render();
    },

    toggleHidden(taskId) {
        // Toggle all descendants (children stay hidden as a group)
        const descendants = this.getDescendants(taskId);

        // Check if any are currently hidden
        const anyHidden = descendants.some(id => {
            const child = this.tasks.find(t => t.id === id);
            return child && child.hidden;
        });

        // Save snapshot
        const task = this.tasks.find(t => t.id === taskId);
        const truncatedTitle = task.title.length > 30 ? task.title.substring(0, 27) + '...' : task.title;
        this.saveSnapshot(anyHidden ? `Showed children of '${truncatedTitle}'` : `Hid children of '${truncatedTitle}'`);

        // Toggle: if any are hidden, show all; if all shown, hide all
        descendants.forEach(id => {
            const child = this.tasks.find(t => t.id === id);
            if (child) {
                child.hidden = !anyHidden;
            }
        });

        // If we're showing children again, make sure the parent is visible too
        if (anyHidden) {
            if (task) {
                task.hidden = false;
            }
        }

        this.saveToStorage();
        this.render();
    },

    getHiddenChildrenCount(taskId) {
        const task = this.tasks.find(t => t.id === taskId);
        if (!task) return 0;

        return task.children.filter(childId => {
            const child = this.tasks.find(t => t.id === childId);
            return child && child.hidden;
        }).length;
    },

    autoCollapseCompleted(clickedTaskId) {
        // Skip if auto-hide is disabled
        if (!this.autoHideCompletedNodes) {
            return;
        }

        // Only process the clicked task and its affected relatives, not all tasks
        const task = clickedTaskId ? this.tasks.find(t => t.id === clickedTaskId) : null;
        if (!task) return;

        // Check if any children are manually hidden via toggleHidden
        const hasManuallyHiddenChildren = task.children.some(childId => {
            const child = this.tasks.find(t => t.id === childId);
            return child && child.hidden;
        });

        // If task has manually hidden children, skip auto-hide for this task
        if (hasManuallyHiddenChildren) {
            return;
        }

        // Part 1: Hide completed children if task is done and all children are done
        if (task.children.length > 0 && task.status === 'done') {
            const allChildrenDone = task.children.every(childId => {
                const child = this.tasks.find(t => t.id === childId);
                return child && child.status === 'done';
            });

            // Hide all children if they're all done
            if (allChildrenDone) {
                task.children.forEach(childId => {
                    const child = this.tasks.find(t => t.id === childId);
                    if (child) child.hidden = true;
                });
            }
        }

        // Part 2: Hide the task itself ONLY if it has a parent AND that parent is done
        // Root tasks (no parent) are NEVER auto-hidden
        // Tasks inside non-completed parents are NEVER auto-hidden
        if (task.status === 'done' && task.mainParent !== null) {
            const parent = this.tasks.find(t => t.id === task.mainParent);
            if (parent && parent.status === 'done') {
                task.hidden = true;
            }
        }

        // Also process parent if it needs to be collapsed
        if (task.mainParent !== null) {
            const parent = this.tasks.find(t => t.id === task.mainParent);
            if (parent) {
                this.autoCollapseCompleted(parent.id);
            }
        }
    },

    clearCompleted() {
        this.tasks = this.tasks.filter(t => t.status !== 'done');
        this.saveToStorage();
        this.render();
    },

    toggleDarkMode() {
        this.darkMode = !this.darkMode;
        const btn = document.getElementById('darkModeToggle');
        if (this.darkMode) {
            document.body.classList.add('dark-mode');
            btn.textContent = '‚òÄÔ∏è Light Mode';
        } else {
            document.body.classList.remove('dark-mode');
            btn.textContent = 'üåô Dark Mode';
        }
        this.saveToStorage();
        this.render();
    },

    /**
     * Toggle debug Ctrl mode - all clicks/drags act as if Ctrl is pressed
     * Useful for testing Ctrl+drag features without holding Ctrl
     */
    toggleDebugCtrlMode() {
        this.debugCtrlMode = !this.debugCtrlMode;
        const btn = document.getElementById('debugCtrlToggle');
        if (this.debugCtrlMode) {
            btn.textContent = 'üîß Debug: Ctrl ON';
            btn.style.background = '#ff9800';
            btn.style.color = 'white';
            btn.style.fontWeight = 'bold';
            this.showToast('üîß Debug mode ON: All clicks/drags act as Ctrl+click/drag', 'info', 3000);
        } else {
            btn.textContent = 'üîß Debug: Ctrl OFF';
            btn.style.background = '';
            btn.style.color = '';
            btn.style.fontWeight = '';
            this.showToast('Debug mode OFF', 'info', 2000);
        }
        // Don't save to storage - debug mode should not persist
    },

    repairWorkingTasks(silent = false) {
        // Detect and fix data corruption where multiple tasks are marked as working
        const workingTasks = this.tasks.filter(t => t.currentlyWorking);

        if (workingTasks.length === 0) {
            if (!silent) {
                this.showToast('‚úì No issues found - data is clean', 'success', 2000);
            }
            return;
        }

        if (workingTasks.length === 1) {
            // Single working task - just verify workingTasksByRoot is correct
            const task = workingTasks[0];
            const root = this.getRootTask(task.id);
            const rootId = root ? root.id : null;

            if (rootId && this.workingTasksByRoot[rootId] !== task.id) {
                this.workingTasksByRoot[rootId] = task.id;
                this.saveToStorage();
                if (!silent) {
                    this.showToast('‚úì Fixed working task tracking', 'success', 2000);
                }
            } else if (!silent) {
                this.showToast('‚úì No issues found - data is clean', 'success', 2000);
            }
            return;
        }

        // Multiple working tasks - this is the bug!
        this.saveSnapshot('Repaired multiple working tasks');

        // Group working tasks by root
        const workingByRoot = {};
        for (const task of workingTasks) {
            const root = this.getRootTask(task.id);
            const rootId = root ? root.id : null;
            if (!workingByRoot[rootId]) {
                workingByRoot[rootId] = [];
            }
            workingByRoot[rootId].push(task);
        }

        let fixedCount = 0;

        // For each root tree, keep only the first working task
        for (const rootId in workingByRoot) {
            const tasksInRoot = workingByRoot[rootId];
            if (tasksInRoot.length > 1) {
                // Keep first, clear the rest
                for (let i = 1; i < tasksInRoot.length; i++) {
                    tasksInRoot[i].currentlyWorking = false;
                    if (!tasksInRoot[i].textLocked) {
                        tasksInRoot[i].textExpanded = false;
                    }
                    fixedCount++;
                }
                // Update workingTasksByRoot to point to the kept task
                this.workingTasksByRoot[rootId] = tasksInRoot[0].id;
            }
        }

        this.saveToStorage();
        this.updateStatusBar();
        this.render();

        if (!silent) {
            const taskWord = fixedCount === 1 ? 'task' : 'tasks';
            this.showToast(`‚úì Fixed ${fixedCount} ${taskWord} marked as working`, 'success', 3000);
        }
    }
});



// ============================================================
// CORE/RELATIONSHIPS.JS (Order: 17, Category: Core)
// ============================================================

/**
 * @order 17
 * @category Core Domain Logic
 * @description Task relationship management - parent-child, dependencies, cycle detection
 *
 * Functions extracted from task-tree.html (lines 4421-4602):
 * - reparentTask() - Change task's parent via Ctrl+drag
 * - addDependency() - Add dependency via Alt+drag (toggle if exists)
 * - removeDependency() - Remove specific dependency
 * - deleteLine() - Delete parent or dependency link
 * - wouldCreateCycle() - Check if dependency would create cycle
 */

Object.assign(app, {
    reparentTask({ taskId, newParentId }) {
        const task = this.tasks.find(t => t.id === taskId);
        const newParent = this.tasks.find(t => t.id === newParentId);

        console.log(`[REPARENT] taskId=${taskId}, newParentId=${newParentId}`);
        console.log(`[REPARENT] task coords: (${task?.x}, ${task?.y})`);
        console.log(`[REPARENT] newParent coords: (${newParent?.x}, ${newParent?.y})`);

        if (!task || !newParent) return;

        // Can't reparent to self or to own descendant
        if (taskId === newParentId || this.getDescendants(taskId).includes(newParentId)) {
            this.showAlert('Cannot Reparent', 'Cannot reparent to self or descendant!');
            return;
        }

        // Handle working task log if task is currently working
        if (task.currentlyWorking) {
            const oldRoot = this.getRootTask(taskId);

            // Will get new root after reparenting below, so we just remove from old root now
            if (oldRoot) {
                delete this.workingTasksByRoot[oldRoot.id];
            }
        }

        // Remove from old parent's children
        if (task.mainParent !== null) {
            const oldParent = this.tasks.find(t => t.id === task.mainParent);
            if (oldParent) {
                oldParent.children = oldParent.children.filter(id => id !== taskId);
            }
        }

        // Set new parent
        task.mainParent = newParentId;
        newParent.children.push(taskId);

        // Update working log if task is still working (after reparenting)
        if (task.currentlyWorking) {
            const newRoot = this.getRootTask(taskId);
            if (newRoot) {
                this.workingTasksByRoot[newRoot.id] = taskId;
            }
        }

        // Clean up redundant dependencies
        // Remove newParent from task's dependencies (task depending on its parent is redundant)
        task.dependencies = task.dependencies.filter(id => id !== newParentId);

        // Remove task from newParent's dependencies (parent depending on child would be circular)
        newParent.dependencies = newParent.dependencies.filter(id => id !== taskId);

        this.saveToStorage();
        this.updateStatusBar();
        this.render();
    },

    addDependency({ dependentId, prerequisiteId }) {
        const dependent = this.tasks.find(t => t.id === dependentId);
        if (!dependent) return;

        // Check if dependency already exists (toggle behavior)
        const existingIndex = dependent.dependencies.indexOf(prerequisiteId);
        if (existingIndex !== -1) {
            // Dependency exists, remove it
            const prerequisite = this.tasks.find(t => t.id === prerequisiteId);
            const depTitle = dependent.title.length > 20 ? dependent.title.substring(0, 17) + '...' : dependent.title;
            const preTitle = prerequisite.title.length > 20 ? prerequisite.title.substring(0, 17) + '...' : prerequisite.title;
            this.saveSnapshot(`Removed dependency: '${depTitle}' no longer depends on '${preTitle}'`);
            dependent.dependencies.splice(existingIndex, 1);
            this.saveToStorage();
            this.render();
            return;
        }

        // Prevent circular dependencies
        if (this.wouldCreateCycle(dependentId, prerequisiteId)) {
            this.showAlert('Cannot Create Dependency', 'Cannot create circular dependency!');
            return;
        }

        // Add new dependency
        const prerequisite = this.tasks.find(t => t.id === prerequisiteId);
        const depTitle = dependent.title.length > 20 ? dependent.title.substring(0, 17) + '...' : dependent.title;
        const preTitle = prerequisite.title.length > 20 ? prerequisite.title.substring(0, 17) + '...' : prerequisite.title;
        this.saveSnapshot(`Added dependency: '${depTitle}' depends on '${preTitle}'`);
        dependent.dependencies.push(prerequisiteId);
        this.saveToStorage();
        this.render();
    },

    removeDependency(fromId, toId) {
        const from = this.tasks.find(t => t.id === fromId);
        if (from) {
            const to = this.tasks.find(t => t.id === toId);
            const fromTitle = from.title.length > 20 ? from.title.substring(0, 17) + '...' : from.title;
            const toTitle = to.title.length > 20 ? to.title.substring(0, 17) + '...' : to.title;
            this.saveSnapshot(`Removed dependency: '${fromTitle}' no longer depends on '${toTitle}'`);
            from.dependencies = from.dependencies.filter(id => id !== toId);
            this.saveToStorage();
            this.render();
        }
    },

    deleteLine(lineData) {
        if (lineData.type === 'parent') {
            // Remove parent-child relationship
            const task = this.tasks.find(t => t.id === lineData.taskId);
            if (task) {
                if (task.mainParent === lineData.parentId) {
                    // Remove main parent - child becomes root
                    task.mainParent = null;
                }
                // Also try to remove from otherParents
                task.otherParents = task.otherParents.filter(id => id !== lineData.parentId);

                // Remove from parent's children list
                const parent = this.tasks.find(t => t.id === lineData.parentId);
                if (parent) {
                    parent.children = parent.children.filter(id => id !== lineData.taskId);
                }

                this.saveToStorage();
                this.selectedLine = null;
                this.render();
            }
        } else if (lineData.type === 'dependency') {
            // Remove dependency
            this.removeDependency(lineData.from, lineData.to);
            this.selectedLine = null;
        }
    },

    wouldCreateCycle(fromId, toId) {
        // Check if adding dependency from->to would create a cycle
        const visited = new Set();
        const queue = [toId];

        while (queue.length > 0) {
            const current = queue.shift();
            if (current === fromId) return true;
            if (visited.has(current)) continue;

            visited.add(current);
            const task = this.tasks.find(t => t.id === current);
            if (task) {
                queue.push(...task.dependencies);
            }
        }

        return false;
    }
});



// ============================================================
// RENDERING/GRID.JS (Order: 19, Category: rendering)
// ============================================================

/**
 * @module rendering/grid
 * @order 19
 * @category rendering
 * @description Grid rendering - draws background grid for visual alignment
 *
 * KEY FUNCTIONS:
 *
 * renderGrid() - Renders grid lines on canvas
 * - Calculates visible grid lines based on viewport
 * - Creates SVG line elements for grid
 * - Updates on pan/zoom changes
 * - Performance optimized: only renders visible lines
 *
 * clearGrid() - Removes all grid lines from canvas
 * - Clears existing grid group
 * - Called when grid is disabled
 *
 * Grid is rendered behind all other elements (order: 19, before nodes/links)
 */

Object.assign(app, {
    /**
     * Render grid lines on the canvas
     * Only renders lines visible in current viewport for performance
     */
    renderGrid() {
        if (!this.gridEnabled) {
            this.clearGrid();
            return;
        }

        const svg = document.getElementById('canvas');
        let gridGroup = document.getElementById('grid-group');

        // Create grid group if it doesn't exist (should be first child)
        if (!gridGroup) {
            gridGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
            gridGroup.id = 'grid-group';
            // Insert as first child so grid renders behind everything
            svg.insertBefore(gridGroup, svg.firstChild);
        }

        // Clear existing grid lines
        gridGroup.innerHTML = '';

        const { x, y, width, height } = this.viewBox;
        const size = this.gridSize;

        // Calculate grid bounds with some padding for smooth panning
        const startX = Math.floor(x / size) * size - size;
        const endX = Math.ceil((x + width) / size) * size + size;
        const startY = Math.floor(y / size) * size - size;
        const endY = Math.ceil((y + height) / size) * size + size;

        // Use dark mode aware color
        const color = this.darkMode
            ? 'rgba(255, 255, 255, 0.1)'
            : this.gridColor;

        // Draw vertical lines
        for (let i = startX; i <= endX; i += size) {
            const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
            line.setAttribute('x1', i);
            line.setAttribute('y1', startY);
            line.setAttribute('x2', i);
            line.setAttribute('y2', endY);
            line.setAttribute('stroke', color);
            line.setAttribute('stroke-width', '1');
            line.style.pointerEvents = 'none'; // Grid doesn't intercept clicks
            gridGroup.appendChild(line);
        }

        // Draw horizontal lines
        for (let i = startY; i <= endY; i += size) {
            const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
            line.setAttribute('x1', startX);
            line.setAttribute('y1', i);
            line.setAttribute('x2', endX);
            line.setAttribute('y2', i);
            line.setAttribute('stroke', color);
            line.setAttribute('stroke-width', '1');
            line.style.pointerEvents = 'none';
            gridGroup.appendChild(line);
        }
    },

    /**
     * Clear all grid lines from canvas
     */
    clearGrid() {
        const gridGroup = document.getElementById('grid-group');
        if (gridGroup) {
            gridGroup.innerHTML = '';
        }
    },

    /**
     * Snap coordinate to grid
     * @param {number} coord - The coordinate to snap
     * @returns {number} - Snapped coordinate
     */
    snapToGrid(coord) {
        if (!this.gridEnabled || !this.gridSnapEnabled) {
            return coord;
        }
        return Math.round(coord / this.gridSize) * this.gridSize;
    },

    /**
     * Snap a point (x, y) to grid
     * @param {number} x - X coordinate
     * @param {number} y - Y coordinate
     * @returns {{x: number, y: number}} - Snapped coordinates
     */
    snapPointToGrid(x, y) {
        return {
            x: this.snapToGrid(x),
            y: this.snapToGrid(y)
        };
    }
});

console.log('[grid.js] Grid rendering module loaded');



// ============================================================
// RENDERING/GOLDEN-PATH.JS (Order: 20, Category: rendering)
// ============================================================

/**
 * @module rendering/golden-path
 * @order 20
 * @category rendering
 *
 * Golden path visualization - tracks working task ancestors and children
 */

Object.assign(app, {
    getWorkingTaskPath() {
        // Returns ancestor and descendant paths for the currently working task
        // Used for golden path visualization
        const workingTask = this.tasks.find(t => t.currentlyWorking);
        if (!workingTask) {
            return { workingTaskId: null, ancestorPath: new Set(), directChildren: [] };
        }

        // Build full ancestor path (working task ‚Üí root)
        // This includes the working task itself AND all ancestors
        const ancestorPath = new Set();
        ancestorPath.add(workingTask.id);  // Include working task itself
        let current = workingTask.mainParent;
        while (current !== null) {
            ancestorPath.add(current);
            const parent = this.tasks.find(t => t.id === current);
            current = parent ? parent.mainParent : null;
        }

        // Get direct children with their completion status
        const directChildren = workingTask.children.map(childId => {
            const child = this.tasks.find(t => t.id === childId);
            return {
                id: childId,
                isDone: child ? child.status === 'done' : false
            };
        });

        return {
            workingTaskId: workingTask.id,
            ancestorPath,
            directChildren
        };
    }
});



// ============================================================
// RENDERING/INDICATORS.JS (Order: 21, Category: rendering)
// ============================================================

/**
 * @module rendering/indicators
 * @order 21
 * @category rendering
 *
 * Off-screen indicators for working tasks and homes
 */

Object.assign(app, {
    renderOffscreenIndicators() {
        // Show arrows on screen edges pointing to off-screen targets (working tasks and homes)
        const container = document.getElementById('offscreen-indicators');
        if (!container) return;

        // Clear existing indicators
        container.innerHTML = '';

        // Calculate visible viewport bounds in SVG coordinates
        const svg = document.getElementById('canvas');
        const actualViewBoxWidth = this.viewBox.width / this.zoomLevel;
        const actualViewBoxHeight = this.viewBox.height / this.zoomLevel;
        const viewportLeft = this.viewBox.x - (actualViewBoxWidth - this.viewBox.width) / 2;
        const viewportRight = viewportLeft + actualViewBoxWidth;
        const viewportTop = this.viewBox.y - (actualViewBoxHeight - this.viewBox.height) / 2;
        const viewportBottom = viewportTop + actualViewBoxHeight;
        const viewportCenterX = (viewportLeft + viewportRight) / 2;
        const viewportCenterY = (viewportTop + viewportBottom) / 2;

        // Get all working tasks
        const workingTasks = this.tasks.filter(t => t.currentlyWorking && !t.hidden);

        // Find off-screen working tasks
        const offscreenTasks = workingTasks.filter(task => {
            return task.x < viewportLeft || task.x > viewportRight ||
                   task.y < viewportTop || task.y > viewportBottom;
        });

        // Find off-screen homes
        const offscreenHomes = this.homes.filter(home => {
            return home.centerX < viewportLeft || home.centerX > viewportRight ||
                   home.centerY < viewportTop || home.centerY > viewportBottom;
        });

        // Use canvas-container dimensions (not window, to avoid overlapping buttons)
        const canvasContainer = document.getElementById('canvas-container');
        const screenWidth = canvasContainer.clientWidth;
        const screenHeight = canvasContainer.clientHeight;
        const margin = 20; // Pixels from edge

        // Calculate top margin to avoid controls bar overlap
        // Controls bar is position:fixed, canvas-container has top:65px, but controls might be taller
        const controlsBar = document.getElementById('controls');
        const controlsBottom = controlsBar ? controlsBar.getBoundingClientRect().bottom : 65; // Actual bottom position
        const canvasTop = canvasContainer.getBoundingClientRect().top; // Actual canvas top position
        const overlap = Math.max(0, controlsBottom - canvasTop); // How much controls extends into canvas
        const topMargin = overlap + 20; // Overlap + 20px buffer (increased for safety)

        // Render indicators for each off-screen working task
        offscreenTasks.forEach(task => {
            this.createDirectionalIndicator({
                container,
                targetX: task.x,
                targetY: task.y,
                viewportCenterX,
                viewportCenterY,
                screenWidth,
                screenHeight,
                margin,
                topMargin,
                type: 'task',
                title: task.title,
                onClick: () => this.jumpToWorkingTask(task.id)
            });
        });

        // Render indicators for each off-screen home
        offscreenHomes.forEach(home => {
            this.createDirectionalIndicator({
                container,
                targetX: home.centerX,
                targetY: home.centerY,
                viewportCenterX,
                viewportCenterY,
                screenWidth,
                screenHeight,
                margin,
                topMargin,
                type: 'home',
                title: home.name,
                icon: home.icon || 'üè†',  // Use custom icon or default
                onClick: () => this.jumpToHome(home.id)
            });
        });
    },

    createDirectionalIndicator({ container, targetX, targetY, viewportCenterX, viewportCenterY, screenWidth, screenHeight, margin, topMargin, type, title, icon, onClick }) {
        // Calculate angle from viewport center to target
        const dx = targetX - viewportCenterX;
        const dy = targetY - viewportCenterY;
        const angle = Math.atan2(dy, dx); // Radians

        // Screen center
        const screenCenterX = screenWidth / 2;
        const screenCenterY = screenHeight / 2;

        // Find intersection with screen rectangle
        // Ray from center: (screenCenterX + t*cos(angle), screenCenterY + t*sin(angle))
        const cosAngle = Math.cos(angle);
        const sinAngle = Math.sin(angle);

        // Calculate t for each edge intersection (use topMargin for top edge to avoid header)
        const tRight = cosAngle > 0 ? (screenWidth - margin - screenCenterX) / cosAngle : Infinity;
        const tLeft = cosAngle < 0 ? (margin - screenCenterX) / cosAngle : Infinity;
        const tBottom = sinAngle > 0 ? (screenHeight - margin - screenCenterY) / sinAngle : Infinity;
        const tTop = sinAngle < 0 ? (topMargin - screenCenterY) / sinAngle : Infinity;

        // Find minimum positive t (closest intersection)
        const t = Math.min(tRight, tLeft, tBottom, tTop);

        // Calculate intersection point
        const edgeX = screenCenterX + t * cosAngle;
        const edgeY = screenCenterY + t * sinAngle;

        // Create indicator
        const indicator = document.createElement('div');
        indicator.className = 'offscreen-indicator' + (type === 'home' ? ' home' : '');
        indicator.style.left = `${edgeX}px`;
        indicator.style.top = `${edgeY}px`;

        // Convert radians to degrees
        const rotation = angle * (180 / Math.PI);

        // For homes: add 90 degrees so the roof points in the direction (not the side)
        const finalRotation = type === 'home' ? rotation + 90 : rotation;

        // Rotate arrows and homes to point toward target
        indicator.style.transform = `translate(-50%, -50%) rotate(${finalRotation}deg)`;

        // Use different emojis: arrow for tasks, custom icon for homes
        indicator.innerHTML = type === 'home' ? (icon || 'üè†') : '‚û§';

        // Create separate tooltip element (won't rotate with indicator)
        const tooltip = document.createElement('div');
        tooltip.className = 'indicator-tooltip';
        const prefix = type === 'home' ? `${icon || 'üè†'} Home: ` : 'üéØ Task: ';
        tooltip.textContent = prefix + title;

        // Position tooltip on opposite side (visible side) based on angle
        // Normalize angle to 0-360
        const normalizedAngle = ((rotation % 360) + 360) % 360;

        // Determine best position for tooltip (opposite to where indicator is pointing inward)
        let tooltipX = edgeX;
        let tooltipY = edgeY;

        if (normalizedAngle >= 315 || normalizedAngle < 45) {
            // Pointing right, tooltip on left
            tooltipX = edgeX - 50;
            tooltipY = edgeY;
            tooltip.style.transform = 'translate(-100%, -50%)';
        } else if (normalizedAngle >= 45 && normalizedAngle < 135) {
            // Pointing down, tooltip on top
            tooltipX = edgeX;
            tooltipY = edgeY - 50;
            tooltip.style.transform = 'translate(-50%, -100%)';
        } else if (normalizedAngle >= 135 && normalizedAngle < 225) {
            // Pointing left, tooltip on right
            tooltipX = edgeX + 50;
            tooltipY = edgeY;
            tooltip.style.transform = 'translate(0%, -50%)';
        } else {
            // Pointing up, tooltip on bottom
            tooltipX = edgeX;
            tooltipY = edgeY + 50;
            tooltip.style.transform = 'translate(-50%, 0%)';
        }

        tooltip.style.left = `${tooltipX}px`;
        tooltip.style.top = `${tooltipY}px`;

        // Show/hide tooltip on hover
        indicator.onmouseenter = () => tooltip.classList.add('visible');
        indicator.onmouseleave = () => tooltip.classList.remove('visible');

        indicator.title = title; // Fallback for browsers without CSS support
        indicator.onclick = onClick;

        // Add right-click support for home indicators to set icon
        if (type === 'home') {
            indicator.oncontextmenu = (e) => {
                e.preventDefault();
                e.stopPropagation();
                // Find the home by name to get its ID
                const home = this.homes.find(h => h.name === title);
                if (home) {
                    this.setHomeIcon(home.id);
                }
            };
        }

        container.appendChild(indicator);
        container.appendChild(tooltip);
    }
});



// ============================================================
// RENDERING/NODES.JS (Order: 22, Category: rendering)
// ============================================================

/**
 * @module rendering/nodes
 * @order 22
 * @category rendering
 *
 * Task node rendering - SVG generation for task rectangles with text
 */

Object.assign(app, {
    /**
     * Convert tab characters to spaces for SVG display
     * SVG text elements don't render tabs visibly, so we convert them to spaces
     * @param {string} text - Text with tabs
     * @returns {string} Text with tabs converted to spaces
     */
    convertTabsToSpaces(text) {
        if (!text) return text;
        const spaces = ' '.repeat(this.tabWidth || 4);
        return text.replace(/\t/g, spaces);
    },

    wrapText(text, maxWidth, charWidth, wordWrap) {
        // Convert tabs to spaces for SVG display (SVG doesn't render tabs)
        const displayText = this.convertTabsToSpaces(text);

        // Return single line if multiline is disabled
        if (!this.enableMultiline) {
            return [displayText];
        }

        // Calculate maximum characters that fit in one line
        const maxChars = Math.floor(maxWidth / charWidth);
        if (maxChars <= 0) return [displayText]; // Safety check

        // NEW: First split by newlines to preserve user line breaks
        const paragraphs = displayText.split('\n');
        const allLines = [];

        // Process each paragraph (line break = user intent)
        for (const paragraph of paragraphs) {
            // Handle empty lines (preserve them as blank lines)
            if (paragraph === '') {
                allLines.push('');
                continue;
            }

            if (wordWrap) {
                // Split into tokens: words AND spaces (preserves all whitespace)
                // Match sequences of non-whitespace OR sequences of spaces
                const tokens = paragraph.match(/\S+| +/g) || [];
                let currentLine = '';

                for (const token of tokens) {
                    const testLine = currentLine + token;
                    const testWidth = testLine.length * charWidth;

                    if (testWidth <= maxWidth) {
                        currentLine = testLine;
                    } else {
                        // Line would be too long
                        const isSpaceToken = token.startsWith(' ');

                        if (isSpaceToken) {
                            // Don't wrap in the middle of spaces - add them to current line
                            // (This handles edge case of many spaces)
                            if (currentLine) {
                                allLines.push(currentLine);
                            }
                            currentLine = token;
                        } else {
                            // Word token - wrap before it
                            if (currentLine) {
                                allLines.push(currentLine);
                            }

                            // Handle single word longer than max width
                            if (token.length * charWidth > maxWidth) {
                                // Force character break for long words
                                let remaining = token;
                                while (remaining.length > 0) {
                                    allLines.push(remaining.substring(0, maxChars));
                                    remaining = remaining.substring(maxChars);
                                }
                                currentLine = '';
                            } else {
                                currentLine = token;
                            }
                        }
                    }
                }

                if (currentLine) {
                    allLines.push(currentLine);
                }
            } else {
                // Character wrapping - simple split at max chars for this paragraph
                for (let i = 0; i < paragraph.length; i += maxChars) {
                    allLines.push(paragraph.substring(i, i + maxChars));
                }
            }
        }

        // Return at least one line (even if empty)
        return allLines.length > 0 ? allLines : [''];
    },

    /**
     * Calculate task dimensions with multiline support
     * @param {Object} task - Task object
     * @returns {{width: number, height: number, lines: string[]}} Dimensions object
     */
    calculateTaskDimensions(task) {
        // Helper: Calculate task dimensions with multiline support

        // For image nodes, use image dimensions with padding
        if (task.imageId && task.imageWidth && task.imageHeight) {
            const imagePadding = 20;
            return {
                width: task.imageWidth + imagePadding * 2,
                height: task.imageHeight + imagePadding * 2,
                lines: []
            };
        }

        // For text nodes, calculate based on text content
        const padding = this.nodePadding;
        const charWidth = this.charWidth;
        const minWidth = this.minNodeWidth;

        // Determine display text (same logic as main rendering)
        const charsOverLimit = task.title.length - this.textLengthThreshold;
        const shouldTruncate = charsOverLimit > 5;
        const shouldExpand = task.currentlyWorking || task.textLocked || (task.textExpanded && this.selectedTaskIds.has(task.id));
        const displayTitle = (shouldTruncate && !shouldExpand) ? task.title.substring(0, this.textLengthThreshold) + '...' : task.title;

        // Use full text for multiline, truncated for single-line
        const textForSizing = this.enableMultiline ? task.title : displayTitle;

        // Wrap text into lines (subtract padding to ensure text fits within available space)
        const availableWidth = this.maxNodeWidth - padding * 2;
        const lines = this.wrapText(textForSizing, availableWidth, charWidth, this.wordWrap);

        // Calculate width
        const longestLineWidth = Math.max(...lines.map(line => line.length * charWidth + padding * 2));
        const rectWidth = Math.max(minWidth, Math.min(this.maxNodeWidth, longestLineWidth));

        // Calculate height (use fixed vertical padding, not nodePadding)
        const verticalPadding = 10;
        // Add extra bottom padding if task has tracked time (for time badge)
        const hasTimeTracking = task.timeTracking && task.timeTracking.totalSeconds > 0;
        const extraBottomPadding = hasTimeTracking ? 18 : 0;
        const calculatedHeight = lines.length * this.lineHeight + verticalPadding * 2 + extraBottomPadding;
        const rectHeight = this.maxNodeHeight > 0
            ? Math.min(this.maxNodeHeight, calculatedHeight)
            : calculatedHeight;

        // Return width/height (not rectWidth/rectHeight) to match render() expectations
        return { width: rectWidth, height: rectHeight, lines };
    },

    /**
     * Calculate rectangle dimensions for given text
     * Used by both render() and resizeEditingBox() for consistent sizing
     * @param {string} text - Text content
     * @returns {{width: number, height: number, lines: string[]}} Dimensions object
     */
    calculateTextBoxDimensions(text) {
        // Helper method to calculate rectangle dimensions for given text
        // Returns { width, height, lines }
        // Used by both render() and resizeEditingBox() for consistent sizing

        const padding = this.nodePadding;
        const charWidth = this.charWidth;
        const minWidth = this.minNodeWidth;

        // Wrap text into lines based on max width (subtract padding to ensure text fits within available space)
        const availableWidth = this.maxNodeWidth - padding * 2;
        const lines = this.wrapText(text, availableWidth, charWidth, this.wordWrap);

        // Calculate width: minimum of (maxNodeWidth OR longest line width OR minWidth)
        const longestLineWidth = Math.max(...lines.map(line => line.length * charWidth + padding * 2));
        const rectWidth = Math.max(minWidth, Math.min(this.maxNodeWidth, longestLineWidth));

        // Calculate height: lines * lineHeight + vertical padding
        const verticalPadding = 10;
        const calculatedHeight = lines.length * this.lineHeight + verticalPadding * 2;

        // Apply max height constraint if configured
        const rectHeight = this.maxNodeHeight > 0
            ? Math.min(this.maxNodeHeight, calculatedHeight)
            : calculatedHeight;

        // Return width/height (not rectWidth/rectHeight) to match caller expectations
        return { width: rectWidth, height: rectHeight, lines };
    }
});



// ============================================================
// RENDERING/LINKS.JS (Order: 23, Category: rendering)
// ============================================================

/**
 * @module rendering/links
 * @order 23
 * @category rendering
 *
 * Link rendering - Lines, arrows, curved paths, temp drag lines
 */

Object.assign(app, {
    /**
     * Create curved line with control point (quadratic bezier)
     *
     * @param {number} x1 - Start X
     * @param {number} y1 - Start Y
     * @param {number} cx - Control point X
     * @param {number} cy - Control point Y
     * @param {number} x2 - End X
     * @param {number} y2 - End Y
     * @param {string} className - CSS class
     * @returns {SVGPathElement} Curved path element
     */
    createCurvedLine(x1, y1, cx, cy, x2, y2, className) {
        // Defensive: Check for invalid coordinates
        if (!isFinite(x1) || !isFinite(y1) || !isFinite(cx) || !isFinite(cy) || !isFinite(x2) || !isFinite(y2)) {
            console.warn(`createCurvedLine called with invalid coordinates`);
            // Return dummy path
            const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
            path.setAttribute('d', 'M 0 0');
            path.setAttribute('class', className);
            path.setAttribute('fill', 'none');
            path.style.display = 'none';
            return path;
        }

        const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');

        // Quadratic bezier: M start Q control end
        const d = `M ${x1} ${y1} Q ${cx} ${cy}, ${x2} ${y2}`;

        path.setAttribute('d', d);
        path.setAttribute('class', className);
        path.setAttribute('fill', 'none');

        // Store coordinates for later reference
        path.setAttribute('data-x1', x1);
        path.setAttribute('data-y1', y1);
        path.setAttribute('data-cx', cx);
        path.setAttribute('data-cy', cy);
        path.setAttribute('data-x2', x2);
        path.setAttribute('data-y2', y2);

        return path;
    },

    /**
     * Create curved line through control points using Catmull-Rom spline
     * Simple, clean curve passing through all specified points
     *
     * @param {number} x1 - Start X
     * @param {number} y1 - Start Y
     * @param {number} x2 - End X
     * @param {number} y2 - End Y
     * @param {Array<{x: number, y: number}>} controlPoints - Points ON the curve
     * @param {string} className - CSS class
     * @param {boolean} useStraightSegments - Use straight lines instead of curves (for orthogonal routing)
     * @param {number} cornerRadius - Corner radius for orthogonal routing (default from app.orthogonalCornerRadius)
     * @returns {SVGPathElement} Curved path element
     */
    createMultiSegmentCurvedLine(x1, y1, x2, y2, controlPoints, className, useStraightSegments = false, cornerRadius = null) {
        const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
        path.setAttribute('class', className);
        path.setAttribute('fill', 'none');

        // Defensive: Check for invalid coordinates
        if (!isFinite(x1) || !isFinite(y1) || !isFinite(x2) || !isFinite(y2)) {
            console.warn(`createMultiSegmentCurvedLine: invalid coordinates`);
            path.setAttribute('d', 'M 0 0');
            path.style.display = 'none';
            return path;
        }

        // No control points - straight line
        if (!controlPoints || !Array.isArray(controlPoints) || controlPoints.length === 0) {
            path.setAttribute('d', `M ${x1} ${y1} L ${x2} ${y2}`);
            return path;
        }

        // Use straight segments with rounded corners for orthogonal routing
        if (useStraightSegments) {
            // Use default corner radius if not provided
            const radius = cornerRadius !== null ? cornerRadius : (this.orthogonalCornerRadius || 15);

            // Build array of all points
            const allPoints = [
                { x: x1, y: y1 },
                ...controlPoints,
                { x: x2, y: y2 }
            ];

            let pathData = `M ${allPoints[0].x} ${allPoints[0].y}`;

            for (let i = 1; i < allPoints.length; i++) {
                const prev = allPoints[i - 1];
                const curr = allPoints[i];
                const next = i < allPoints.length - 1 ? allPoints[i + 1] : null;

                if (radius > 0 && next) {
                    // Calculate vectors
                    const dx1 = curr.x - prev.x;
                    const dy1 = curr.y - prev.y;
                    const len1 = Math.sqrt(dx1 * dx1 + dy1 * dy1);

                    const dx2 = next.x - curr.x;
                    const dy2 = next.y - curr.y;
                    const len2 = Math.sqrt(dx2 * dx2 + dy2 * dy2);

                    // Use smaller radius if segment is too short
                    const effectiveRadius = Math.min(radius, len1 / 2, len2 / 2);

                    // Calculate points for rounded corner
                    const beforeCorner = {
                        x: curr.x - (dx1 / len1) * effectiveRadius,
                        y: curr.y - (dy1 / len1) * effectiveRadius
                    };

                    const afterCorner = {
                        x: curr.x + (dx2 / len2) * effectiveRadius,
                        y: curr.y + (dy2 / len2) * effectiveRadius
                    };

                    // Draw line to before corner, then curve around corner
                    pathData += ` L ${beforeCorner.x} ${beforeCorner.y}`;
                    pathData += ` Q ${curr.x} ${curr.y}, ${afterCorner.x} ${afterCorner.y}`;
                } else {
                    // Last point or no rounding - just draw straight line
                    pathData += ` L ${curr.x} ${curr.y}`;
                }
            }

            path.setAttribute('d', pathData);
            return path;
        }

        // Build complete curve path: start -> control points -> end
        const points = [
            { x: x1, y: y1 },
            ...controlPoints,
            { x: x2, y: y2 }
        ];

        // Generate Catmull-Rom spline through all points
        let pathData = `M ${points[0].x} ${points[0].y}`;

        for (let i = 0; i < points.length - 1; i++) {
            const p0 = points[Math.max(0, i - 1)];
            const p1 = points[i];
            const p2 = points[i + 1];
            const p3 = points[Math.min(points.length - 1, i + 2)];

            // Catmull-Rom to cubic bezier conversion
            const c1x = p1.x + (p2.x - p0.x) / 6;
            const c1y = p1.y + (p2.y - p0.y) / 6;
            const c2x = p2.x - (p3.x - p1.x) / 6;
            const c2y = p2.y - (p3.y - p1.y) / 6;

            pathData += ` C ${c1x} ${c1y}, ${c2x} ${c2y}, ${p2.x} ${p2.y}`;
        }

        path.setAttribute('d', pathData);
        return path;
    },

    createLine(x1, y1, x2, y2, className) {
        // Defensive: Check for NaN or invalid coordinates
        if (!isFinite(x1) || !isFinite(y1) || !isFinite(x2) || !isFinite(y2)) {
            console.warn(`createLine called with invalid coordinates: (${x1},${y1}) to (${x2},${y2})`);
            // Return a dummy line at origin to avoid breaking render
            const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
            line.setAttribute('x1', 0);
            line.setAttribute('y1', 0);
            line.setAttribute('x2', 0);
            line.setAttribute('y2', 0);
            line.setAttribute('class', className);
            line.style.display = 'none'; // Hide invalid lines
            return line;
        }

        // Dispatch to appropriate renderer based on arrow style
        if (this.arrowStyle === 'curved') {
            return this.createCurvedPath(x1, y1, x2, y2, className);
        } else {
            // Default: straight line
            const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
            line.setAttribute('x1', x1);
            line.setAttribute('y1', y1);
            line.setAttribute('x2', x2);
            line.setAttribute('y2', y2);
            line.setAttribute('class', className);
            return line;
        }
    },

    createCurvedPath(x1, y1, x2, y2, className) {
        // Defensive: Check for NaN or invalid coordinates
        if (!isFinite(x1) || !isFinite(y1) || !isFinite(x2) || !isFinite(y2)) {
            console.warn(`createCurvedPath called with invalid coordinates: (${x1},${y1}) to (${x2},${y2})`);
            const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
            path.setAttribute('d', 'M 0 0');
            path.setAttribute('class', className);
            path.setAttribute('fill', 'none');
            path.style.display = 'none';
            return path;
        }

        const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');

        // Calculate curve control points
        const dx = x2 - x1;
        const dy = y2 - y1;
        const distance = Math.sqrt(dx * dx + dy * dy);

        // Curve intensity based on distance and user setting
        const curveAmount = distance * this.arrowCurvature;

        // Create perpendicular offset for smooth curve
        // Use perpendicular direction to curve sideways
        const angle = Math.atan2(dy, dx);
        const perpAngle = angle + Math.PI / 2;

        // Control points offset perpendicular to the line
        const offsetX = Math.cos(perpAngle) * curveAmount;
        const offsetY = Math.sin(perpAngle) * curveAmount;

        // Midpoint for control
        const midX = (x1 + x2) / 2;
        const midY = (y1 + y2) / 2;

        // Quadratic bezier curve through offset midpoint
        const d = `M ${x1} ${y1} Q ${midX + offsetX} ${midY + offsetY}, ${x2} ${y2}`;

        path.setAttribute('d', d);
        path.setAttribute('class', className);
        path.setAttribute('fill', 'none'); // Paths need fill=none to show stroke

        return path;
    },

    getLineEndAtRectEdge(x1, y1, x2, y2, rectWidth, rectHeight) {
        // Calculate line endpoint at rectangle edge for pixel-perfect arrows
        // Direction vector from point 1 to point 2
        const dx = x2 - x1;
        const dy = y2 - y1;
        const distance = Math.sqrt(dx * dx + dy * dy);

        if (distance === 0) {
            // Same point, no direction
            return { x: x2, y: y2 };
        }

        // Normalize to unit vector
        const ux = dx / distance;
        const uy = dy / distance;

        // Rectangle half-dimensions (rect is centered at x2, y2)
        const halfWidth = rectWidth / 2;
        const halfHeight = rectHeight / 2;

        // Find which edge the line hits first
        // Compare using cross-multiplication to avoid division
        const absUx = Math.abs(ux);
        const absUy = Math.abs(uy);

        let edgeDistance;
        if (absUx * halfHeight > absUy * halfWidth) {
            // Hit vertical edge (left/right) first
            // Guard against division by zero (perfectly vertical line)
            if (absUx === 0) {
                edgeDistance = 0;
            } else {
                edgeDistance = halfWidth / absUx;
            }
        } else {
            // Hit horizontal edge (top/bottom) first
            // Guard against division by zero (perfectly horizontal line)
            if (absUy === 0) {
                edgeDistance = 0;
            } else {
                edgeDistance = halfHeight / absUy;
            }
        }

        // Calculate endpoint at rectangle edge
        return {
            x: x2 - ux * edgeDistance,
            y: y2 - uy * edgeDistance
        };
    },

    createCursorArrow() {
        // Create SVG element for custom cursor
        const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
        svg.classList.add('cursor-arrow');
        svg.setAttribute('width', '24px');
        svg.setAttribute('height', '24px');
        svg.setAttribute('viewBox', '0 0 24 24');
        svg.style.left = '0px';
        svg.style.top = '0px';
        svg.style.width = '24px';
        svg.style.height = '24px';

        // Create arrowhead path (pointing RIGHT by default, rotation will be applied)
        const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
        path.setAttribute('d', 'M2,12 L22,12 M22,12 L15,5 M22,12 L15,19');
        path.setAttribute('stroke-width', '2');
        path.setAttribute('stroke-linecap', 'round');
        path.setAttribute('stroke-linejoin', 'round');
        path.setAttribute('fill', 'none');

        svg.appendChild(path);
        document.body.appendChild(svg);

        // Hide default cursor
        const container = document.getElementById('canvas-container');
        container.classList.add('dragging-relationship');

        return svg;
    },

    removeCursorArrow() {
        if (this.cursorArrow) {
            this.cursorArrow.remove();
            this.cursorArrow = null;
        }
        // Restore default cursor
        const container = document.getElementById('canvas-container');
        container.classList.remove('dragging-relationship');
    },

    updateCursorArrow(clientX, clientY, sourceTask) {
        if (!this.cursorArrow || !sourceTask) return;

        // Position the arrow at cursor (offset slightly so it doesn't block elementFromPoint)
        this.cursorArrow.style.left = `${clientX - 12}px`;
        this.cursorArrow.style.top = `${clientY - 12}px`;

        // Calculate rotation angle from source to cursor
        const pt = this.getSVGPoint({ clientX, clientY });
        const dx = pt.x - sourceTask.x;
        const dy = pt.y - sourceTask.y;
        const angle = Math.atan2(dy, dx) * (180 / Math.PI); // Convert to degrees

        // Apply rotation (rotate around center of SVG)
        this.cursorArrow.style.transform = `rotate(${angle}deg)`;
        this.cursorArrow.style.transformOrigin = '12px 12px';
    },

    createTempLine(e) {
        const task = this.tasks.find(t => t.id === this.selectedNode);
        const svg = document.getElementById('canvas');
        this.tempLine = document.createElementNS('http://www.w3.org/2000/svg', 'line');
        this.tempLine.classList.add('temp-line');

        // Style based on drag mode
        if (this.dragMode === 'reparent') {
            // Solid green line for reparenting
            this.tempLine.style.strokeDasharray = 'none';
            this.tempLine.style.stroke = '#28a745';
            // No arrowhead - cursor arrow already shows direction
        } else {
            // Dashed blue line for dependency
            this.tempLine.style.strokeDasharray = '5,5';
            this.tempLine.style.stroke = '#007bff';
            // No arrowhead - cursor arrow already shows direction
        }

        this.tempLine.setAttribute('x1', task.x);
        this.tempLine.setAttribute('y1', task.y);
        this.tempLine.setAttribute('x2', task.x);
        this.tempLine.setAttribute('y2', task.y);
        svg.appendChild(this.tempLine);
    },

    removeTempLine() {
        if (this.tempLine) {
            this.tempLine.remove();
            this.tempLine = null;
        }
    },

    markOrigin() {
        // Create or update "Origin Home" to current view
        const originHome = this.homes.find(h => h.name === "Origin Home");

        if (originHome) {
            // Update existing Origin Home
            this.updateHome(originHome.id);
        } else {
            // Create new Origin Home
            this.createHome("Origin Home");
        }
    },

    /**
     * Render arrow dot (for dragging arrow endpoints)
     *
     * @param {number} x - Dot center X
     * @param {number} y - Dot center Y
     * @param {string} dotType - 'source' or 'target'
     * @param {number} taskId - Task ID
     * @param {number} relatedTaskId - Parent or child ID
     * @param {boolean} isHovered - Is mouse hovering over this dot?
     * @param {boolean} isDragging - Is this dot being dragged?
     * @param {boolean} hasCustomPosition - True if arrow has custom position (blue), false if default (green)
     * @returns {SVGCircleElement} The dot element
     */
    renderArrowDot(x, y, dotType, taskId, relatedTaskId, isHovered, isDragging, hasCustomPosition) {
        // DEFENSIVE: Validate coordinates
        if (!isFinite(x) || !isFinite(y)) {
            console.warn('[renderArrowDot] Invalid coordinates:', { x, y });
            return null;
        }

        const dot = document.createElementNS('http://www.w3.org/2000/svg', 'circle');

        // Determine size based on state
        let size = this.arrowDotSize || 10;
        if (isDragging) {
            size = this.arrowDotDragSize || 14;
        } else if (isHovered) {
            size = this.arrowDotHoverSize || 12;
        }

        // Color: Green if at default position, Blue if customized
        const fillColor = hasCustomPosition ? '#2196f3' : '#4caf50';  // Blue = custom, Green = default

        // Position and styling
        dot.setAttribute('cx', x);
        dot.setAttribute('cy', y);
        dot.setAttribute('r', size);
        dot.setAttribute('fill', fillColor);
        dot.setAttribute('stroke', 'white');
        dot.setAttribute('stroke-width', '2');
        dot.setAttribute('filter', 'drop-shadow(0 2px 4px rgba(0,0,0,0.3))');
        dot.classList.add('arrow-dot');
        dot.setAttribute('data-dot-type', dotType);
        dot.setAttribute('data-task-id', taskId);
        dot.setAttribute('data-related-id', relatedTaskId);

        // Higher z-index
        dot.style.pointerEvents = 'all';
        dot.style.cursor = isDragging ? 'grabbing' : 'grab';

        return dot;
    },

    /**
     * Render snap indicators (8 positions: 4 corners + 4 midpoints)
     *
     * @param {number} rectX - Rectangle center X
     * @param {number} rectY - Rectangle center Y
     * @param {number} rectWidth - Rectangle width
     * @param {number} rectHeight - Rectangle height
     * @param {string} currentEdge - Current edge ('top', 'right', 'bottom', 'left')
     * @param {number} currentNormalized - Current normalized position (0-1)
     * @returns {Array<SVGCircleElement>} Array of snap indicator elements
     */
    renderSnapIndicators(rectX, rectY, rectWidth, rectHeight, currentEdge, currentNormalized) {
        // DEFENSIVE: Validate inputs
        if (!isFinite(rectX) || !isFinite(rectY) || !isFinite(rectWidth) || !isFinite(rectHeight)) {
            console.warn('[renderSnapIndicators] Invalid inputs:', { rectX, rectY, rectWidth, rectHeight });
            return [];
        }

        const indicators = [];
        const snapPositions = this.getSnapPositions(rectX, rectY, rectWidth, rectHeight);
        const threshold = this.arrowSnapThreshold || 3;

        snapPositions.forEach(snap => {
            const pos = this.denormalizeEdgePosition(snap.edge, snap.normalized, rectX, rectY, rectWidth, rectHeight);

            const indicator = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
            indicator.setAttribute('cx', pos.x);
            indicator.setAttribute('cy', pos.y);
            indicator.setAttribute('r', 6);

            // Check if this is the snap position we're near
            const isNearSnap = snap.edge === currentEdge &&
                Math.abs(snap.normalized - currentNormalized) * (snap.edge === 'top' || snap.edge === 'bottom' ? rectWidth : rectHeight) < threshold;

            if (isNearSnap) {
                indicator.setAttribute('fill', '#4caf50');  // Green
                indicator.setAttribute('stroke', '#2e7d32');
            } else {
                indicator.setAttribute('fill', '#9e9e9e');  // Gray
                indicator.setAttribute('stroke', '#757575');
            }

            indicator.setAttribute('stroke-width', '1');
            indicator.classList.add('snap-indicator');
            indicator.style.pointerEvents = 'none';

            indicators.push(indicator);
        });

        return indicators;
    }
});



// ============================================================
// RENDERING/RENDER.JS (Order: 24, Category: rendering)
// ============================================================

/**
 * @module rendering/render
 * @order 24
 * @category rendering
 *
 * Main render orchestrator - renders all tasks, links, and UI elements
 *
 * IMPORTANT: This file was RE-EXTRACTED from the original monolithic task-tree.html
 * to fix missing features (multiline text, proper positioning, etc.)
 * Date: 2025-11-01
 */

Object.assign(app, {
    /**
     * PERF: Invalidate cached dimensions when task changes
     * Call this when task title is edited
     */
    invalidateDimensionCache(taskId) {
        const task = this.tasks.find(t => t.id === taskId);
        if (task) {
            delete task._cachedDims;
        }
    },

    /**
     * PERF: Invalidate all dimension caches
     * Call this after bulk operations
     */
    invalidateAllDimensionCaches() {
        this.tasks.forEach(task => {
            delete task._cachedDims;
        });
    },

    /**
     * PERF: Viewport culling - check if task is visible in current viewport
     * Adds margin for smooth scrolling
     */
    isTaskVisible(task, viewportBounds) {
        if (!task || task.hidden) return false;

        // Get task dimensions (cached if possible)
        const dims = task._cachedDims || this.calculateTaskDimensions(task);
        if (!task._cachedDims) task._cachedDims = dims;

        const halfWidth = dims.width / 2;
        const halfHeight = dims.height / 2;

        // Check if task rectangle intersects viewport (with margin)
        return !(task.x + halfWidth < viewportBounds.left ||
                 task.x - halfWidth > viewportBounds.right ||
                 task.y + halfHeight < viewportBounds.top ||
                 task.y - halfHeight > viewportBounds.bottom);
    },

    render() {
        const svg = document.getElementById('canvas');
        const linksGroup = document.getElementById('links');
        const nodesGroup = document.getElementById('nodes');

        linksGroup.innerHTML = '';
        nodesGroup.innerHTML = '';

        // Apply zoom via viewBox
        const viewBoxWidth = this.viewBox.width / this.zoomLevel;
        const viewBoxHeight = this.viewBox.height / this.zoomLevel;
        const viewBoxX = this.viewBox.x - (viewBoxWidth - this.viewBox.width) / 2;
        const viewBoxY = this.viewBox.y - (viewBoxHeight - this.viewBox.height) / 2;

        svg.setAttribute('viewBox',
            `${viewBoxX} ${viewBoxY} ${viewBoxWidth} ${viewBoxHeight}`
        );

        // Render grid (if enabled)
        this.renderGrid();

        // PERF: Calculate visible viewport bounds for culling
        // Add margin so tasks smoothly appear when scrolling (increased for smoother experience)
        const VIEWPORT_MARGIN = 1000;
        const viewportBounds = {
            left: viewBoxX - VIEWPORT_MARGIN,
            right: viewBoxX + viewBoxWidth + VIEWPORT_MARGIN,
            top: viewBoxY - VIEWPORT_MARGIN,
            bottom: viewBoxY + viewBoxHeight + VIEWPORT_MARGIN
        };

        // PERF: Filter to only visible tasks (massive performance gain!)
        const visibleTasks = this.tasks.filter(task =>
            !task.hidden && this.isTaskVisible(task, viewportBounds)
        );
        const visibleTaskIds = new Set(visibleTasks.map(t => t.id));

        // Trigger background loading for uncached images (non-blocking)
        // Track loading images to prevent duplicate requests
        if (!this._loadingImages) this._loadingImages = new Set();

        visibleTasks.forEach(task => {
            if (task.imageId && !this.imageCache.has(task.imageId) && !this._loadingImages.has(task.imageId)) {
                // Mark as loading to prevent duplicate requests
                this._loadingImages.add(task.imageId);

                // Image not cached - trigger async load in background
                this.getImage(task.imageId).then(() => {
                    this._loadingImages.delete(task.imageId);
                    // Re-render once when image loads to show it
                    requestAnimationFrame(() => this.render());
                }).catch(err => {
                    this._loadingImages.delete(task.imageId);
                    console.warn(`Failed to load image ${task.imageId}:`, err);
                });
            }
        });

        // Find ALL working tasks (one per root graph) using the log for O(1) lookup
        const workingTasks = [];
        Object.values(this.workingTasksByRoot).forEach(taskId => {
            const task = this.tasks.find(t => t.id === taskId);
            if (task) {
                workingTasks.push(task);
            }
        });
        const workingTask = workingTasks[0]; // For status bar display, use first working task

        // Build combined lists for all working tasks
        const workingAncestors = [];
        const incompleteChildren = [];

        workingTasks.forEach(wt => {
            // Add ancestors of this working task
            const ancestors = this.getAncestors(wt.id);
            ancestors.forEach(id => {
                if (!workingAncestors.includes(id)) {
                    workingAncestors.push(id);
                }
            });

            // Add incomplete children of this working task
            wt.children.forEach(childId => {
                const child = this.tasks.find(t => t.id === childId);
                if (child && child.status !== 'done' && !incompleteChildren.includes(childId)) {
                    incompleteChildren.push(childId);
                }
            });
        });

        // Get golden paths for ALL working tasks (multi-project support)
        const allAncestorPaths = new Set();
        const allDirectChildren = [];
        const workingTaskIds = new Set();

        workingTasks.forEach(wt => {
            workingTaskIds.add(wt.id);

            // Build ancestor path for this working task
            allAncestorPaths.add(wt.id);  // Include working task itself
            let current = wt.mainParent;
            while (current !== null) {
                allAncestorPaths.add(current);
                const parent = this.tasks.find(t => t.id === current);
                current = parent ? parent.mainParent : null;
            }

            // Collect direct children with completion status
            wt.children.forEach(childId => {
                const child = this.tasks.find(t => t.id === childId);
                allDirectChildren.push({
                    id: childId,
                    isDone: child ? child.status === 'done' : false,
                    parentWorkingId: wt.id
                });
            });
        });

        const goldenPath = {
            workingTaskIds,
            ancestorPath: allAncestorPaths,
            directChildren: allDirectChildren
        };

        // PERF: Render links - only for visible tasks
        visibleTasks.forEach(task => {
            // DEFENSIVE: Skip tasks with invalid coordinates
            if (!isFinite(task.x) || !isFinite(task.y)) {
                console.warn(`Task ${task.id} has invalid coordinates: (${task.x}, ${task.y}) - skipping render`);
                return;
            }

            // Main parent link with hit detection
            if (task.mainParent !== null) {
                const parent = this.tasks.find(t => t.id === task.mainParent);
                if (parent && !parent.hidden) {
                    // DIAGNOSTIC: Log if either task has NaN
                    if (!isFinite(parent.x) || !isFinite(parent.y)) {
                        console.error(`[RENDER] Parent task ${parent.id} ("${parent.title}") has NaN coords: (${parent.x}, ${parent.y})`);
                    }
                    if (!isFinite(task.x) || !isFinite(task.y)) {
                        console.error(`[RENDER] Child task ${task.id} ("${task.title}") has NaN coords: (${task.x}, ${task.y})`);
                    }

                    // Get curve control points (simple array of {x, y})
                    const controlPoints = task.curveControlPoints?.[task.mainParent];
                    const hasControlPoints = controlPoints && Array.isArray(controlPoints) && controlPoints.length > 0;

                    // Get arrow start point (source)
                    const arrowStart = this.getArrowEndpoint(parent, task, 'source');

                    // Get arrow endpoint (target)
                    const isDraggingThisArrow = this.arrowDotDrag.active &&
                                                 this.arrowDotDrag.taskId === task.id &&
                                                 this.arrowDotDrag.relatedTaskId === task.mainParent;

                    let arrowEnd;
                    if (isDraggingThisArrow) {
                        const dims = this.calculateTaskDimensions(task);
                        arrowEnd = this.denormalizeEdgePosition(
                            this.arrowDotDrag.edge,
                            this.arrowDotDrag.normalized,
                            task.x,
                            task.y,
                            dims.width,
                            dims.height
                        );
                    } else {
                        arrowEnd = this.getArrowEndpoint(parent, task, 'target');
                    }

                    // Determine control points to use (live drag, orthogonal, or saved)
                    const isDraggingThisCurve = this.curveDotDrag.active &&
                                                this.curveDotDrag.taskId === task.id &&
                                                this.curveDotDrag.parentId === task.mainParent;

                    let effectiveControlPoints;

                    // Get effective routing mode from PARENT (arrows go FROM parent TO children)
                    const taskRoutingMode = this.getEffectiveArrowRouting(parent);

                    if (taskRoutingMode === 'orthogonal') {
                        // Orthogonal routing: calculate waypoints
                        const parentDims = this.calculateTaskDimensions(parent);
                        const taskDims = this.calculateTaskDimensions(task);

                        const startEdge = this.getEdgeFromPoint(arrowStart.x, arrowStart.y, parent.x, parent.y, parentDims.width, parentDims.height);
                        const endEdge = this.getEdgeFromPoint(arrowEnd.x, arrowEnd.y, task.x, task.y, taskDims.width, taskDims.height);

                        const waypoints = this.calculateOrthogonalPath(
                            arrowStart.x, arrowStart.y, startEdge,
                            arrowEnd.x, arrowEnd.y, endEdge,
                            parent.x, parent.y, task.x, task.y
                        );

                        // Remove first and last points (they're the start/end positions)
                        effectiveControlPoints = waypoints.slice(1, -1);
                    } else if (isDraggingThisCurve) {
                        effectiveControlPoints = this.curveDotDrag.controlPoints;
                    } else {
                        effectiveControlPoints = controlPoints;
                    }

                    // Create hit line and visible line
                    const useStraightSegments = taskRoutingMode === 'orthogonal';
                    const hitLine = this.createMultiSegmentCurvedLine(
                        arrowStart.x, arrowStart.y,
                        arrowEnd.x, arrowEnd.y,
                        effectiveControlPoints,
                        'link parent-hit',
                        useStraightSegments,
                        this.orthogonalCornerRadius
                    );
                    hitLine.dataset.type = 'parent';
                    hitLine.dataset.taskId = task.id;
                    hitLine.dataset.parentId = task.mainParent;
                    hitLine.style.pointerEvents = 'stroke';
                    hitLine.style.cursor = 'pointer';
                    if (this.selectedLine && this.selectedLine.type === 'parent' &&
                        this.selectedLine.taskId === task.id && this.selectedLine.parentId === task.mainParent) {
                        hitLine.classList.add('selected');
                    }
                    linksGroup.appendChild(hitLine);

                    // Create visible line
                    const line = this.createMultiSegmentCurvedLine(
                        arrowStart.x, arrowStart.y,
                        arrowEnd.x, arrowEnd.y,
                        effectiveControlPoints,
                        'link parent-visible',
                        useStraightSegments,
                        this.orthogonalCornerRadius
                    );
                    line.style.pointerEvents = 'none';
                    // ‚≠ê NEW: Add data attributes so we can update during animation
                    line.dataset.type = 'parent';
                    line.dataset.taskId = task.id;
                    line.dataset.parentId = task.mainParent;

                    // Check if this link is part of the golden ancestor path
                    // Link should be golden if task is on the path (working task or any ancestor)
                    const isAncestorPath =
                        goldenPath.ancestorPath.has(task.id) &&
                        goldenPath.ancestorPath.has(task.mainParent);

                    // Check if this is a link to a direct child of ANY working task
                    const childInfo = goldenPath.directChildren.find(c => c.id === task.id);
                    const isDirectChild = childInfo && goldenPath.workingTaskIds.has(task.mainParent);

                    // Apply path styling
                    if (isAncestorPath) {
                        line.classList.add('golden-path-ancestor');
                        line.setAttribute('marker-end', 'url(#arrowhead-golden)');
                        line.style.stroke = '#f59e0b';  // Golden amber
                        line.style.strokeWidth = '3';
                        line.style.filter = 'drop-shadow(0 0 4px rgba(245, 158, 11, 0.6))';
                    } else if (isDirectChild) {
                        // Color based on completion status
                        if (childInfo.isDone) {
                            line.classList.add('golden-path-child-done');
                            line.setAttribute('marker-end', 'url(#arrowhead-green)');
                            line.style.stroke = '#4caf50';  // Green (same as done tasks)
                            line.style.strokeWidth = '2.5';
                        } else {
                            line.classList.add('golden-path-child-incomplete');
                            line.setAttribute('marker-end', 'url(#arrowhead-red)');
                            line.style.stroke = '#f44336';  // Red (same as incomplete children indicator)
                            line.style.strokeWidth = '2.5';
                        }
                    } else if (task.status === 'done') {
                        // Child is done - use green arrow
                        line.setAttribute('marker-end', 'url(#arrowhead-green)');
                        line.style.stroke = '#4caf50';  // Green
                    } else {
                        line.setAttribute('marker-end', 'url(#arrowhead)'); // Normal arrow
                    }

                    if (this.selectedLine && this.selectedLine.type === 'parent' &&
                        this.selectedLine.taskId === task.id && this.selectedLine.parentId === task.mainParent) {
                        line.classList.add('selected');
                    }
                    linksGroup.appendChild(line);
                }
            }

            // Other parent links with hit detection
            task.otherParents.forEach(parentId => {
                const parent = this.tasks.find(t => t.id === parentId);
                if (parent && !parent.hidden) {
                    // Get curve control points
                    const controlPoints = task.curveControlPoints?.[parentId];

                    // Get arrow start point (source)
                    const arrowStart = this.getArrowEndpoint(parent, task, 'source');

                    // Get arrow endpoint (target)
                    const isDraggingThisArrow = this.arrowDotDrag.active &&
                                                 this.arrowDotDrag.taskId === task.id &&
                                                 this.arrowDotDrag.relatedTaskId === parentId;

                    let arrowEnd;
                    if (isDraggingThisArrow) {
                        const dims = this.calculateTaskDimensions(task);
                        arrowEnd = this.denormalizeEdgePosition(
                            this.arrowDotDrag.edge,
                            this.arrowDotDrag.normalized,
                            task.x,
                            task.y,
                            dims.width,
                            dims.height
                        );
                    } else {
                        arrowEnd = this.getArrowEndpoint(parent, task, 'target');
                    }

                    // Determine control points to use (live drag, orthogonal, or saved)
                    const isDraggingThisCurve = this.curveDotDrag.active &&
                                                this.curveDotDrag.taskId === task.id &&
                                                this.curveDotDrag.parentId === parentId;

                    let effectiveControlPoints;

                    // Get effective routing mode from PARENT (arrows go FROM parent TO children)
                    const taskRoutingMode = this.getEffectiveArrowRouting(parent);

                    if (taskRoutingMode === 'orthogonal') {
                        // Orthogonal routing: calculate waypoints
                        const parentDims = this.calculateTaskDimensions(parent);
                        const taskDims = this.calculateTaskDimensions(task);

                        const startEdge = this.getEdgeFromPoint(arrowStart.x, arrowStart.y, parent.x, parent.y, parentDims.width, parentDims.height);
                        const endEdge = this.getEdgeFromPoint(arrowEnd.x, arrowEnd.y, task.x, task.y, taskDims.width, taskDims.height);

                        const waypoints = this.calculateOrthogonalPath(
                            arrowStart.x, arrowStart.y, startEdge,
                            arrowEnd.x, arrowEnd.y, endEdge,
                            parent.x, parent.y, task.x, task.y
                        );

                        // Remove first and last points (they're the start/end positions)
                        effectiveControlPoints = waypoints.slice(1, -1);
                    } else if (isDraggingThisCurve) {
                        effectiveControlPoints = this.curveDotDrag.controlPoints;
                    } else {
                        effectiveControlPoints = controlPoints;
                    }

                    // Create hit line
                    const useStraightSegments = taskRoutingMode === 'orthogonal';
                    const hitLine = this.createMultiSegmentCurvedLine(
                        arrowStart.x, arrowStart.y,
                        arrowEnd.x, arrowEnd.y,
                        effectiveControlPoints,
                        'link other-parent-hit',
                        useStraightSegments,
                        this.orthogonalCornerRadius
                    );
                    hitLine.dataset.type = 'parent';
                    hitLine.dataset.taskId = task.id;
                    hitLine.dataset.parentId = parentId;
                    hitLine.style.pointerEvents = 'stroke';
                    hitLine.style.cursor = 'pointer';
                    if (this.selectedLine && this.selectedLine.type === 'parent' &&
                        this.selectedLine.taskId === task.id && this.selectedLine.parentId === parentId) {
                        hitLine.classList.add('selected');
                    }
                    linksGroup.appendChild(hitLine);

                    // Create visible line
                    const line = this.createMultiSegmentCurvedLine(
                        arrowStart.x, arrowStart.y,
                        arrowEnd.x, arrowEnd.y,
                        effectiveControlPoints,
                        'link other-parent',
                        useStraightSegments,
                        this.orthogonalCornerRadius
                    );

                    // Color arrow based on task status
                    if (task.status === 'done') {
                        line.setAttribute('marker-end', 'url(#arrowhead-green)');
                        line.style.stroke = '#4caf50';  // Green
                    } else {
                        line.setAttribute('marker-end', 'url(#arrowhead)'); // Normal arrow
                    }

                    line.style.pointerEvents = 'none';
                    // ‚≠ê NEW: Add data attributes so we can update during animation
                    line.dataset.type = 'parent';
                    line.dataset.taskId = task.id;
                    line.dataset.parentId = parentId;
                    if (this.selectedLine && this.selectedLine.type === 'parent' &&
                        this.selectedLine.taskId === task.id && this.selectedLine.parentId === parentId) {
                        line.classList.add('selected');
                    }
                    linksGroup.appendChild(line);
                }
            });

            // Dependency links with better hit detection
            task.dependencies.forEach(depId => {
                const dep = this.tasks.find(t => t.id === depId);
                if (dep && !dep.hidden) {
                    // Create wider invisible line for easier clicking
                    const hitLine = this.createLine(dep.x, dep.y, task.x, task.y, 'link dependency-hit');
                    hitLine.dataset.type = 'dependency';
                    hitLine.dataset.from = task.id;
                    hitLine.dataset.to = depId;
                    hitLine.style.pointerEvents = 'stroke';
                    // Check if selected
                    if (this.selectedLine && this.selectedLine.type === 'dependency' &&
                        this.selectedLine.from === task.id && this.selectedLine.to === depId) {
                        hitLine.classList.add('selected');
                    }
                    linksGroup.appendChild(hitLine);

                    // Create visible line (non-interactive) with arrow at edge
                    // Calculate arrow endpoint at rectangle edge for pixel-perfect positioning
                    // Use dynamic dimensions to account for multiline nodes
                    const { width: rectWidth, height: rectHeight } = this.calculateTaskDimensions(task);
                    const arrowEnd = this.getLineEndAtRectEdge(dep.x, dep.y, task.x, task.y, rectWidth, rectHeight);

                    const line = this.createLine(dep.x, dep.y, arrowEnd.x, arrowEnd.y, 'link dependency');
                    line.setAttribute('marker-end', 'url(#arrowhead)');
                    // Make visible line NOT clickable - all interaction through hitLine
                    line.style.pointerEvents = 'none';
                    // ‚≠ê NEW: Add data attributes (using visual direction: dep ‚Üí task)
                    line.dataset.type = 'dependency';
                    line.dataset.from = depId;  // Source (prerequisite)
                    line.dataset.to = task.id;  // Target (dependent)
                    // Check if selected
                    if (this.selectedLine && this.selectedLine.type === 'dependency' &&
                        this.selectedLine.from === task.id && this.selectedLine.to === depId) {
                        line.classList.add('selected');
                    }
                    linksGroup.appendChild(line);
                }
            });
        });

        // ========================================
        // Prioritize golden path and selected lines (render on top)
        // ========================================
        // Re-append golden path and selected lines to move them to the top of z-order
        const goldenPathLines = linksGroup.querySelectorAll('.golden-path-ancestor, .golden-path-child-done, .golden-path-child-incomplete');
        const selectedLines = linksGroup.querySelectorAll('.selected');

        // Re-append golden path lines (moves them to end = top of z-order)
        goldenPathLines.forEach(line => linksGroup.appendChild(line));

        // Re-append selected lines last (so they're on top of everything including golden path)
        selectedLines.forEach(line => linksGroup.appendChild(line));

        // PERF: Render nodes - only for visible tasks
        visibleTasks.forEach(task => {
            // DEFENSIVE: Skip tasks with invalid coordinates
            if (!isFinite(task.x) || !isFinite(task.y)) {
                console.warn(`Task ${task.id} ("${task.title}") has invalid coordinates - skipping node render`);
                return;
            }

            const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');
            g.classList.add('task-node');
            g.dataset.id = task.id;

            // ‚≠ê NEW: Position group with transform (GPU-accelerated, animatable!)
            g.setAttribute('transform', `translate(${task.x}, ${task.y})`);

            if (task.status === 'done') g.classList.add('done');
            if (task.status === 'in_progress') g.classList.add('in-progress');
            if (task.currentlyWorking) g.classList.add('working');
            if (this.suggestedNextTaskId === task.id) g.classList.add('suggested-next');
            if (workingAncestors.includes(task.id)) g.classList.add('parent-of-working');
            if (incompleteChildren.includes(task.id)) g.classList.add('incomplete-child-of-working');
            if (task.hidden) g.classList.add('hidden');
            if (this.selectedTaskIds.has(task.id)) g.classList.add('selected');

            // Add visual indicator for "tied" nodes (with custom attachments) while dragging
            const hasCustomAttachments = (task.customAttachPoints && Object.keys(task.customAttachPoints).length > 0) ||
                                         (task.customSourcePoints && Object.keys(task.customSourcePoints).length > 0);
            if (this.dragMode === 'node' && this.selectedNode === task.id && hasCustomAttachments) {
                g.classList.add('tied');
            }

            // Determine display text (truncated or full)
            const isLongText = task.title.length > this.textLengthThreshold;
            const charsOverLimit = task.title.length - this.textLengthThreshold;
            // Only truncate if significantly over limit (5+ chars) and not expanded
            const shouldTruncate = charsOverLimit > 5;
            const shouldExpand = task.currentlyWorking || task.textLocked || (task.textExpanded && this.selectedTaskIds.has(task.id));
            let displayTitle = task.title;
            let isTruncated = false;

            if (shouldTruncate && !shouldExpand) {
                // Normal truncation
                displayTitle = task.title.substring(0, this.textLengthThreshold) + '...';
                isTruncated = true;
            }

            // Calculate rect dimensions
            let rectWidth, rectHeight, lines;
            const verticalPadding = 10; // Used for both image and text nodes
            let isOverflowing = false; // Used in text rendering later
            let actualRenderedLines = 0; // Used in text rendering later
            const padding = this.nodePadding; // Used in text rendering later

            // For image nodes, size based on original image dimensions
            if (task.imageId && task.imageWidth && task.imageHeight) {
                const imagePadding = 20;
                rectWidth = task.imageWidth + imagePadding * 2;
                rectHeight = task.imageHeight + imagePadding * 2;
                lines = []; // No text lines for image nodes
            } else {
                // For text nodes, calculate based on text
                const charWidth = this.charWidth;
                const minWidth = this.minNodeWidth;
                // When multiline is enabled, always use full text for wrapping (maxNodeHeight handles limiting)
                // When multiline is disabled, use truncated displayTitle
                // When editing, always use full text
                const textForSizing = this.editingTaskId === task.id || this.enableMultiline ? task.title : displayTitle;

                // Wrap text into lines based on max width (subtract padding to ensure text fits within available space)
                const availableWidth = this.maxNodeWidth - padding * 2;
                lines = this.wrapText(textForSizing, availableWidth, charWidth, this.wordWrap);

                // Calculate width: minimum of (maxNodeWidth OR longest line width OR minWidth)
                const longestLineWidth = Math.max(...lines.map(line => line.length * charWidth + padding * 2));
                rectWidth = Math.max(minWidth, Math.min(this.maxNodeWidth, longestLineWidth));

                // Calculate height: lines * lineHeight + vertical padding
                const calculatedHeight = lines.length * this.lineHeight + verticalPadding * 2;

                // Determine if we should bypass maxNodeHeight and show full text
                // - When editing: show all lines for easier editing
                // - When selected: show all lines so user can see full text and use lock button
                // - When already expanded (currentlyWorking, textLocked, etc.): show all lines
                const shouldFullyExpand = this.editingTaskId === task.id || this.selectedTaskIds.has(task.id) || shouldExpand;

                // Check if text overflows BEFORE calculating rectHeight
                isOverflowing = this.maxNodeHeight > 0 && !shouldFullyExpand && calculatedHeight > this.maxNodeHeight;

                // Calculate how many lines will actually be rendered when overflowing
                actualRenderedLines = lines.length;
                if (isOverflowing) {
                    const availableHeightForOverflow = this.maxNodeHeight - verticalPadding * 2;
                    actualRenderedLines = Math.floor(availableHeightForOverflow / this.lineHeight);
                }

                // Size rectangle based on actual rendered content (not blindly using maxNodeHeight)
                rectHeight = (this.maxNodeHeight > 0 && !shouldFullyExpand)
                    ? actualRenderedLines * this.lineHeight + verticalPadding * 2
                    : calculatedHeight;
            }

            // ‚≠ê NEW: Rect positioned RELATIVE to group (centered at 0,0)
            const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
            rect.setAttribute('x', -rectWidth / 2);
            rect.setAttribute('y', -rectHeight / 2);
            rect.setAttribute('width', rectWidth);
            rect.setAttribute('height', rectHeight);

            // Set fill based on priority with diagonal stripe patterns
            // Use inline style to override CSS rules
            if (task.priority === 'high') {
                rect.style.fill = this.darkMode ? 'url(#priority-high-dark)' : 'url(#priority-high-light)';
            } else if (task.priority === 'medium') {
                rect.style.fill = this.darkMode ? 'url(#priority-medium-dark)' : 'url(#priority-medium-light)';
            }
            // For normal priority, let CSS handle it (no inline style needed)

            g.appendChild(rect);

            // Render image if task has one
            if (task.imageId) {
                this.renderTaskImage(g, task, rectWidth, rectHeight);
            }

            // Add link badge if task has links
            if (task.links && task.links.length > 0) {
                const badgeGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
                badgeGroup.classList.add('link-badge');

                // Position badge at top-right corner INSIDE the node bounds
                const badgeWidth = 20;  // Fixed width for just the emoji
                const badgeHeight = 14;
                const badgeX = rectWidth / 2 - badgeWidth - 1;  // 1px margin from right edge
                const badgeY = -rectHeight / 2 + 3;              // 3px margin from top edge

                // Invisible clickable area behind the emoji
                const clickArea = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                clickArea.setAttribute('x', badgeX);
                clickArea.setAttribute('y', badgeY);
                clickArea.setAttribute('width', badgeWidth);
                clickArea.setAttribute('height', badgeHeight);
                clickArea.setAttribute('fill', 'none');
                clickArea.setAttribute('opacity', '0');
                clickArea.style.cursor = 'pointer';
                clickArea.style.pointerEvents = 'all';
                badgeGroup.appendChild(clickArea);

                // Badge text (just emoji, no visible background or count)
                const badgeText = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                badgeText.setAttribute('x', badgeX + badgeWidth / 2);
                badgeText.setAttribute('y', badgeY + 12);  // 2px lower for better visual alignment
                badgeText.setAttribute('fill', '#2196f3');  // Blue color for link
                badgeText.setAttribute('font-size', '12');  // Slightly larger since no background
                badgeText.setAttribute('text-anchor', 'middle');
                badgeText.setAttribute('pointer-events', 'none');  // Let clicks pass through to clickArea
                badgeText.setAttribute('filter', 'drop-shadow(0 1px 2px rgba(0,0,0,0.2))');
                badgeText.textContent = 'üîó';
                badgeGroup.appendChild(badgeText);

                // Tooltip showing all links
                const title = document.createElementNS('http://www.w3.org/2000/svg', 'title');
                const linkList = task.links.map(url => '‚Ä¢ ' + this.shortenURL(url)).join('\n');
                title.textContent = `Links (${task.links.length}):\n${linkList}`;
                badgeGroup.appendChild(title);

                // Make badge clickable
                badgeGroup.style.cursor = 'pointer';
                badgeGroup.style.pointerEvents = 'all';

                badgeGroup.onclick = (evt) => {
                    evt.stopPropagation();
                    evt.preventDefault();

                    if (task.links.length === 1) {
                        // Single link - open directly
                        this.openLink(task.links[0]);
                    } else {
                        // Multiple links - show dropdown menu at badge location
                        const rect = clickArea.getBoundingClientRect();
                        this.showLinksDropdown(task.id, rect.left, rect.bottom);
                    }
                };

                g.appendChild(badgeGroup);
            }

            // Show input if editing, otherwise show text
            if (this.editingTaskId === task.id) {
                const foreignObject = document.createElementNS('http://www.w3.org/2000/svg', 'foreignObject');
                // Cover full rectangle width for better editing experience
                foreignObject.setAttribute('x', -rectWidth / 2);
                foreignObject.setAttribute('y', -rectHeight / 2 + 5);
                foreignObject.setAttribute('width', rectWidth);
                foreignObject.setAttribute('height', rectHeight - 10);
                // Prevent clicks on editing container from bubbling
                foreignObject.onmousedown = (e) => e.stopPropagation();
                foreignObject.onclick = (e) => e.stopPropagation();

                const textarea = document.createElement('textarea');
                textarea.id = 'edit-input';
                textarea.value = task.title;
                textarea.rows = Math.max(2, lines.length); // Dynamic rows based on content
                textarea.style.cssText = `width: 100%; max-width: none; height: 100%; border: 2px solid #007bff; border-radius: 4px; padding: 4px 8px; font-size: 14px; font-family: ${this.fontFamily}; text-align: left; box-sizing: border-box; resize: none; overflow: auto;`;
                textarea.onkeydown = (e) => {
                    if (e.key === 'Enter' && !e.shiftKey) {
                        // Plain Enter = save and finish editing
                        this.finishEditing(true);
                        e.preventDefault();
                    } else if (e.key === 'Escape') {
                        // Escape = cancel editing
                        this.finishEditing(false);
                        e.preventDefault();
                    }
                    // Shift+Enter creates newline (default textarea behavior when we don't preventDefault)
                    e.stopPropagation();
                };
                // Prevent clicks on textarea from bubbling to canvas handlers
                textarea.onmousedown = (e) => e.stopPropagation();
                textarea.onclick = (e) => e.stopPropagation();
                textarea.onblur = () => this.finishEditing(true);
                // Dynamically resize box as user types
                textarea.oninput = () => this.resizeEditingBox();

                foreignObject.appendChild(textarea);
                g.appendChild(foreignObject);
            } else {
                const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                text.setAttribute('x', 0);
                text.setAttribute('text-anchor', 'start'); // Left-aligned for multiline
                text.setAttribute('xml:space', 'preserve'); // Preserve all whitespace (tabs, spaces)
                text.style.cursor = 'pointer';
                text.style.fontFamily = this.fontFamily;
                text.style.fontWeight = this.fontWeight;

                // Calculate how many lines actually fit within rectHeight
                const availableHeight = rectHeight - verticalPadding * 2;
                const maxVisibleLines = Math.floor(availableHeight / this.lineHeight);
                // Render all visible lines (truncate last line if overflowing)
                const linesToRender = Math.min(lines.length, maxVisibleLines);

                // Render only the lines that fit within the rectangle
                for (let index = 0; index < linesToRender; index++) {
                    let lineText = lines[index];

                    // If this is the last visible line and text is overflowing, truncate it
                    if (isOverflowing && index === linesToRender - 1) {
                        // Truncate to make room for "..." (remove last 3 chars, add ellipsis)
                        lineText = lineText.length > 3 ? lineText.slice(0, -3) + '...' : lineText + '...';
                    }

                    // Parse markdown tokens from line
                    const tokens = this.parseMarkdown(lineText);
                    const yOffset = -rectHeight / 2 + verticalPadding + this.lineHeight * (index + 0.75);
                    const xStart = -rectWidth / 2 + padding; // Left edge + padding (horizontal)

                    // Render each token as a separate tspan with appropriate styling
                    for (let tokenIndex = 0; tokenIndex < tokens.length; tokenIndex++) {
                        const token = tokens[tokenIndex];
                        const tspan = document.createElementNS('http://www.w3.org/2000/svg', 'tspan');
                        tspan.setAttribute('xml:space', 'preserve'); // Preserve whitespace in this token

                        // Use createTextNode instead of textContent to preserve exact whitespace
                        const textNode = document.createTextNode(token.text);
                        tspan.appendChild(textNode);

                        // Position: first token uses x, subsequent tokens use dx=0
                        if (tokenIndex === 0) {
                            tspan.setAttribute('x', xStart);
                            tspan.setAttribute('y', yOffset);
                        } else {
                            tspan.setAttribute('dx', '0'); // Continue on same line
                        }

                        // Apply styling based on token format
                        if (token.format === 'bold') {
                            tspan.style.fontWeight = 'bold';
                        } else if (token.format === 'italic') {
                            tspan.style.fontStyle = 'italic';
                        } else if (token.format === 'code') {
                            tspan.style.fontFamily = "'Courier New', monospace";
                            tspan.style.fill = '#d63384'; // Pink/magenta for code
                        } else if (token.format === 'link') {
                            tspan.style.fill = '#0d6efd'; // Blue for links
                            tspan.style.textDecoration = 'underline';
                            tspan.style.cursor = 'pointer';
                            // Add click handler for link
                            tspan.addEventListener('click', (e) => {
                                e.stopPropagation(); // Don't trigger task selection
                                window.open(token.url, '_blank');
                            });
                        }
                        // 'normal' format gets default styling

                        text.appendChild(tspan);
                    }
                }

                // Add status emoji indicator positioned to the left of the node
                if (task.currentlyWorking || task.status === 'done') {
                    const statusEmoji = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                    statusEmoji.textContent = task.currentlyWorking ? 'üîÑ' : '‚úÖ';
                    // Position to the left of the rectangle
                    statusEmoji.setAttribute('x', -rectWidth / 2 - 20); // 20px left of node edge
                    statusEmoji.setAttribute('y', 0); // Vertically centered
                    statusEmoji.setAttribute('font-size', '16');
                    statusEmoji.setAttribute('text-anchor', 'middle');
                    statusEmoji.setAttribute('dominant-baseline', 'middle');
                    statusEmoji.setAttribute('pointer-events', 'none'); // Don't interfere with node clicks
                    statusEmoji.style.opacity = '0.63'; // More transparent to be subtle
                    g.appendChild(statusEmoji);
                }


                // Add dblclick handler directly to text element
                text.addEventListener('dblclick', (e) => {
                    if (this.editingTaskId === null) {
                        if (e.shiftKey) {
                            // Shift+double click: hide/show the node itself within its parent
                            this.toggleHiddenSelf(task.id);
                        } else {
                            // Normal double click: edit task name
                            this.startEditing(task.id);
                        }
                        e.preventDefault();
                        e.stopPropagation();
                    }
                });
                g.appendChild(text);
            }

            // Add lock button for expanded text (only if long text and expanded)
            if (isLongText && shouldExpand) {
                const lockSize = 16;
                // ‚≠ê NEW: Relative to group center
                const lockX = -rectWidth / 2 - 20;  // 20px to the left of box
                const lockY = 0;  // Vertically centered on node

                // Create a group for the lock button
                const lockGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
                lockGroup.classList.add('lock-button');
                lockGroup.style.cursor = task.currentlyWorking ? 'not-allowed' : 'pointer';
                lockGroup.onclick = (e) => {
                    e.stopPropagation();
                    if (!task.currentlyWorking) {
                        this.toggleTextLock(task.id);
                    }
                };

                // Background circle for visibility
                const lockBg = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                lockBg.setAttribute('cx', lockX);
                lockBg.setAttribute('cy', lockY);
                lockBg.setAttribute('r', 14);
                lockBg.setAttribute('fill', this.darkMode ? 'rgba(45, 55, 72, 0.9)' : 'rgba(255, 255, 255, 0.9)');
                lockBg.setAttribute('stroke', this.darkMode ? '#4a5568' : '#ccc');
                lockBg.setAttribute('stroke-width', '1');
                lockGroup.appendChild(lockBg);

                // Lock icon (emoji)
                const lockText = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                lockText.setAttribute('x', lockX);
                lockText.setAttribute('y', lockY);
                lockText.setAttribute('font-size', lockSize);
                lockText.setAttribute('text-anchor', 'middle');
                lockText.setAttribute('dominant-baseline', 'middle');
                lockText.textContent = task.textLocked ? 'üîí' : 'üîì';
                lockText.style.opacity = task.currentlyWorking ? '0.4' : '1';
                lockGroup.appendChild(lockText);

                g.appendChild(lockGroup);
            }

            // Add priority badge (colored dot in top-left corner)
            if (task.priority && task.priority !== 'normal') {
                const dotRadius = 6;
                const dotX = -rectWidth / 2 + dotRadius + 3;  // 3px from left edge
                const dotY = -rectHeight / 2 + dotRadius + 3;  // 3px from top edge

                const priorityDot = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                priorityDot.setAttribute('cx', dotX);
                priorityDot.setAttribute('cy', dotY);
                priorityDot.setAttribute('r', dotRadius);
                priorityDot.setAttribute('fill', task.priority === 'high' ? '#f44336' : '#ff9800');  // Red for high, Orange for medium
                priorityDot.setAttribute('stroke', this.darkMode ? 'rgba(0, 0, 0, 0.3)' : 'rgba(255, 255, 255, 0.8)');
                priorityDot.setAttribute('stroke-width', '1.5');
                priorityDot.style.filter = 'drop-shadow(0 1px 2px rgba(0, 0, 0, 0.3))';

                g.appendChild(priorityDot);
            }

            // Add time tracking badge (bottom-right corner)
            if (task.timeTracking && task.timeTracking.totalSeconds > 0) {
                const timeText = this.formatDurationCompact(task.timeTracking.totalSeconds);
                const badgeText = `‚è±Ô∏è ${timeText}`;

                // Position in bottom-right corner (text only, no background)
                const badgeX = rectWidth / 2 - 5;  // Right edge with small margin
                const badgeY = rectHeight / 2 - 5;  // Bottom edge with small margin

                // Badge text only (no background rectangle)
                const badgeLabel = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                badgeLabel.setAttribute('x', badgeX);
                badgeLabel.setAttribute('y', badgeY);
                badgeLabel.setAttribute('text-anchor', 'end');  // Align right
                badgeLabel.setAttribute('dominant-baseline', 'baseline');
                badgeLabel.setAttribute('font-size', '9');
                badgeLabel.setAttribute('font-weight', '400');
                badgeLabel.setAttribute('fill', this.darkMode ? '#999' : '#888');
                badgeLabel.setAttribute('opacity', '0.8');
                badgeLabel.classList.add('time-badge');
                badgeLabel.textContent = badgeText;

                g.appendChild(badgeLabel);
            }

            // Add hidden children indicator badge
            const hiddenCount = this.getHiddenChildrenCount(task.id);
            if (hiddenCount > 0) {
                const badgeRadius = 12;
                // ‚≠ê NEW: Relative to group center
                const badgeX = rectWidth / 2 - 5;
                const badgeY = -rectHeight / 2 - 5;

                // Create a group for the badge
                const badgeGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
                badgeGroup.style.cursor = 'pointer';
                badgeGroup.onclick = (e) => {
                    e.stopPropagation();
                    this.toggleHidden(task.id);
                };

                // Badge circle
                const badgeCircle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                badgeCircle.setAttribute('cx', badgeX);
                badgeCircle.setAttribute('cy', badgeY);
                badgeCircle.setAttribute('r', badgeRadius);
                badgeCircle.classList.add('hidden-indicator');
                badgeGroup.appendChild(badgeCircle);

                // Badge text
                const badgeText = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                badgeText.setAttribute('x', badgeX);
                badgeText.setAttribute('y', badgeY);
                badgeText.textContent = `+${hiddenCount}`;
                badgeText.classList.add('hidden-indicator-text');
                badgeGroup.appendChild(badgeText);

                g.appendChild(badgeGroup);
            }

            // Add general click handler on node for selection
            g.style.cursor = 'pointer';
            g.addEventListener('click', (e) => {
                // Don't handle clicks on interactive elements
                if (e.target.closest('.lock-button') ||
                    e.target.closest('.hidden-indicator') ||
                    e.target.closest('.link-badge')) {
                    return;
                }

                // Don't interfere with Ctrl+click (multi-select), Alt+click (delete), or Shift+click (reserved)
                // Let the main canvas click handler handle those
                if (e.ctrlKey || e.metaKey || e.altKey || e.shiftKey) {
                    return;
                }

                // Select the node (this updates lastWorkingTaskId if task is working)
                this.selectNode(task.id);

                // Also expand text if truncated
                if (isLongText && !shouldExpand) {
                    this.expandText(task.id);
                }
            });

            // Track hover for priority changes with P key
            g.addEventListener('mouseenter', () => {
                this.hoveredTaskId = task.id;
            });
            g.addEventListener('mouseleave', () => {
                this.hoveredTaskId = null;
            });

            nodesGroup.appendChild(g);
        });

        // ========================================
        // Arrow Snap Points - Render dots and snap indicators
        // ========================================
        if (this.hoveredArrowDot || this.arrowDotDrag.active) {
            // Determine which dot to render
            let dotToRender = this.arrowDotDrag.active ? {
                type: this.arrowDotDrag.dotType,
                taskId: this.arrowDotDrag.taskId,
                parentId: this.arrowDotDrag.relatedTaskId,
                childId: this.arrowDotDrag.relatedChildId
            } : this.hoveredArrowDot;

            if (dotToRender) {
                const isSourceDot = dotToRender.type === 'source';

                // For source dots: taskId is parent, childId is child
                // For target dots: taskId is child, parentId is parent
                const dotOwner = this.tasks.find(t => t.id === dotToRender.taskId);
                const relatedTask = isSourceDot ?
                    this.tasks.find(t => t.id === dotToRender.childId) :
                    this.tasks.find(t => t.id === dotToRender.parentId);

                if (dotOwner && relatedTask) {
                    // Get dot position
                    let dotPos;
                    if (this.arrowDotDrag.active) {
                        // During drag: use LIVE drag position
                        const dims = this.calculateTaskDimensions(dotOwner);
                        dotPos = this.denormalizeEdgePosition(
                            this.arrowDotDrag.edge,
                            this.arrowDotDrag.normalized,
                            dotOwner.x,
                            dotOwner.y,
                            dims.width,
                            dims.height
                        );
                    } else {
                        // When hovering: use saved or default position
                        if (isSourceDot) {
                            // Source dot on parent node
                            dotPos = this.getArrowEndpoint(dotOwner, relatedTask, 'source');
                        } else {
                            // Target dot on child node
                            dotPos = this.getArrowEndpoint(relatedTask, dotOwner, 'target');
                        }
                    }

                    // Check if this arrow has a custom position (for coloring)
                    const hasCustomPosition = isSourceDot ?
                        !!(dotOwner.customSourcePoints && dotOwner.customSourcePoints[dotToRender.childId]) :
                        !!(dotOwner.customAttachPoints && dotOwner.customAttachPoints[dotToRender.parentId]);

                    // Render the arrow dot
                    const relatedId = isSourceDot ? dotToRender.childId : dotToRender.parentId;
                    const dot = this.renderArrowDot(
                        dotPos.x, dotPos.y,
                        dotToRender.type,
                        dotToRender.taskId,
                        relatedId,
                        this.hoveredArrowDot !== null,
                        this.arrowDotDrag.active,
                        hasCustomPosition
                    );

                    if (dot) {
                        // Append to nodesGroup so it renders OVER nodes
                        nodesGroup.appendChild(dot);
                    }

                    // Render snap indicators if dragging
                    if (this.arrowDotDrag.active) {
                        const dims = this.calculateTaskDimensions(dotOwner);
                        const indicators = this.renderSnapIndicators(
                            dotOwner.x, dotOwner.y,
                            dims.width, dims.height,
                            this.arrowDotDrag.edge,
                            this.arrowDotDrag.normalized
                        );

                        indicators.forEach(indicator => {
                            // Append to nodesGroup so it renders OVER nodes
                            nodesGroup.appendChild(indicator);
                        });
                    }
                }
            }
        }

        // ========================================
        // Curve Control Points - Miro-style dots
        // ========================================
        if (this.hoveredCurveDot || this.curveDotDrag.active) {
            let dotsToRender = [];
            let taskId, parentId;

            if (this.curveDotDrag.active) {
                // During drag: show all control points being edited
                taskId = this.curveDotDrag.taskId;
                parentId = this.curveDotDrag.parentId;
                const controlPoints = this.curveDotDrag.controlPoints || [];
                dotsToRender = controlPoints.map((cp, idx) => ({
                    x: cp.x,
                    y: cp.y,
                    index: idx,
                    isBeingDragged: idx === this.curveDotDrag.editingIndex,
                    isExisting: true
                }));
            } else if (this.hoveredCurveDot) {
                // Hovering: show all existing control points + potential new point
                taskId = this.hoveredCurveDot.taskId;
                parentId = this.hoveredCurveDot.parentId;
                const { controlPoints, nearestPointIndex, addNewPoint, mouseX, mouseY } = this.hoveredCurveDot;

                // Add existing control points
                if (controlPoints && Array.isArray(controlPoints)) {
                    dotsToRender = controlPoints.map((cp, idx) => ({
                        x: cp.x,
                        y: cp.y,
                        index: idx,
                        isHovered: idx === nearestPointIndex,
                        isExisting: true
                    }));
                }

                // Add potential new point (gray preview)
                if (addNewPoint) {
                    dotsToRender.push({
                        x: mouseX,
                        y: mouseY,
                        index: -1,
                        isHovered: true,
                        isExisting: false
                    });
                }
            }

            // Render all dots
            for (const dotInfo of dotsToRender) {
                // Size
                let size = 5;
                if (dotInfo.isBeingDragged) {
                    size = 8;
                } else if (dotInfo.isHovered) {
                    size = 6;
                }

                // Color
                let fillColor = '#9e9e9e';  // Gray default
                if (dotInfo.isBeingDragged) {
                    fillColor = '#2196f3';  // Blue when dragging
                } else if (dotInfo.isExisting) {
                    fillColor = '#9c27b0';  // Purple for existing points
                }

                // Render dot
                const dot = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                dot.setAttribute('cx', dotInfo.x);
                dot.setAttribute('cy', dotInfo.y);
                dot.setAttribute('r', size);
                dot.setAttribute('fill', fillColor);
                dot.setAttribute('stroke', 'white');
                dot.setAttribute('stroke-width', '2');
                dot.setAttribute('filter', 'drop-shadow(0 2px 4px rgba(0,0,0,0.3))');
                dot.classList.add('curve-dot');
                dot.style.pointerEvents = 'all';
                dot.style.cursor = this.curveDotDrag.active ? 'grabbing' : 'grab';

                // Add data attributes for double-click reset handler
                dot.setAttribute('data-link-type', 'parent');
                dot.setAttribute('data-task-id', taskId);
                dot.setAttribute('data-related-id', parentId);
                dot.setAttribute('data-point-index', dotInfo.index); // Which control point this is

                nodesGroup.appendChild(dot);
            }
        }

        // ========================================
        // Alignment Snap Guide Lines
        // ========================================
        if (this.activeSnapLines && this.activeSnapLines.length > 0) {
            this.activeSnapLines.forEach(snapLine => {
                const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');

                if (snapLine.type === 'vertical') {
                    // Vertical snap line (spans entire viewport height)
                    line.setAttribute('x1', snapLine.position);
                    line.setAttribute('y1', this.viewBox.y);
                    line.setAttribute('x2', snapLine.position);
                    line.setAttribute('y2', this.viewBox.y + this.viewBox.height);
                } else if (snapLine.type === 'horizontal') {
                    // Horizontal snap line (spans entire viewport width)
                    line.setAttribute('x1', this.viewBox.x);
                    line.setAttribute('y1', snapLine.position);
                    line.setAttribute('x2', this.viewBox.x + this.viewBox.width);
                    line.setAttribute('y2', snapLine.position);
                }

                // Style: semi-transparent, dashed line
                // Use different colors for edge vs center alignment
                const isCenter = snapLine.alignType === 'center';
                line.setAttribute('stroke', isCenter ? '#ff6b6b' : '#4dabf7');
                line.setAttribute('stroke-width', '1.5');
                line.setAttribute('stroke-dasharray', '5,5');
                line.setAttribute('opacity', '0.6');
                line.setAttribute('pointer-events', 'none');

                nodesGroup.appendChild(line);
            });
        }

        // Render off-screen indicators for working tasks
        this.renderOffscreenIndicators();

        // Update FPS counter
        this.updateFpsCounter();
    },

    /**
     * Update FPS counter and lag detection
     * Called at the end of every render()
     */
    updateFpsCounter() {
        if (!this.showFpsCounter) {
            // Remove FPS counter if disabled
            const fpsElement = document.getElementById('fps-counter');
            if (fpsElement) {
                fpsElement.remove();
            }
            return;
        }

        const now = performance.now();

        // Calculate current FPS
        if (this.fpsLastFrameTime > 0) {
            const frameDuration = now - this.fpsLastFrameTime;
            this.fpsCurrentFps = frameDuration > 0 ? Math.round(1000 / frameDuration) : 0;
        }
        this.fpsLastFrameTime = now;

        // Track frame times for average FPS (last 1 second)
        this.fpsFrameTimes.push(now);

        // Remove frame times older than 1 second
        this.fpsFrameTimes = this.fpsFrameTimes.filter(time => now - time < 1000);

        // Calculate average FPS over last second
        if (this.fpsFrameTimes.length > 1) {
            const timeSpan = this.fpsFrameTimes[this.fpsFrameTimes.length - 1] - this.fpsFrameTimes[0];
            this.fpsAverageFps = timeSpan > 0 ? Math.round((this.fpsFrameTimes.length - 1) * 1000 / timeSpan) : 0;
        }

        // Create or update FPS counter overlay
        let fpsElement = document.getElementById('fps-counter');
        if (!fpsElement) {
            fpsElement = document.createElement('div');
            fpsElement.id = 'fps-counter';
            fpsElement.style.position = 'fixed';
            fpsElement.style.top = '10px';
            fpsElement.style.right = '10px';
            fpsElement.style.backgroundColor = 'rgba(0, 0, 0, 0.7)';
            fpsElement.style.color = '#fff';
            fpsElement.style.padding = '8px 12px';
            fpsElement.style.borderRadius = '4px';
            fpsElement.style.fontFamily = 'monospace';
            fpsElement.style.fontSize = '12px';
            fpsElement.style.zIndex = '10000';
            fpsElement.style.pointerEvents = 'none';
            fpsElement.style.userSelect = 'none';
            document.body.appendChild(fpsElement);
        }

        // Determine if lagging
        const isLagging = this.fpsAverageFps < this.fpsLagThreshold && this.fpsAverageFps > 0;

        // Update content
        const lagIndicator = isLagging ? ' ‚ö†Ô∏è LAG' : '';
        const fpsColor = isLagging ? '#ff5252' : '#4caf50';

        fpsElement.innerHTML = `
            <div style="display: flex; flex-direction: column; gap: 4px;">
                <div style="display: flex; justify-content: space-between; gap: 12px;">
                    <span>FPS:</span>
                    <span style="color: ${fpsColor}; font-weight: bold;">${this.fpsCurrentFps}</span>
                </div>
                <div style="display: flex; justify-content: space-between; gap: 12px;">
                    <span>Avg:</span>
                    <span style="color: ${fpsColor}; font-weight: bold;">${this.fpsAverageFps}</span>
                </div>
                ${isLagging ? '<div style="color: #ff5252; font-weight: bold; text-align: center; margin-top: 4px;">‚ö†Ô∏è LAG DETECTED</div>' : ''}
            </div>
        `;
    },

    /**
     * Render task image in SVG node
     * @param {SVGElement} g - Group element to append to
     * @param {Object} task - Task object with imageId
     * @param {number} rectWidth - Rectangle width
     * @param {number} rectHeight - Rectangle height
     */
    renderTaskImage(g, task, rectWidth, rectHeight) {
        try {
            // Get image blob URL from cache (already pre-loaded in render())
            const blobUrl = this.imageCache.get(task.imageId);

            if (!blobUrl) {
                console.warn(`[render.js] Image not in cache for task ${task.id}: ${task.imageId}`);
                return;
            }

            // Use original image dimensions (already stored in task)
            const imageWidth = task.imageWidth || 200;
            const imageHeight = task.imageHeight || 150;

            // Create SVG image element at original size
            const image = document.createElementNS('http://www.w3.org/2000/svg', 'image');
            image.setAttribute('x', -imageWidth / 2);
            image.setAttribute('y', -imageHeight / 2);
            image.setAttribute('width', imageWidth);
            image.setAttribute('height', imageHeight);
            image.setAttribute('href', blobUrl);
            image.setAttribute('preserveAspectRatio', 'xMidYMid meet');
            image.style.pointerEvents = 'none';  // Don't block mouse events

            g.appendChild(image);

            // Add resize handles for selected image nodes
            if (this.selectedTaskIds.has(task.id)) {
                this.addResizeHandles(g, task, imageWidth, imageHeight);
            }
        } catch (error) {
            console.error(`[render.js] Failed to render image for task ${task.id}:`, error);
        }
    },

    /**
     * Add resize handles to image node corners
     * @param {SVGElement} g - Group element
     * @param {Object} task - Task object
     * @param {number} imageWidth - Current image width
     * @param {number} imageHeight - Current image height
     */
    addResizeHandles(g, task, imageWidth, imageHeight) {
        const handleSize = 12;
        const handleOffset = 4;

        // Corner positions
        const corners = [
            { x: imageWidth / 2 + handleOffset, y: imageHeight / 2 + handleOffset, cursor: 'nwse-resize', corner: 'se' },  // SE
            { x: -imageWidth / 2 - handleOffset, y: imageHeight / 2 + handleOffset, cursor: 'nesw-resize', corner: 'sw' }, // SW
            { x: imageWidth / 2 + handleOffset, y: -imageHeight / 2 - handleOffset, cursor: 'nesw-resize', corner: 'ne' }, // NE
            { x: -imageWidth / 2 - handleOffset, y: -imageHeight / 2 - handleOffset, cursor: 'nwse-resize', corner: 'nw' }  // NW
        ];

        corners.forEach(({ x, y, cursor, corner }) => {
            const handle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
            handle.setAttribute('cx', x);
            handle.setAttribute('cy', y);
            handle.setAttribute('r', handleSize / 2);
            handle.setAttribute('fill', '#2196f3');
            handle.setAttribute('stroke', 'white');
            handle.setAttribute('stroke-width', '2');
            handle.style.cursor = cursor;
            handle.style.pointerEvents = 'all';
            handle.classList.add('resize-handle');
            handle.dataset.taskId = task.id;
            handle.dataset.corner = corner;

            g.appendChild(handle);
        });
    },
});



// ============================================================
// INTERACTIONS/MOUSE.JS (Order: 25, Category: interactions)
// ============================================================

/**
 * @module interactions/mouse
 * @order 25
 * @category interactions
 *
 * Mouse event handlers for canvas interactions
 */

Object.assign(app, {
    onCanvasMouseDown(e) {
        // Don't start drag if we're editing
        if (this.editingTaskId !== null) return;

        // Check if clicking on resize handle (highest priority)
        if (e.target.classList && e.target.classList.contains('resize-handle')) {
            const taskId = parseInt(e.target.dataset.taskId);
            const corner = e.target.dataset.corner;
            this.startImageResize(taskId, corner, e);
            e.preventDefault();
            e.stopPropagation();
            return;
        }

        // Check if clicking on arrow dot (high priority)
        if (e.target.classList && e.target.classList.contains('arrow-dot')) {
            const dotType = e.target.getAttribute('data-dot-type');
            const taskId = parseInt(e.target.getAttribute('data-task-id'));
            const relatedId = parseInt(e.target.getAttribute('data-related-id'));

            const now = performance.now();
            const dotId = `${taskId}-${relatedId}`;
            const timeSinceLastClick = now - this.arrowDotDrag.lastClickTime;

            // Check for double-click (< 300ms, same dot)
            if (timeSinceLastClick < 300 && this.arrowDotDrag.lastClickedDotId === dotId) {
                // This is a double-click - don't start drag, let dblclick handler process it
                this.arrowDotDrag.lastClickTime = 0;
                this.arrowDotDrag.lastClickedDotId = null;
                e.preventDefault();
                e.stopPropagation();
                return;
            }

            // Single click - track for future double-click detection
            this.arrowDotDrag.lastClickTime = now;
            this.arrowDotDrag.lastClickedDotId = dotId;

            // Start drag after short delay to allow double-click detection
            setTimeout(() => {
                // Only start drag if not double-clicked in the meantime
                if (this.arrowDotDrag.lastClickedDotId === dotId) {
                    // For source dots: taskId is parent, relatedId is child
                    // For target dots: taskId is child, relatedId is parent
                    const dotInfo = {
                        type: dotType,
                        taskId: taskId
                    };

                    if (dotType === 'source') {
                        dotInfo.childId = relatedId;
                    } else {
                        dotInfo.parentId = relatedId;
                    }

                    this.startArrowDotDrag(dotInfo);
                }
            }, 250);

            e.preventDefault();
            e.stopPropagation();
            return;
        }

        // Check if clicking on curve control dot (second priority)
        // Use hoveredCurveDot state (Miro-style proximity detection)
        // ONLY works when Ctrl is held
        if (e.target.classList && e.target.classList.contains('curve-dot') && this.hoveredCurveDot && (e.ctrlKey || e.metaKey)) {
            const now = performance.now();
            const dotId = `curve-${this.hoveredCurveDot.taskId}-${this.hoveredCurveDot.parentId}`;
            const timeSinceLastClick = now - this.curveDotDrag.lastClickTime;

            // Check for double-click (< 300ms, same dot)
            if (timeSinceLastClick < 300 && this.curveDotDrag.lastClickedDotId === dotId) {
                // This is a double-click - don't start drag, let dblclick handler process it
                this.curveDotDrag.lastClickTime = 0;
                this.curveDotDrag.lastClickedDotId = null;
                e.preventDefault();
                e.stopPropagation();
                return;
            }

            // Single click - track for future double-click detection
            this.curveDotDrag.lastClickTime = now;
            this.curveDotDrag.lastClickedDotId = dotId;

            // Start drag after short delay to allow double-click detection
            setTimeout(() => {
                // Only start drag if not double-clicked in the meantime
                if (this.curveDotDrag.lastClickedDotId === dotId) {
                    this.startCurveDotDrag(this.hoveredCurveDot);
                }
            }, 250);

            e.preventDefault();
            e.stopPropagation();
            return;
        }

        // Don't interfere with line clicks - let the click handler deal with them
        if (e.target.tagName === 'line' && e.target.classList.contains('link')) {
            return; // Exit early, allow click event to fire
        }

        if (e.target.closest('.task-node')) {
            const node = e.target.closest('.task-node');
            const taskId = parseInt(node.dataset.id);

            if (e.button === 0) { // Left click
                if (e.ctrlKey || e.metaKey || this.debugCtrlMode) {
                    // Prepare for potential reparent drag (will activate on mousemove >5px)
                    // If no drag occurs, click event will handle multi-select
                    this.dragMode = 'reparent-pending';
                    this.selectedNode = taskId;
                    const pt = this.getSVGPoint(e);
                    this.dragStart = { x: pt.x, y: pt.y };
                    this.dragStartOriginal = { x: pt.x, y: pt.y };
                } else if (e.altKey) {
                    // Start dependency drag
                    this.dragMode = 'dependency';
                    this.selectedNode = taskId;
                    this.createTempLine(e);
                    // Create custom cursor arrow
                    this.cursorArrow = this.createCursorArrow();
                    // Initialize line from source to cursor (A ‚Üí B drag direction)
                    const task = this.tasks.find(t => t.id === taskId);
                    if (task && this.tempLine) {
                        const pt = this.getSVGPoint(e);
                        this.tempLine.setAttribute('x1', task.x);
                        this.tempLine.setAttribute('y1', task.y);
                        this.tempLine.setAttribute('x2', pt.x);
                        this.tempLine.setAttribute('y2', pt.y);
                    }
                } else if (e.shiftKey) {
                    // Prepare for potential subtree drag (will activate on mousemove >5px)
                    this.dragMode = 'subtree-pending';
                    this.selectedNode = taskId;
                    const pt = this.getSVGPoint(e);
                    this.dragStart = { x: pt.x, y: pt.y };
                    this.dragStartOriginal = { x: pt.x, y: pt.y };
                } else {
                    // Start node drag
                    this.dragMode = 'node';
                    this.selectedNode = taskId;
                    const task = this.tasks.find(t => t.id === taskId);
                    const pt = this.getSVGPoint(e);
                    this.dragStart = { x: pt.x - task.x, y: pt.y - task.y };
                    this.dragOriginalPos = { x: task.x, y: task.y };

                    // Save snapshot BEFORE drag starts (captures original position)
                    if (this.selectedTaskIds.size > 1) {
                        this.saveSnapshot(`Move ${this.selectedTaskIds.size} tasks`);
                    } else {
                        const truncatedTitle = task.title.length > 30 ? task.title.substring(0, 27) + '...' : task.title;
                        this.saveSnapshot(`Move task '${truncatedTitle}'`);
                    }
                }
            }
            e.preventDefault();
            e.stopPropagation();
        } else {
            // Clicked on empty space
            if (e.button === 0 && (e.ctrlKey || e.metaKey || this.debugCtrlMode)) {
                // Ctrl+Drag on empty space: prepare for box selection (Windows standard)
                const pt = this.getSVGPoint(e);
                this.dragMode = 'box-select';
                this.boxSelectStart = { x: pt.x, y: pt.y };
                this.isBoxSelecting = true;
                e.preventDefault();
            } else {
                // Pan canvas - use screen coordinates (stable, unlike SVG coords which change with viewBox)
                this.dragMode = 'canvas';
                this.dragStart = { x: e.clientX, y: e.clientY };
                const pt = this.getSVGPoint(e);
                this.dragStartOriginal = { x: pt.x, y: pt.y }; // Track original for click detection (SVG coords)
                document.getElementById('canvas-container').classList.add('dragging');
                e.preventDefault();
            }
        }
    },

    onCanvasMouseMove(e) {
        // Always track mouse position for Ctrl+V paste at cursor
        const pt = this.getSVGPoint(e);
        this.lastMousePosition = { x: pt.x, y: pt.y };

        // Handle image resizing
        if (this.imageResizing) {
            const task = this.tasks.find(t => t.id === this.imageResizing.taskId);
            if (!task) return;

            const dx = pt.x - this.imageResizing.startPoint.x;
            const dy = pt.y - this.imageResizing.startPoint.y;

            // Calculate new dimensions based on corner
            let newWidth = this.imageResizing.originalWidth;
            let newHeight = this.imageResizing.originalHeight;

            switch (this.imageResizing.corner) {
                case 'se': // Southeast - drag right/down
                    newWidth = this.imageResizing.originalWidth + dx;
                    newHeight = newWidth / this.imageResizing.aspectRatio;
                    break;
                case 'sw': // Southwest - drag left/down
                    newWidth = this.imageResizing.originalWidth - dx;
                    newHeight = newWidth / this.imageResizing.aspectRatio;
                    break;
                case 'ne': // Northeast - drag right/up
                    newWidth = this.imageResizing.originalWidth + dx;
                    newHeight = newWidth / this.imageResizing.aspectRatio;
                    break;
                case 'nw': // Northwest - drag left/up
                    newWidth = this.imageResizing.originalWidth - dx;
                    newHeight = newWidth / this.imageResizing.aspectRatio;
                    break;
            }

            // Enforce minimum size
            const MIN_SIZE = 50;
            newWidth = Math.max(MIN_SIZE, newWidth);
            newHeight = Math.max(MIN_SIZE, newHeight);

            // Update task dimensions
            task.imageWidth = Math.round(newWidth);
            task.imageHeight = Math.round(newHeight);

            this.render();
            e.preventDefault();
            return;
        }

        // Update arrow dot hover detection (even when not dragging)
        if (!this.arrowDotDrag.active && !this.curveDotDrag.active) {
            this.updateArrowDotHover(pt.x, pt.y);
        }

        // Update curve dot hover detection (only when Ctrl is held, not in orthogonal mode, and not dragging)
        if (!this.arrowDotDrag.active && !this.curveDotDrag.active && (e.ctrlKey || e.metaKey) && this.arrowRoutingMode !== 'orthogonal') {
            this.updateCurveDotHover(pt.x, pt.y);
        } else if (!this.curveDotDrag.active) {
            // Clear curve dot hover if Ctrl not held or in orthogonal mode
            if (this.hoveredCurveDot) {
                this.hoveredCurveDot = null;
                this.render();
            }
        }

        // Handle arrow dot drag
        if (this.arrowDotDrag.active) {
            this.updateArrowDotDrag(pt.x, pt.y);
            e.preventDefault();
            return;
        }

        // Handle curve dot drag
        if (this.curveDotDrag.active) {
            this.updateCurveDotDrag(pt.x, pt.y);
            e.preventDefault();
            return;
        }

        if (!this.dragMode) return;

        e.preventDefault();

        if (this.dragMode === 'box-select' && this.boxSelectStart) {
            // Draw visual feedback for box selection
            const minX = Math.min(this.boxSelectStart.x, pt.x);
            const minY = Math.min(this.boxSelectStart.y, pt.y);
            const maxX = Math.max(this.boxSelectStart.x, pt.x);
            const maxY = Math.max(this.boxSelectStart.y, pt.y);

            // Remove existing selection box
            const existingBox = document.querySelector('#box-selection-rect');
            if (existingBox) existingBox.remove();

            // Create new selection box
            const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
            rect.id = 'box-selection-rect';
            rect.setAttribute('x', minX);
            rect.setAttribute('y', minY);
            rect.setAttribute('width', maxX - minX);
            rect.setAttribute('height', maxY - minY);
            rect.setAttribute('fill', 'rgba(33, 150, 243, 0.1)');
            rect.setAttribute('stroke', '#2196f3');
            rect.setAttribute('stroke-width', '2');
            rect.setAttribute('stroke-dasharray', '5,5');
            rect.setAttribute('pointer-events', 'none');
            document.getElementById('canvas').appendChild(rect);

            return;
        } else if (this.dragMode === 'node' && this.selectedNode !== null) {
            const task = this.tasks.find(t => t.id === this.selectedNode);
            if (task) {
                let newX = pt.x - this.dragStart.x;
                let newY = pt.y - this.dragStart.y;

                // Apply snapping
                if (this.enableSnapping) {
                    const dims = this.calculateTaskDimensions(task);
                    const excludeIds = this.selectedTaskIds.has(this.selectedNode) ? this.selectedTaskIds : new Set([this.selectedNode]);
                    const snapped = this.calculateSnapping(newX, newY, dims.width, dims.height, excludeIds);
                    newX = snapped.x;
                    newY = snapped.y;
                    this.activeSnapLines = snapped.snapLines;
                } else {
                    this.activeSnapLines = [];
                }

                // Check if we're dragging a selected node
                if (this.selectedTaskIds.has(this.selectedNode)) {
                    // Move all selected nodes together, maintaining relative positions
                    const dx = newX - task.x;
                    const dy = newY - task.y;

                    this.selectedTaskIds.forEach(selectedId => {
                        const selectedTask = this.tasks.find(t => t.id === selectedId);
                        if (selectedTask) {
                            selectedTask.x += dx;
                            selectedTask.y += dy;
                            selectedTask.vx = 0;
                            selectedTask.vy = 0;
                        }
                    });
                } else {
                    // Dragging an unselected node - move just this one
                    const snapped = this.snapPointToGrid(newX, newY);
                    task.x = snapped.x;
                    task.y = snapped.y;
                    task.vx = 0;
                    task.vy = 0;
                }

                // Check for hover copy of arrow attachments (with 750ms delay)
                // Temporarily hide dragged node from elementFromPoint to see what's underneath
                const draggedNodeElement = document.querySelector(`.task-node[data-id="${task.id}"]`);
                const originalPointerEvents = draggedNodeElement ? draggedNodeElement.style.pointerEvents : null;
                if (draggedNodeElement) {
                    draggedNodeElement.style.pointerEvents = 'none';
                }

                const elementUnderCursor = document.elementFromPoint(e.clientX, e.clientY);
                const hoveredNode = elementUnderCursor ? elementUnderCursor.closest('.task-node') : null;

                // Restore pointer events
                if (draggedNodeElement) {
                    draggedNodeElement.style.pointerEvents = originalPointerEvents || '';
                }

                if (hoveredNode) {
                    const hoveredId = parseInt(hoveredNode.dataset.id);
                    if (hoveredId !== task.id && !isNaN(hoveredId)) {
                        // Start hover timer if this is a new hover target OR revert if same target
                        if (this._attachmentCopyHoverTarget !== hoveredId || this._attachmentCopyApplied) {
                            // Clear any existing timer
                            if (this._attachmentCopyHoverTimer) {
                                clearTimeout(this._attachmentCopyHoverTimer);
                            }

                            // Capture IDs for closure
                            const draggedId = task.id;
                            const targetId = hoveredId;
                            const shouldRevert = this._attachmentCopyHoverTarget === hoveredId && this._attachmentCopyApplied;

                            // Set new timer for 750ms
                            this._attachmentCopyHoverTimer = setTimeout(() => {
                                if (shouldRevert) {
                                    // Revert to original
                                    this.revertArrowAttachments(draggedId);
                                    this._attachmentCopyApplied = false;
                                } else {
                                    // Apply copy
                                    this.handleArrowAttachmentHoverCopy(draggedId, targetId);
                                    this._attachmentCopyApplied = true;
                                }
                            }, 750);

                            this._attachmentCopyHoverTarget = hoveredId;
                        }
                    }
                } else {
                    // No longer hovering - moved to empty space
                    // Clear timer and reset state to allow multiple copies per drag
                    if (this._attachmentCopyHoverTimer) {
                        clearTimeout(this._attachmentCopyHoverTimer);
                        this._attachmentCopyHoverTimer = null;
                    }

                    // If we've copied attachments, commit them by updating the original state
                    // This allows multiple copies per drag session (reset after moving to empty space)
                    if (this._attachmentCopyApplied && this._attachmentCopyOriginal) {
                        // Update the "original" to current state so next revert doesn't undo this copy
                        this.saveOriginalArrowAttachments(task.id);
                        this._attachmentCopyApplied = false; // Allow copying again
                    }

                    this._attachmentCopyHoverTarget = null;
                }

                this.render();
            }
        } else if (this.dragMode === 'subtree-pending' && this.selectedNode !== null) {
            // Check if moved >threshold to activate subtree drag (vs shift+click for selection)
            const distance = Math.sqrt(
                Math.pow(pt.x - this.dragStartOriginal.x, 2) +
                Math.pow(pt.y - this.dragStartOriginal.y, 2)
            );

            if (distance >= this.INTERACTION.DRAG_THRESHOLD_PX) {
                // Activate full subtree drag
                this.dragMode = 'subtree';
                const taskId = this.selectedNode;

                // Get all descendants
                this.draggedSubtree = [taskId, ...this.getDescendants(taskId)];

                // Store original positions
                this.subtreeOriginalPositions = {};
                this.draggedSubtree.forEach(id => {
                    const t = this.tasks.find(t => t.id === id);
                    this.subtreeOriginalPositions[id] = { x: t.x, y: t.y };
                });

                const task = this.tasks.find(t => t.id === taskId);
                this.dragStart = { x: pt.x - task.x, y: pt.y - task.y };
                this.dragOriginalPos = { x: task.x, y: task.y };

                // Save snapshot BEFORE drag starts (captures original position)
                const truncatedTitle = task.title.length > 30 ? task.title.substring(0, 27) + '...' : task.title;
                this.saveSnapshot(`Move subtree '${truncatedTitle}'`);
            }
        } else if (this.dragMode === 'subtree' && this.selectedNode !== null) {
            // Calculate offset from original root position
            let newX = pt.x - this.dragStart.x;
            let newY = pt.y - this.dragStart.y;

            // Apply snapping to root node
            if (this.enableSnapping) {
                const rootTask = this.tasks.find(t => t.id === this.selectedNode);
                const dims = this.calculateTaskDimensions(rootTask);
                const excludeIds = new Set(this.draggedSubtree);
                const snapped = this.calculateSnapping(newX, newY, dims.width, dims.height, excludeIds);
                newX = snapped.x;
                newY = snapped.y;
                this.activeSnapLines = snapped.snapLines;
            } else {
                this.activeSnapLines = [];
            }

            let dx = newX - this.dragOriginalPos.x;
            let dy = newY - this.dragOriginalPos.y;

            // Snap the offset if grid snap is enabled
            if (this.gridEnabled && this.gridSnapEnabled) {
                dx = this.snapToGrid(dx);
                dy = this.snapToGrid(dy);
            }

            // Move entire subtree by same offset
            this.draggedSubtree.forEach(id => {
                const task = this.tasks.find(t => t.id === id);
                if (task) {
                    task.x = this.subtreeOriginalPositions[id].x + dx;
                    task.y = this.subtreeOriginalPositions[id].y + dy;
                    task.vx = 0;
                    task.vy = 0;
                }
            });

            this.render();
        } else if (this.dragMode === 'reparent-pending' && this.selectedNode !== null) {
            // Check if moved >threshold to activate reparent drag (vs Ctrl+click for multi-select)
            const distance = Math.sqrt(
                Math.pow(pt.x - this.dragStartOriginal.x, 2) +
                Math.pow(pt.y - this.dragStartOriginal.y, 2)
            );

            if (distance >= this.INTERACTION.DRAG_THRESHOLD_PX) {
                // Activate reparent drag mode
                this.dragMode = 'reparent';
                this.createTempLine(e);
                // Create custom cursor arrow
                this.cursorArrow = this.createCursorArrow();
                // Initialize line from source to cursor (A ‚Üí B)
                // Arrow follows drag motion for intuitive UX
                const task = this.tasks.find(t => t.id === this.selectedNode);
                if (task && this.tempLine) {
                    this.tempLine.setAttribute('x1', task.x);
                    this.tempLine.setAttribute('y1', task.y);
                    this.tempLine.setAttribute('x2', pt.x);
                    this.tempLine.setAttribute('y2', pt.y);
                }
            }
        } else if (this.dragMode === 'reparent' && this.tempLine) {
            const sourceTask = this.tasks.find(t => t.id === this.selectedNode);
            if (sourceTask) {
                // Check if cursor is over empty space (not over another task)
                const elementUnderCursor = document.elementFromPoint(e.clientX, e.clientY);
                const targetNode = elementUnderCursor ? elementUnderCursor.closest('.task-node') : null;

                if (!targetNode) {
                    // Over empty space ‚Üí Show preview ghost node for new child creation
                    // Hide cursor arrow (only show for reparenting, not child creation)
                    if (this.cursorArrow) {
                        this.cursorArrow.style.display = 'none';
                    }

                    // Remove existing preview if any
                    const existingPreview = document.getElementById('preview-ghost-node');
                    if (existingPreview) existingPreview.remove();

                    // Calculate preview node dimensions - MUST match actual created task
                    // Created tasks have title: '' (empty), so preview must too
                    const previewDims = this.calculateTaskDimensions({ title: '' });

                    // Calculate arrow endpoint at preview node edge (not center)
                    // Use same approach as permanent arrows in render.js
                    const arrowEnd = this.getLineEndAtRectEdge(
                        sourceTask.x, sourceTask.y,  // From source task center
                        pt.x, pt.y,                   // To preview node center
                        previewDims.width,
                        previewDims.height
                    );

                    // Update line from source to edge (same as permanent arrows)
                    this.tempLine.setAttribute('x1', sourceTask.x);
                    this.tempLine.setAttribute('y1', sourceTask.y);
                    this.tempLine.setAttribute('x2', arrowEnd.x);
                    this.tempLine.setAttribute('y2', arrowEnd.y);
                    // Add green arrowhead marker to match temp line color
                    this.tempLine.setAttribute('marker-end', 'url(#arrowhead-temp-green)');

                    // Create preview ghost node rectangle
                    const ghostNode = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                    ghostNode.id = 'preview-ghost-node';
                    ghostNode.setAttribute('x', pt.x - previewDims.width / 2);
                    ghostNode.setAttribute('y', pt.y - previewDims.height / 2);
                    ghostNode.setAttribute('width', previewDims.width);
                    ghostNode.setAttribute('height', previewDims.height);
                    ghostNode.setAttribute('rx', '8');
                    ghostNode.setAttribute('fill', 'rgba(255, 255, 255, 0.3)');
                    ghostNode.setAttribute('stroke', '#2196f3');
                    ghostNode.setAttribute('stroke-width', '2');
                    ghostNode.setAttribute('stroke-dasharray', '5,5');
                    ghostNode.setAttribute('pointer-events', 'none');
                    document.getElementById('canvas').appendChild(ghostNode);
                } else {
                    // Over another task ‚Üí Show cursor arrow for reparenting
                    this.updateCursorArrow(e.clientX, e.clientY, sourceTask);

                    // Remove preview ghost if exists
                    const existingPreview = document.getElementById('preview-ghost-node');
                    if (existingPreview) existingPreview.remove();

                    // Update line to cursor (no preview node to clip to)
                    this.tempLine.setAttribute('x1', sourceTask.x);
                    this.tempLine.setAttribute('y1', sourceTask.y);
                    this.tempLine.setAttribute('x2', pt.x);
                    this.tempLine.setAttribute('y2', pt.y);
                    // Remove arrowhead marker (cursor arrow shows direction)
                    this.tempLine.removeAttribute('marker-end');
                }
            }
        } else if ((this.dragMode === 'dependency') && this.tempLine) {
            // Get source task for cursor arrow rotation
            const sourceTask = this.tasks.find(t => t.id === this.selectedNode);
            if (sourceTask) {
                this.updateCursorArrow(e.clientX, e.clientY, sourceTask);

                // Update line from source to cursor (A ‚Üí B drag direction)
                // Arrow follows hand motion for intuitive UX
                this.tempLine.setAttribute('x1', sourceTask.x);
                this.tempLine.setAttribute('y1', sourceTask.y);
                this.tempLine.setAttribute('x2', pt.x);
                this.tempLine.setAttribute('y2', pt.y);
            }
        } else if (this.dragMode === 'canvas') {
            // Calculate delta in screen coordinates (stable)
            const screenDx = e.clientX - this.dragStart.x;
            const screenDy = e.clientY - this.dragStart.y;

            // Convert screen pixels to SVG units for viewBox movement
            // Account for zoom: when zoomed in, panning is slower (more precise)
            // when zoomed out, panning is faster (cover more ground)
            const svg = document.getElementById('canvas');
            const actualViewBoxWidth = this.viewBox.width / this.zoomLevel; // Current rendered viewBox size
            const scale = actualViewBoxWidth / svg.clientWidth; // SVG units per screen pixel
            const svgDx = screenDx * scale;
            const svgDy = screenDy * scale;

            // Move viewBox (opposite direction: drag right = look left)
            this.viewBox.x -= svgDx;
            this.viewBox.y -= svgDy;

            // Update dragStart for next frame (screen coords)
            this.dragStart = { x: e.clientX, y: e.clientY };
            this.render();
        }
    },

    onCanvasMouseUp(e) {
        // End image resizing
        if (this.imageResizing) {
            this.imageResizing = null;
            this.saveToStorage();
            e.preventDefault();
            return;
        }

        // Handle arrow dot drag finish
        if (this.arrowDotDrag.active) {
            this.finishArrowDotDrag();
            e.preventDefault();
            return;
        }

        // Handle curve dot drag finish
        if (this.curveDotDrag.active) {
            this.finishCurveDotDrag();
            e.preventDefault();
            return;
        }

        if (this.dragMode === 'dependency') {
            // Use elementFromPoint to find what's actually under cursor (not e.target)
            const elementUnderCursor = document.elementFromPoint(e.clientX, e.clientY);
            const targetNode = elementUnderCursor ? elementUnderCursor.closest('.task-node') : null;
            if (targetNode && this.tempLine) {
                const targetId = parseInt(targetNode.dataset.id);

                // Check if dragging FROM a selected node (multi-source mode)
                if (this.selectedTaskIds.has(this.selectedNode)) {
                    // Source is selected (with others): all selected ‚Üí target
                    // target depends on each selected node
                    this.selectedTaskIds.forEach(sourceId => {
                        if (sourceId !== targetId) {
                            this.addDependency({ dependentId: targetId, prerequisiteId: sourceId });
                        }
                    });
                } else if (this.selectedTaskIds.has(targetId)) {
                    // Target is selected (with others): source ‚Üí all selected
                    // each selected depends on source
                    this.selectedTaskIds.forEach(depId => {
                        if (depId !== this.selectedNode) {
                            this.addDependency({ dependentId: depId, prerequisiteId: this.selectedNode });
                        }
                    });
                } else {
                    // Single source/target mode: source ‚Üí target
                    if (targetId !== this.selectedNode) {
                        this.addDependency({ dependentId: targetId, prerequisiteId: this.selectedNode });
                    }
                }
            }
            this.removeTempLine();
        } else if (this.dragMode === 'reparent') {
            // Complete reparent: Make target a child of source
            const elementUnderCursor = document.elementFromPoint(e.clientX, e.clientY);
            const targetNode = elementUnderCursor ? elementUnderCursor.closest('.task-node') : null;

            if (targetNode && this.tempLine) {
                // Dropped on another task ‚Üí Reparent
                const targetId = parseInt(targetNode.dataset.id);

                // Reparent target to source (source becomes parent of target)
                // Drag from A to B = A becomes parent of B
                if (targetId !== this.selectedNode) {
                    this.reparentTask({ taskId: targetId, newParentId: this.selectedNode });
                }
            } else if (!targetNode && this.tempLine) {
                // Dropped on empty space ‚Üí Create child task at cursor position
                const pt = this.getSVGPoint(e);

                // DEFENSIVE: Validate coordinates
                if (this.validateTaskCoordinates({ x: pt.x, y: pt.y })) {
                    this.createChildAtPosition({
                        parentId: this.selectedNode,
                        x: pt.x,
                        y: pt.y
                    });
                }
            }

            // Clean up visual elements
            this.removeTempLine();
            const previewGhost = document.getElementById('preview-ghost-node');
            if (previewGhost) previewGhost.remove();
        } else if (this.dragMode === 'reparent-pending') {
            // Ctrl+click without dragging - don't interfere, let click event handle multi-select
            // Don't do anything here, just clear the dragMode
        } else if (this.dragMode === 'subtree-pending') {
            // Shift+click without dragging - clear pending mode
            // Don't do anything here, just clear the dragMode
        } else if (this.dragMode === 'subtree' && this.selectedNode !== null) {
            const task = this.tasks.find(t => t.id === this.selectedNode);
            if (task) {
                const movedDistance = Math.sqrt(
                    Math.pow(task.x - this.dragOriginalPos.x, 2) +
                    Math.pow(task.y - this.dragOriginalPos.y, 2)
                );

                // Save to storage if we actually moved (snapshot was saved in mousedown)
                if (movedDistance >= this.INTERACTION.DRAG_THRESHOLD_PX) {
                    // Update timestamps for all moved nodes in the subtree
                    this.draggedSubtree.forEach(nodeId => {
                        this.updateConnectedArrowsTimestamps(nodeId);
                    });

                    this.saveToStorage();
                } else {
                    // Didn't move enough - remove the snapshot we created in mousedown
                    if (this.undoStack.length > 0) {
                        this.undoStack.pop();
                    }
                }
            }

            // Clean up subtree drag state
            this.draggedSubtree = [];
            this.subtreeOriginalPositions = {};
        } else if (this.dragMode === 'node' && this.selectedNode !== null) {
            const task = this.tasks.find(t => t.id === this.selectedNode);
            if (task) {
                const movedDistance = Math.sqrt(
                    Math.pow(task.x - this.dragOriginalPos.x, 2) +
                    Math.pow(task.y - this.dragOriginalPos.y, 2)
                );

                // Save to storage if we actually moved (snapshot was saved in mousedown)
                if (movedDistance >= this.INTERACTION.DRAG_THRESHOLD_PX) {
                    // Update timestamps for all connected arrows to prioritize them
                    // If multi-select, update all selected nodes; otherwise just the moved node
                    if (this.selectedTaskIds.has(this.selectedNode) && this.selectedTaskIds.size > 1) {
                        this.selectedTaskIds.forEach(taskId => {
                            this.updateConnectedArrowsTimestamps(taskId);
                        });
                    } else {
                        this.updateConnectedArrowsTimestamps(this.selectedNode);
                    }

                    this.saveToStorage();
                } else {
                    // Didn't move enough - remove the snapshot we created in mousedown
                    if (this.undoStack.length > 0) {
                        this.undoStack.pop();
                    }
                }
            }
        } else if (this.dragMode === 'canvas') {
            // Don't create undo snapshot for canvas panning - it's a viewport navigation
            // action, not a content modification. Creating a snapshot would clear the
            // redo stack, preventing users from redoing after panning to look around.
            // Use debounced save to prevent performance issues from frequent localStorage writes
            this.debouncedSaveToStorage(500);
        } else if (this.dragMode === 'box-select' && this.boxSelectStart) {
            // Complete box selection
            const pt = this.getSVGPoint(e);
            const minX = Math.min(this.boxSelectStart.x, pt.x);
            const minY = Math.min(this.boxSelectStart.y, pt.y);
            const maxX = Math.max(this.boxSelectStart.x, pt.x);
            const maxY = Math.max(this.boxSelectStart.y, pt.y);

            // Find all nodes whose centers fall within the box
            const selectedInBox = this.tasks.filter(task => {
                return !task.hidden && task.x >= minX && task.x <= maxX && task.y >= minY && task.y <= maxY;
            });

            // Add to selection (additive - Shift+drag means add to existing selection)
            selectedInBox.forEach(task => {
                this.selectedTaskIds.add(task.id);
            });

            // Remove the selection box visual
            const boxElement = document.querySelector('#box-selection-rect');
            if (boxElement) boxElement.remove();

            // Render to show highlights on selected nodes
            this.render();
        }

        // Clear selection when clicking canvas (not when panning)
        const wasCanvasDrag = this.dragMode === 'canvas';

        // Remove custom cursor arrow if it exists
        this.removeCursorArrow();

        // Clear snap lines
        this.activeSnapLines = [];

        this.dragMode = null;
        this.selectedNode = null;
        this.isBoxSelecting = false;
        this.boxSelectStart = null;

        // Clear arrow attachment copy state
        if (this._attachmentCopyHoverTimer) {
            clearTimeout(this._attachmentCopyHoverTimer);
            this._attachmentCopyHoverTimer = null;
        }
        this._attachmentCopyHoverTarget = null;
        this._attachmentCopyApplied = false;
        this._attachmentCopyOriginal = null;

        if (wasCanvasDrag) {
            // Only clear selection if we didn't actually pan (click without movement)
            const pt = this.getSVGPoint(e);
            const panDistance = Math.sqrt(
                Math.pow(pt.x - this.dragStartOriginal.x, 2) +
                Math.pow(pt.y - this.dragStartOriginal.y, 2)
            );

            // If pan distance < threshold, treat as a click on canvas and clear selection
            if (panDistance < this.INTERACTION.DRAG_THRESHOLD_PX) {
                this.selectedTaskIds.clear();
                this.selectedLine = null;
                this.render();
            }
        }
        document.getElementById('canvas-container').classList.remove('dragging');
    },

    /**
     * Start resizing an image node
     * @param {number} taskId - Task ID
     * @param {string} corner - Corner being dragged ('se', 'sw', 'ne', 'nw')
     * @param {MouseEvent} e - Mouse event
     */
    startImageResize(taskId, corner, e) {
        const task = this.tasks.find(t => t.id === taskId);
        if (!task || !task.imageId) return;

        this.imageResizing = {
            taskId: taskId,
            corner: corner,
            startPoint: this.getSVGPoint(e),
            originalWidth: task.imageWidth,
            originalHeight: task.imageHeight,
            aspectRatio: task.imageWidth / task.imageHeight
        };

        // Save snapshot for undo
        this.saveSnapshot(`Resize image`);
    },

    /**
     * Save original arrow attachments before copying (for revert)
     * @param {number} draggedId - ID of node being dragged
     */
    saveOriginalArrowAttachments(draggedId) {
        const draggedTask = this.tasks.find(t => t.id === draggedId);
        if (!draggedTask) return;

        this._attachmentCopyOriginal = {
            taskId: draggedId,
            customAttachPoints: JSON.parse(JSON.stringify(draggedTask.customAttachPoints || {})),
            customSourcePoints: JSON.parse(JSON.stringify(draggedTask.customSourcePoints || {}))
        };
    },

    /**
     * Revert arrow attachments to original state
     * @param {number} draggedId - ID of node being dragged
     */
    revertArrowAttachments(draggedId) {
        if (!this._attachmentCopyOriginal || this._attachmentCopyOriginal.taskId !== draggedId) {
            return;
        }

        const draggedTask = this.tasks.find(t => t.id === draggedId);
        if (!draggedTask) return;

        draggedTask.customAttachPoints = JSON.parse(JSON.stringify(this._attachmentCopyOriginal.customAttachPoints));
        draggedTask.customSourcePoints = JSON.parse(JSON.stringify(this._attachmentCopyOriginal.customSourcePoints));

        this.showToast('‚Ü©Ô∏è Reverted arrow attachments', 'info', 1500);
    },

    /**
     * Handle arrow attachment copying when hovering dragged node over another node
     * Copies both target points (where arrows land) and source points (where arrows start)
     * @param {number} draggedId - ID of node being dragged
     * @param {number} hoveredId - ID of node being hovered over
     */
    handleArrowAttachmentHoverCopy(draggedId, hoveredId) {
        const draggedTask = this.tasks.find(t => t.id === draggedId);
        const hoveredTask = this.tasks.find(t => t.id === hoveredId);

        if (!draggedTask || !hoveredTask) {
            return;
        }

        // Save original state before first copy
        if (!this._attachmentCopyOriginal) {
            this.saveOriginalArrowAttachments(draggedId);
        }

        let copiedCount = 0;

        // Process matching parent relationships (arrows coming INTO both nodes)
        const draggedParents = [draggedTask.mainParent, ...draggedTask.otherParents].filter(p => p !== null);
        const hoveredParents = [hoveredTask.mainParent, ...hoveredTask.otherParents].filter(p => p !== null);
        const sharedParents = draggedParents.filter(p => hoveredParents.includes(p));

        sharedParents.forEach(parentId => {
            const parent = this.tasks.find(t => t.id === parentId);
            if (!parent) return;

            // Copy TARGET point (where arrow lands on child)
            let targetPoint;
            if (hoveredTask.customAttachPoints && hoveredTask.customAttachPoints[parentId]) {
                targetPoint = hoveredTask.customAttachPoints[parentId];
            } else {
                const hoveredEndpoint = this.getArrowEndpoint(parent, hoveredTask, 'target');
                const hoveredDims = this.calculateTaskDimensions(hoveredTask);
                targetPoint = this.constrainToRectEdge(
                    hoveredEndpoint.x, hoveredEndpoint.y,
                    hoveredTask.x, hoveredTask.y,
                    hoveredDims.width, hoveredDims.height
                );
            }

            if (!draggedTask.customAttachPoints) {
                draggedTask.customAttachPoints = {};
            }
            draggedTask.customAttachPoints[parentId] = JSON.parse(JSON.stringify(targetPoint));
            copiedCount++;

            // Copy SOURCE point (where arrow starts from parent)
            let sourcePoint;
            if (parent.customSourcePoints && parent.customSourcePoints[hoveredId]) {
                sourcePoint = parent.customSourcePoints[hoveredId];
            } else {
                const parentStartpoint = this.getArrowEndpoint(parent, hoveredTask, 'source');
                const parentDims = this.calculateTaskDimensions(parent);
                sourcePoint = this.constrainToRectEdge(
                    parentStartpoint.x, parentStartpoint.y,
                    parent.x, parent.y,
                    parentDims.width, parentDims.height
                );
            }

            if (!parent.customSourcePoints) {
                parent.customSourcePoints = {};
            }
            parent.customSourcePoints[draggedId] = JSON.parse(JSON.stringify(sourcePoint));
            copiedCount++;
        });

        // Process matching child relationships (arrows going OUT from both nodes)
        const sharedChildren = draggedTask.children.filter(c => hoveredTask.children.includes(c));

        sharedChildren.forEach(childId => {
            const child = this.tasks.find(t => t.id === childId);
            if (!child) return;

            // Copy TARGET point (where arrow lands on child)
            let targetPoint;
            if (child.customAttachPoints && child.customAttachPoints[hoveredId]) {
                targetPoint = child.customAttachPoints[hoveredId];
            } else {
                const childTargetEndpoint = this.getArrowEndpoint(hoveredTask, child, 'target');
                const childDims = this.calculateTaskDimensions(child);
                targetPoint = this.constrainToRectEdge(
                    childTargetEndpoint.x, childTargetEndpoint.y,
                    child.x, child.y,
                    childDims.width, childDims.height
                );
            }

            if (!child.customAttachPoints) {
                child.customAttachPoints = {};
            }
            child.customAttachPoints[draggedId] = JSON.parse(JSON.stringify(targetPoint));
            copiedCount++;

            // Copy SOURCE point (where arrow starts from parent)
            let sourcePoint;
            if (hoveredTask.customSourcePoints && hoveredTask.customSourcePoints[childId]) {
                sourcePoint = hoveredTask.customSourcePoints[childId];
            } else {
                const draggedStartpoint = this.getArrowEndpoint(hoveredTask, child, 'source');
                const hoveredDims = this.calculateTaskDimensions(hoveredTask);
                sourcePoint = this.constrainToRectEdge(
                    draggedStartpoint.x, draggedStartpoint.y,
                    hoveredTask.x, hoveredTask.y,
                    hoveredDims.width, hoveredDims.height
                );
            }

            if (!draggedTask.customSourcePoints) {
                draggedTask.customSourcePoints = {};
            }
            draggedTask.customSourcePoints[childId] = JSON.parse(JSON.stringify(sourcePoint));
            copiedCount++;
        });

        // Show feedback with prominent toast and visual flash effect
        if (copiedCount > 0) {
            // Bigger, longer toast for better visibility
            this.showToast(`‚ú® Copied ${copiedCount} arrow attachment${copiedCount > 1 ? 's' : ''} from hover target!`, 'success', 3000);

            // Add flash effect to dragged node
            const draggedNodeElement = document.querySelector(`.task-node[data-id="${draggedId}"]`);
            if (draggedNodeElement) {
                draggedNodeElement.classList.add('attachment-copied-flash');
                setTimeout(() => {
                    draggedNodeElement.classList.remove('attachment-copied-flash');
                }, 600); // Remove after animation completes
            }
        } else {
            this.showToast('‚ö†Ô∏è No matching relationships to copy', 'warning', 2000);
        }
    },

});



// ============================================================
// INTERACTIONS/KEYBOARD.JS (Order: 26, Category: interactions)
// ============================================================

/**
 * @module interactions/keyboard
 * @order 26
 * @category interactions
 *
 * Keyboard event handlers and shortcuts
 *
 * NOTE: The keyboard handler remains in task-tree.html (lines ~1476-1877 within
 * setupEventListeners()) due to its integration with app state. This file documents
 * the keyboard shortcut architecture.
 *
 * KEY SHORTCUTS:
 *
 * Task Management:
 * - Enter: Create root task at last mouse position
 * - Tab: Create child of selected task
 * - Delete/Backspace: Delete selected task(s)
 * - E: Edit selected task
 * - D: Toggle done status
 * - W: Toggle working status
 * - P: Cycle priority (normal ‚Üí medium ‚Üí high)
 * - H: Toggle hide/show descendants
 *
 * Selection:
 * - Escape: Clear selections
 * - Ctrl/Cmd+A: Select all tasks
 * - A: Select all tasks in subtree of selected
 * - Arrow Keys: Move selected task(s) 1 pixel in direction
 *
 * Navigation:
 * - 0-9: Jump to home with keybind
 * - J: Jump to working task (or show dropdown if multiple)
 * - M: Mark origin home
 * - O: Open link (if selected task has link)
 * - F: Zoom to fit all tasks
 *
 * Clipboard:
 * - Ctrl/Cmd+C: Copy selected task(s)
 * - Ctrl/Cmd+V: Paste at cursor or as child
 * - Ctrl/Cmd+X: Cut selected task(s)
 *
 * Undo/Redo:
 * - Ctrl/Cmd+Z: Undo last action
 * - Ctrl/Cmd+Shift+Z: Redo last undone action
 *
 * View:
 * - +/=: Zoom in
 * - -/_: Zoom out
 * - 0: Reset zoom to 100%
 * - T: Toggle dark mode
 * - Ctrl/Cmd+Alt+A: Toggle arrow routing mode (Direct/Orthogonal)
 *
 * System:
 * - ?: Show shortcuts modal
 * - Ctrl/Cmd+S: Manual save (no-op, auto-saves)
 * - Ctrl/Cmd+Shift+E: Export data
 * - Ctrl/Cmd+Shift+I: Import data
 * - Ctrl/Cmd+Shift+Delete: Clear all data
 *
 * The keyboard handler includes:
 * - Modifier key detection (Ctrl/Cmd, Alt, Shift)
 * - Preventing default browser shortcuts
 * - Context-aware behavior (e.g., Tab creates child only if task selected)
 * - Hover-aware shortcuts (e.g., P cycles priority of hovered task)
 */

Object.assign(app, {
    // Placeholder - actual handler stays in setupEventListeners()
    // This module serves as shortcut documentation
});



// ============================================================
// INTERACTIONS/DRAG.JS (Order: 27, Category: interactions)
// ============================================================

/**
 * @module interactions/drag
 * @order 27
 * @category interactions
 *
 * Drag mode logic and state management
 *
 * NOTE: Drag logic is integrated into mouse.js handlers (onCanvasMouseDown,
 * onCanvasMouseMove, onCanvasMouseUp). This file documents the drag architecture.
 *
 * DRAG MODES:
 *
 * 1. node - Move single task
 *    - Trigger: Left-click drag (no modifier)
 *    - Behavior: Moves single task or all selected tasks together
 *    - State: dragStart (offset from cursor to task center)
 *    - Snapshot: Saved at mousedown
 *
 * 2. subtree - Move entire subtree
 *    - Trigger: Shift+drag (activates after 5px movement)
 *    - Behavior: Moves root task and all descendants preserving relative positions
 *    - State: draggedSubtree (array of IDs), subtreeOriginalPositions (map)
 *    - Snapshot: Saved when activated (not at mousedown)
 *
 * 3. reparent - Change parent relationship
 *    - Trigger: Ctrl/Cmd+drag (activates after 5px movement)
 *    - Behavior: Makes source task a child of target task
 *    - Visual: Green solid temp line, cursor arrow
 *    - State: tempLine, cursorArrow
 *    - Snapshot: Saved in reparentTask()
 *
 * 4. dependency - Create dependency link
 *    - Trigger: Alt+drag
 *    - Behavior: Creates dependency from source (prerequisite) to target (dependent)
 *    - Visual: Blue dashed temp line (reversed: cursor ‚Üí source), cursor arrow
 *    - State: tempLine, cursorArrow
 *    - Supports: Multi-select (all selected ‚Üí target OR source ‚Üí all selected)
 *    - Snapshot: Saved in addDependency()
 *
 * 5. box-select - Multi-select rectangle
 *    - Trigger: Ctrl/Cmd+drag on empty space
 *    - Behavior: Selects all tasks within drawn rectangle
 *    - Visual: Blue dashed rectangle overlay
 *    - State: boxSelectStart (SVG coords)
 *
 * 6. canvas - Pan viewport
 *    - Trigger: Drag on empty space (no modifier)
 *    - Behavior: Moves viewBox to pan around canvas
 *    - Coordinates: Screen coordinates (stable under zoom)
 *    - Visual: 'dragging' class on canvas-container (grab cursor)
 *
 * PENDING MODES:
 * - reparent-pending, subtree-pending: Allow distinguishing click vs drag
 * - If <5px movement ‚Üí treated as click (multi-select or context menu)
 * - If ‚â•5px movement ‚Üí activates full drag mode
 *
 * CLICK DETECTION:
 * - Uses dragStartOriginal (SVG coords at mousedown)
 * - Calculates distance at mouseup
 * - <5px = click, ‚â•5px = drag
 * - Click events: context menu, multi-select toggle
 */

Object.assign(app, {
    // Placeholder - drag logic integrated into mouse handlers
    // This module serves as architecture documentation
});



// ============================================================
// INTERACTIONS/SNAPPING.JS (Order: 27, Category: interactions)
// ============================================================

/**
 * @module interactions/snapping
 * @order 27
 * @category interactions
 *
 * Alignment snapping for node positioning
 * Provides visual feedback and snap-to-align behavior when dragging nodes
 */

Object.assign(app, {
    /**
     * Calculate snap position for a dragged node
     * Returns adjusted position and snap lines to display
     *
     * @param {number} draggedX - Proposed X position of dragged node center
     * @param {number} draggedY - Proposed Y position of dragged node center
     * @param {number} draggedWidth - Width of dragged node
     * @param {number} draggedHeight - Height of dragged node
     * @param {Set<number>} excludeIds - Task IDs to exclude from snapping (e.g., dragged tasks)
     * @returns {{x: number, y: number, snapLines: Array}} Adjusted position and snap lines
     */
    calculateSnapping(draggedX, draggedY, draggedWidth, draggedHeight, excludeIds = new Set()) {
        if (!this.enableSnapping) {
            return { x: draggedX, y: draggedY, snapLines: [] };
        }

        const threshold = this.snapThreshold;
        const snapLines = [];

        // Calculate dragged node bounds
        const dragged = {
            left: draggedX - draggedWidth / 2,
            right: draggedX + draggedWidth / 2,
            top: draggedY - draggedHeight / 2,
            bottom: draggedY + draggedHeight / 2,
            centerX: draggedX,
            centerY: draggedY
        };

        let snapX = null;
        let snapY = null;
        let minDistX = threshold;
        let minDistY = threshold;
        let snapLineX = null;
        let snapLineY = null;

        // Check all other tasks (only those visible in viewport)
        for (const task of this.tasks) {
            if (excludeIds.has(task.id) || task.hidden) continue;

            // Skip tasks outside the viewport
            const margin = 100; // Extra margin to include near-viewport tasks
            if (task.x < this.viewBox.x - margin ||
                task.x > this.viewBox.x + this.viewBox.width + margin ||
                task.y < this.viewBox.y - margin ||
                task.y > this.viewBox.y + this.viewBox.height + margin) {
                continue;
            }

            const dims = this.calculateTaskDimensions(task);
            const other = {
                left: task.x - dims.width / 2,
                right: task.x + dims.width / 2,
                top: task.y - dims.height / 2,
                bottom: task.y + dims.height / 2,
                centerX: task.x,
                centerY: task.y
            };

            // Check vertical alignments (affects X position)
            const verticalChecks = [
                // Edge alignments
                { pos: other.left, dragPos: dragged.left, type: 'left-edge', line: other.left },
                { pos: other.right, dragPos: dragged.right, type: 'right-edge', line: other.right },
                { pos: other.left, dragPos: dragged.right, type: 'right-to-left', line: other.left },
                { pos: other.right, dragPos: dragged.left, type: 'left-to-right', line: other.right },
                // Center alignment
                { pos: other.centerX, dragPos: dragged.centerX, type: 'center-x', line: other.centerX, isCenter: true }
            ];

            for (const check of verticalChecks) {
                const dist = Math.abs(check.pos - check.dragPos);
                if (dist < minDistX) {
                    minDistX = dist;
                    const offset = check.pos - check.dragPos;
                    snapX = draggedX + offset;
                    snapLineX = {
                        type: 'vertical',
                        position: check.line,
                        alignType: check.isCenter ? 'center' : 'edge'
                    };
                }
            }

            // Check horizontal alignments (affects Y position)
            const horizontalChecks = [
                // Edge alignments
                { pos: other.top, dragPos: dragged.top, type: 'top-edge', line: other.top },
                { pos: other.bottom, dragPos: dragged.bottom, type: 'bottom-edge', line: other.bottom },
                { pos: other.top, dragPos: dragged.bottom, type: 'bottom-to-top', line: other.top },
                { pos: other.bottom, dragPos: dragged.top, type: 'top-to-bottom', line: other.bottom },
                // Center alignment
                { pos: other.centerY, dragPos: dragged.centerY, type: 'center-y', line: other.centerY, isCenter: true }
            ];

            for (const check of horizontalChecks) {
                const dist = Math.abs(check.pos - check.dragPos);
                if (dist < minDistY) {
                    minDistY = dist;
                    const offset = check.pos - check.dragPos;
                    snapY = draggedY + offset;
                    snapLineY = {
                        type: 'horizontal',
                        position: check.line,
                        alignType: check.isCenter ? 'center' : 'edge'
                    };
                }
            }
        }

        // Build snap lines array
        if (snapLineX) snapLines.push(snapLineX);
        if (snapLineY) snapLines.push(snapLineY);

        return {
            x: snapX !== null ? snapX : draggedX,
            y: snapY !== null ? snapY : draggedY,
            snapLines
        };
    }
});

console.log('[snapping.js] Alignment snapping loaded');



// ============================================================
// INTERACTIONS/ARROW-SNAP.JS (Order: 28, Category: interactions)
// ============================================================

/**
 * @module interactions/arrow-snap
 * @order 28
 * @category interactions
 *
 * Arrow snap point interactions - drag dots to customize arrow attachment points
 * Currently implements TARGET END only (arrowhead). Source end logic reusable for future.
 */

Object.assign(app, {
    /**
     * Setup mouse listeners for arrow dot interactions
     * Called during app initialization
     */
    setupArrowSnapListeners() {
        const canvas = document.getElementById('canvas');
        if (!canvas) {
            console.warn('[arrow-snap] Canvas not found, skipping setup');
            return;
        }

        // Mousemove for hover detection (delegated to render loop)
        // Mousedown/up for drag handled by existing onCanvasMouseDown/Up

        console.log('‚úì Arrow snap listeners setup');
    },

    /**
     * Check if mouse is near any arrow endpoint and update hover state
     * Called from render() every frame
     *
     * @param {number} mouseX - Mouse X in SVG coordinates
     * @param {number} mouseY - Mouse Y in SVG coordinates
     */
    updateArrowDotHover(mouseX, mouseY) {
        // DEFENSIVE: Skip if editing or dragging
        if (this.editingTaskId !== null || this.dragMode !== null) {
            this.hoveredArrowDot = null;
            return;
        }

        // DEFENSIVE: Validate inputs
        if (!isFinite(mouseX) || !isFinite(mouseY)) {
            return;
        }

        // PERF: If already hovering a dot, check if cursor moved too far away
        // Use squared distance to avoid Math.sqrt()
        if (this.hoveredArrowDot) {
            const dx = mouseX - this.hoveredArrowDot.x;
            const dy = mouseY - this.hoveredArrowDot.y;
            const distanceSquared = dx * dx + dy * dy;
            const hideRadiusSquared = this.arrowDotHideRadius * this.arrowDotHideRadius;

            if (distanceSquared > hideRadiusSquared) {
                // Cursor moved too far - hide the dot
                this.hoveredArrowDot = null;

                // Update cursor
                const canvasContainer = document.getElementById('canvas-container');
                canvasContainer.style.cursor = 'default';

                // Trigger re-render to hide dot
                this.render();
                return;
            }
            // Still within hide radius - keep showing the dot
            return;
        }

        // Not currently hovering - check all visible arrows for proximity
        const hoveredDot = this.findArrowDotNearMouse(mouseX, mouseY);

        this.hoveredArrowDot = hoveredDot;

        // Update cursor style
        const canvasContainer = document.getElementById('canvas-container');
        if (hoveredDot && !this.arrowDotDrag.active) {
            canvasContainer.style.cursor = 'pointer';
        } else if (!this.arrowDotDrag.active && this.dragMode === null) {
            canvasContainer.style.cursor = 'default';
        }

        // IMPORTANT: Trigger re-render when hover state changes
        if (hoveredDot) {
            this.render();
        }
    },

    /**
     * Find arrow dot near mouse position
     * If multiple dots overlap, prioritizes the most recently moved (highest timestamp)
     *
     * @param {number} mouseX - Mouse X in SVG coordinates
     * @param {number} mouseY - Mouse Y in SVG coordinates
     * @returns {{type: string, taskId: number, parentId: number, childId: number, x: number, y: number}|null}
     */
    findArrowDotNearMouse(mouseX, mouseY) {
        // DEFENSIVE: Validate radius
        const radius = this.arrowDotRadius || 5;

        // PERF: Only check tasks near mouse cursor (rough viewport culling)
        // This avoids checking 100+ tasks when mouse is far away
        const QUICK_CHECK_MARGIN = 500;

        // Collect ALL dots near mouse, then prioritize by timestamp
        const nearbyDots = [];

        // Check all arrows (main parent + other parents)
        for (const task of this.tasks) {
            if (task.hidden) continue;

            // PERF: Quick distance check before expensive endpoint calculation
            const dx = task.x - mouseX;
            const dy = task.y - mouseY;
            if (Math.abs(dx) > QUICK_CHECK_MARGIN || Math.abs(dy) > QUICK_CHECK_MARGIN) {
                continue; // Too far away, skip
            }

            // Check main parent arrow (TARGET end - arrowhead on child)
            if (task.mainParent !== null) {
                const parent = this.tasks.find(t => t.id === task.mainParent);
                if (parent && !parent.hidden) {
                    const endPos = this.getArrowEndpoint(parent, task, 'target');

                    if (this.isPointNearPosition(mouseX, mouseY, endPos.x, endPos.y, radius)) {
                        const customPoint = task.customAttachPoints?.[task.mainParent];
                        nearbyDots.push({
                            type: 'target',
                            taskId: task.id,
                            parentId: task.mainParent,
                            x: endPos.x,
                            y: endPos.y,
                            timestamp: customPoint?.timestamp || 0
                        });
                    }
                }
            }

            // Check other parents (TARGET end - arrowhead on child)
            for (const parentId of task.otherParents || []) {
                const parent = this.tasks.find(t => t.id === parentId);
                if (parent && !parent.hidden) {
                    const endPos = this.getArrowEndpoint(parent, task, 'target');
                    if (this.isPointNearPosition(mouseX, mouseY, endPos.x, endPos.y, radius)) {
                        const customPoint = task.customAttachPoints?.[parentId];
                        nearbyDots.push({
                            type: 'target',
                            taskId: task.id,
                            parentId: parentId,
                            x: endPos.x,
                            y: endPos.y,
                            timestamp: customPoint?.timestamp || 0
                        });
                    }
                }
            }

            // Check main parent arrow (SOURCE end - where arrow starts from parent)
            if (task.mainParent !== null) {
                const parent = this.tasks.find(t => t.id === task.mainParent);
                if (parent && !parent.hidden) {
                    const startPos = this.getArrowEndpoint(parent, task, 'source');

                    if (this.isPointNearPosition(mouseX, mouseY, startPos.x, startPos.y, radius)) {
                        const customPoint = parent.customSourcePoints?.[task.id];
                        nearbyDots.push({
                            type: 'source',
                            taskId: parent.id,  // Source dot belongs to parent node
                            childId: task.id,   // Related to this child
                            x: startPos.x,
                            y: startPos.y,
                            timestamp: customPoint?.timestamp || 0
                        });
                    }
                }
            }

            // Check other parents (SOURCE end - where arrow starts from parent)
            for (const parentId of task.otherParents || []) {
                const parent = this.tasks.find(t => t.id === parentId);
                if (parent && !parent.hidden) {
                    const startPos = this.getArrowEndpoint(parent, task, 'source');
                    if (this.isPointNearPosition(mouseX, mouseY, startPos.x, startPos.y, radius)) {
                        const customPoint = parent.customSourcePoints?.[task.id];
                        nearbyDots.push({
                            type: 'source',
                            taskId: parent.id,  // Source dot belongs to parent node
                            childId: task.id,   // Related to this child
                            x: startPos.x,
                            y: startPos.y,
                            timestamp: customPoint?.timestamp || 0
                        });
                    }
                }
            }
        }

        // If no dots found, return null
        if (nearbyDots.length === 0) return null;

        // If multiple dots overlap, return the one with highest timestamp (most recently moved)
        nearbyDots.sort((a, b) => b.timestamp - a.timestamp);

        // Remove timestamp before returning (not needed in result)
        const result = nearbyDots[0];
        delete result.timestamp;
        return result;
    },

    /**
     * Determine which edge a point is on
     * @param {number} pointX - Point X
     * @param {number} pointY - Point Y
     * @param {number} centerX - Rectangle center X
     * @param {number} centerY - Rectangle center Y
     * @param {number} rectWidth - Rectangle width
     * @param {number} rectHeight - Rectangle height
     * @returns {string} 'top', 'bottom', 'left', or 'right'
     */
    getEdgeFromPoint(pointX, pointY, centerX, centerY, rectWidth, rectHeight) {
        const halfWidth = rectWidth / 2;
        const halfHeight = rectHeight / 2;

        const dx = pointX - centerX;
        const dy = pointY - centerY;

        // Use same quadrant logic as getOppositeEdgeCenter
        if (Math.abs(dy) * halfWidth < Math.abs(dx) * halfHeight) {
            return dx > 0 ? 'right' : 'left';
        } else {
            return dy > 0 ? 'bottom' : 'top';
        }
    },

    /**
     * Calculate orthogonal routing path with 90-degree turns
     * @param {number} startX - Start point X (arrow start on edge)
     * @param {number} startY - Start point Y (arrow start on edge)
     * @param {string} startEdge - Start edge: 'top', 'bottom', 'left', 'right'
     * @param {number} endX - End point X (arrow end on edge)
     * @param {number} endY - End point Y (arrow end on edge)
     * @param {string} endEdge - End edge: 'top', 'bottom', 'left', 'right'
     * @param {number} startNodeX - Start node center X (for alignment detection)
     * @param {number} startNodeY - Start node center Y (for alignment detection)
     * @param {number} endNodeX - End node center X (for alignment detection)
     * @param {number} endNodeY - End node center Y (for alignment detection)
     * @returns {Array<{x: number, y: number}>} Array of waypoints
     */
    calculateOrthogonalPath(startX, startY, startEdge, endX, endY, endEdge, startNodeX, startNodeY, endNodeX, endNodeY) {
        const waypoints = [];

        // Always start at source
        waypoints.push({ x: startX, y: startY });

        const dx = endX - startX;
        const dy = endY - startY;
        const alignmentThreshold = 5; // Consider aligned if within 5px

        // Check if NODES are aligned (not arrow endpoints!)
        const nodesVerticallyAligned = startNodeX !== undefined && endNodeX !== undefined &&
                                       Math.abs(startNodeX - endNodeX) < alignmentThreshold;
        const nodesHorizontallyAligned = startNodeY !== undefined && endNodeY !== undefined &&
                                         Math.abs(startNodeY - endNodeY) < alignmentThreshold;

        // Calculate based on edge directions
        if (startEdge === 'right' || startEdge === 'left') {
            // Horizontal exit

            // If nodes are horizontally aligned (same Y), just draw a straight line!
            if (nodesHorizontallyAligned) {
                // Straight horizontal arrow - no turns needed
                // (waypoints already has start, will add end below)
            } else if (nodesVerticallyAligned) {
                // Nodes vertically aligned - need to route around
                const direction = startEdge === 'right' ? 1 : -1;
                const offset = 60 * direction;
                waypoints.push({ x: startX + offset, y: startY });
                waypoints.push({ x: startX + offset, y: endY });
            } else {
                // Normal case: 2 turns at midpoint
                const midX = startX + dx / 2;
                waypoints.push({ x: midX, y: startY });
                waypoints.push({ x: midX, y: endY });
            }

        } else {
            // Vertical exit (top or bottom)

            // If nodes are vertically aligned (same X), just draw a straight line!
            if (nodesVerticallyAligned) {
                // Straight vertical arrow - no turns needed
                // (waypoints already has start, will add end below)
            } else if (nodesHorizontallyAligned) {
                // Nodes horizontally aligned - need to route around
                const direction = startEdge === 'bottom' ? 1 : -1;
                const offset = 60 * direction;
                waypoints.push({ x: startX, y: startY + offset });
                waypoints.push({ x: endX, y: startY + offset });
            } else {
                // Normal case: 2 turns at midpoint
                const midY = startY + dy / 2;
                waypoints.push({ x: startX, y: midY });
                waypoints.push({ x: endX, y: midY });
            }
        }

        // Always end at target
        waypoints.push({ x: endX, y: endY });

        return waypoints;
    },

    /**
     * Get edge center based on direction from target to source
     * Uses simple dominant-axis approach: whichever direction (horizontal/vertical)
     * has greater distance determines which edge to use
     *
     * @param {number} sourceX - Source X position
     * @param {number} sourceY - Source Y position
     * @param {number} targetX - Target center X
     * @param {number} targetY - Target center Y
     * @param {number} rectWidth - Target rectangle width
     * @param {number} rectHeight - Target rectangle height
     * @returns {{x: number, y: number}} Center point of appropriate edge
     */
    getOppositeEdgeCenter(sourceX, sourceY, targetX, targetY, rectWidth, rectHeight) {
        const halfWidth = rectWidth / 2;
        const halfHeight = rectHeight / 2;

        // Calculate direction from target to source
        const dx = sourceX - targetX;
        const dy = sourceY - targetY;

        // Pick edge based on dominant axis
        // Use absolute values to determine which direction is stronger
        if (Math.abs(dx) > Math.abs(dy)) {
            // Horizontal direction dominates
            if (dx > 0) {
                // Source is to the right
                return { x: targetX + halfWidth, y: targetY };
            } else {
                // Source is to the left
                return { x: targetX - halfWidth, y: targetY };
            }
        } else {
            // Vertical direction dominates
            if (dy > 0) {
                // Source is below
                return { x: targetX, y: targetY + halfHeight };
            } else {
                // Source is above
                return { x: targetX, y: targetY - halfHeight };
            }
        }
    },

    /**
     * Get arrow endpoint position (uses custom attach point if exists)
     * This is the key function that checks for customization
     *
     * @param {object} sourceTask - Source task (parent)
     * @param {object} targetTask - Target task (child)
     * @param {string} type - 'source' or 'target'
     * @returns {{x: number, y: number}} Endpoint position
     */
    getArrowEndpoint(sourceTask, targetTask, type) {
        // DEFENSIVE: Validate inputs
        if (!sourceTask || !targetTask) {
            console.warn('[getArrowEndpoint] Missing task:', { sourceTask, targetTask });
            return { x: 0, y: 0 };
        }

        if (type === 'target') {
            const targetDims = this.calculateTaskDimensions(targetTask);

            // Check for custom attach point on target task
            const customPoint = targetTask.customAttachPoints?.[sourceTask.id];

            if (customPoint) {
                // Use custom position
                return this.denormalizeEdgePosition(
                    customPoint.edge,
                    customPoint.normalized,
                    targetTask.x,
                    targetTask.y,
                    targetDims.width,
                    targetDims.height
                );
            } else {
                // Use default calculation based on setting
                if (this.arrowOppositeEdge) {
                    // New behavior: land on edge center facing source
                    return this.getOppositeEdgeCenter(
                        sourceTask.x, sourceTask.y,
                        targetTask.x, targetTask.y,
                        targetDims.width, targetDims.height
                    );
                } else {
                    // Original behavior: land on nearest edge
                    return this.getLineEndAtRectEdge(
                        sourceTask.x, sourceTask.y,
                        targetTask.x, targetTask.y,
                        targetDims.width, targetDims.height
                    );
                }
            }
        } else {
            // Source end
            const sourceDims = this.calculateTaskDimensions(sourceTask);

            // Check for custom source point
            const customPoint = sourceTask.customSourcePoints?.[targetTask.id];

            if (customPoint) {
                // Use custom position
                return this.denormalizeEdgePosition(
                    customPoint.edge,
                    customPoint.normalized,
                    sourceTask.x,
                    sourceTask.y,
                    sourceDims.width,
                    sourceDims.height
                );
            } else {
                // Use default calculation based on setting
                if (this.arrowOppositeEdge) {
                    // New behavior: start from edge center facing target
                    return this.getOppositeEdgeCenter(
                        targetTask.x, targetTask.y,
                        sourceTask.x, sourceTask.y,
                        sourceDims.width, sourceDims.height
                    );
                } else {
                    // Original behavior: start from center of source
                    return { x: sourceTask.x, y: sourceTask.y };
                }
            }
        }
    },

    /**
     * Start dragging arrow dot
     * Called from onCanvasMouseDown when clicking on hoveredArrowDot
     *
     * @param {object} dotInfo - Dot information {type, taskId, parentId, childId}
     */
    startArrowDotDrag(dotInfo) {
        if (!dotInfo) return;

        // Save snapshot for undo
        this.saveSnapshot(`Adjust arrow position`);

        // Get current task
        const task = this.tasks.find(t => t.id === dotInfo.taskId);
        if (!task) return;

        // PERF: Cache task dimensions for entire drag session
        const cachedDims = this.calculateTaskDimensions(task);

        // PERF: Pre-calculate snap positions (only once at drag start)
        const cachedSnapPositions = this.getSnapPositions(task.x, task.y, cachedDims.width, cachedDims.height);

        // Get current position (custom or default)
        let currentEdge, currentNormalized;

        if (dotInfo.type === 'target') {
            // Target dot: dragging arrowhead on child node
            const customPoint = task.customAttachPoints?.[dotInfo.parentId];
            if (customPoint) {
                currentEdge = customPoint.edge;
                currentNormalized = customPoint.normalized;
            } else {
                // Calculate current default position
                const parent = this.tasks.find(t => t.id === dotInfo.parentId);
                if (!parent) return;

                const endPos = this.getLineEndAtRectEdge(
                    parent.x, parent.y,
                    task.x, task.y,
                    cachedDims.width, cachedDims.height
                );

                // Convert to edge + normalized
                const constrained = this.constrainToRectEdge(
                    endPos.x, endPos.y,
                    task.x, task.y,
                    cachedDims.width, cachedDims.height
                );
                currentEdge = constrained.edge;
                currentNormalized = constrained.normalized;
            }
        } else if (dotInfo.type === 'source') {
            // Source dot: dragging arrow start on parent node
            const customPoint = task.customSourcePoints?.[dotInfo.childId];
            if (customPoint) {
                currentEdge = customPoint.edge;
                currentNormalized = customPoint.normalized;
            } else {
                // Calculate current default position
                const child = this.tasks.find(t => t.id === dotInfo.childId);
                if (!child) return;

                const startPos = this.getOppositeEdgeCenter(
                    child.x, child.y,
                    task.x, task.y,
                    cachedDims.width, cachedDims.height
                );

                // Convert to edge + normalized
                const constrained = this.constrainToRectEdge(
                    startPos.x, startPos.y,
                    task.x, task.y,
                    cachedDims.width, cachedDims.height
                );
                currentEdge = constrained.edge;
                currentNormalized = constrained.normalized;
            }
        }

        // Set drag state with cached values
        this.arrowDotDrag = {
            active: true,
            dotType: dotInfo.type,
            taskId: dotInfo.taskId,
            relatedTaskId: dotInfo.type === 'target' ? dotInfo.parentId : dotInfo.childId,
            edge: currentEdge,
            normalized: currentNormalized,
            lastRenderTime: 0,
            // PERF: Cache expensive calculations
            cachedDims: cachedDims,
            cachedSnapPositions: cachedSnapPositions,
            rafPending: false  // For RAF throttling
        };

        // GPU ACCEL: Add class to arrow link for GPU acceleration
        // For source dots, the arrow is from taskId (parent) to childId
        // For target dots, the arrow is from parentId to taskId (child)
        const parentId = dotInfo.type === 'source' ? dotInfo.taskId : dotInfo.parentId;
        const childId = dotInfo.type === 'source' ? dotInfo.childId : dotInfo.taskId;
        const arrowSelector = `.parent-visible[data-task-id="${childId}"][data-parent-id="${parentId}"]`;
        const arrowLine = document.querySelector(arrowSelector);
        if (arrowLine) {
            arrowLine.classList.add('dragging-arrow');
        }

        // Update cursor
        const canvasContainer = document.getElementById('canvas-container');
        canvasContainer.style.cursor = 'grabbing';
    },

    /**
     * Update arrow dot drag position
     * Called from onCanvasMouseMove during drag
     *
     * @param {number} mouseX - Mouse X in SVG coordinates
     * @param {number} mouseY - Mouse Y in SVG coordinates
     */
    updateArrowDotDrag(mouseX, mouseY) {
        if (!this.arrowDotDrag.active) return;

        // DEFENSIVE: Validate inputs
        if (!isFinite(mouseX) || !isFinite(mouseY)) return;

        const task = this.tasks.find(t => t.id === this.arrowDotDrag.taskId);
        if (!task) return;

        // PERF: Use cached dimensions instead of recalculating
        const dims = this.arrowDotDrag.cachedDims;

        // Constrain mouse to rectangle edge
        const constrained = this.constrainToRectEdge(
            mouseX, mouseY,
            task.x, task.y,
            dims.width, dims.height
        );

        // PERF: Use cached snap positions
        const snap = this.findNearestSnap(
            constrained,
            this.arrowDotDrag.cachedSnapPositions,
            task.x, task.y,
            dims.width, dims.height,
            this.arrowSnapThreshold
        );

        // Update drag state
        if (snap) {
            this.arrowDotDrag.edge = snap.edge;
            this.arrowDotDrag.normalized = snap.normalized;
        } else {
            this.arrowDotDrag.edge = constrained.edge;
            this.arrowDotDrag.normalized = constrained.normalized;
        }

        // PERF: Use RAF to batch updates (max 60fps instead of 100+)
        if (!this.arrowDotDrag.rafPending) {
            this.arrowDotDrag.rafPending = true;
            requestAnimationFrame(() => {
                this.arrowDotDrag.rafPending = false;
                // PERF: Partial render - only update dot and arrow, not entire canvas
                this.renderArrowDotDragVisuals();
            });
        }
    },

    /**
     * PERF: Partial render for arrow dot drag - only update dot and arrow line
     * This avoids re-rendering the entire canvas on every mousemove
     */
    renderArrowDotDragVisuals() {
        if (!this.arrowDotDrag.active) return;

        const task = this.tasks.find(t => t.id === this.arrowDotDrag.taskId);
        if (!task) return;

        const relatedTask = this.tasks.find(t => t.id === this.arrowDotDrag.relatedTaskId);
        if (!relatedTask) return;

        const dims = this.arrowDotDrag.cachedDims;

        // Calculate current dot position from live drag state
        const dotPos = this.denormalizeEdgePosition(
            this.arrowDotDrag.edge,
            this.arrowDotDrag.normalized,
            task.x, task.y,
            dims.width, dims.height
        );

        // Find and update existing arrow dot element (or create if missing)
        let dotElement = document.querySelector('.arrow-dot');
        if (!dotElement) {
            // Fallback: full render if dot doesn't exist
            this.render();
            return;
        }

        // Update dot position (faster than recreating)
        dotElement.setAttribute('cx', dotPos.x);
        dotElement.setAttribute('cy', dotPos.y);
        dotElement.setAttribute('r', this.arrowDotDragSize || 7);

        // Determine color based on whether position is custom and dot type
        let hasCustomPosition;
        if (this.arrowDotDrag.dotType === 'source') {
            hasCustomPosition = !!(task.customSourcePoints && task.customSourcePoints[this.arrowDotDrag.relatedTaskId]);
        } else {
            hasCustomPosition = !!(task.customAttachPoints && task.customAttachPoints[this.arrowDotDrag.relatedTaskId]);
        }
        dotElement.setAttribute('fill', hasCustomPosition ? '#2196f3' : '#4caf50');

        // Find and update arrow line
        // For source dots: arrow is from taskId (parent) to relatedTaskId (child)
        // For target dots: arrow is from relatedTaskId (parent) to taskId (child)
        const parentId = this.arrowDotDrag.dotType === 'source' ? this.arrowDotDrag.taskId : this.arrowDotDrag.relatedTaskId;
        const childId = this.arrowDotDrag.dotType === 'source' ? this.arrowDotDrag.relatedTaskId : this.arrowDotDrag.taskId;
        const arrowSelector = `.parent-visible[data-task-id="${childId}"][data-parent-id="${parentId}"]`;
        const arrowLine = document.querySelector(arrowSelector);

        if (arrowLine) {
            // Update arrow to match dot
            // All arrows are <path> elements (created by createMultiSegmentCurvedLine)
            if (arrowLine.tagName === 'path') {
                // Get the OTHER end of the arrow (the one we're NOT dragging)
                let arrowStart, arrowEnd;
                const parentTask = this.tasks.find(t => t.id === parentId);
                const childTask = this.tasks.find(t => t.id === childId);

                if (this.arrowDotDrag.dotType === 'source') {
                    // Dragging source dot - start is what we're dragging, end is fixed
                    arrowStart = dotPos;
                    arrowEnd = this.getArrowEndpoint(parentTask, childTask, 'target');
                } else {
                    // Dragging target dot - start is fixed, end is what we're dragging
                    arrowStart = this.getArrowEndpoint(parentTask, childTask, 'source');
                    arrowEnd = dotPos;
                }

                // Get control points for this arrow (stored on child task)
                const controlPoints = childTask.curveControlPoints?.[parentId];

                // Check if we're also dragging curve control points
                const isDraggingThisCurve = this.curveDotDrag.active &&
                                            this.curveDotDrag.taskId === childId &&
                                            this.curveDotDrag.parentId === parentId;
                const effectiveControlPoints = isDraggingThisCurve ?
                    this.curveDotDrag.controlPoints : controlPoints;

                // Recreate the path with new endpoints
                if (effectiveControlPoints && effectiveControlPoints.length > 0) {
                    // Multi-segment curve - use Catmull-Rom spline
                    const points = [
                        { x: arrowStart.x, y: arrowStart.y },
                        ...effectiveControlPoints,
                        { x: arrowEnd.x, y: arrowEnd.y }
                    ];

                    let pathData = `M ${points[0].x} ${points[0].y}`;
                    for (let i = 0; i < points.length - 1; i++) {
                        const p0 = points[Math.max(0, i - 1)];
                        const p1 = points[i];
                        const p2 = points[i + 1];
                        const p3 = points[Math.min(points.length - 1, i + 2)];

                        const c1x = p1.x + (p2.x - p0.x) / 6;
                        const c1y = p1.y + (p2.y - p0.y) / 6;
                        const c2x = p2.x - (p3.x - p1.x) / 6;
                        const c2y = p2.y - (p3.y - p1.y) / 6;

                        pathData += ` C ${c1x} ${c1y}, ${c2x} ${c2y}, ${p2.x} ${p2.y}`;
                    }
                    arrowLine.setAttribute('d', pathData);
                } else {
                    // Straight line - simple path
                    arrowLine.setAttribute('d', `M ${arrowStart.x} ${arrowStart.y} L ${arrowEnd.x} ${arrowEnd.y}`);
                }
            }
        }

        // Update snap indicators
        const snapGroup = document.getElementById('snap-indicators-group');
        if (snapGroup) {
            // Clear old indicators
            snapGroup.innerHTML = '';

            // Render new snap indicators
            const indicators = this.renderSnapIndicators(
                task.x, task.y,
                dims.width, dims.height,
                this.arrowDotDrag.edge,
                this.arrowDotDrag.normalized
            );

            indicators.forEach(indicator => snapGroup.appendChild(indicator));
        }
    },

    /**
     * Finish arrow dot drag and commit changes
     * Called from onCanvasMouseUp
     */
    finishArrowDotDrag() {
        if (!this.arrowDotDrag.active) return;

        const task = this.tasks.find(t => t.id === this.arrowDotDrag.taskId);
        if (!task) {
            this.cancelArrowDotDrag();
            return;
        }

        // Save custom position based on dot type (with timestamp for prioritization)
        if (this.arrowDotDrag.dotType === 'target') {
            // Target dot: save to customAttachPoints (arrow endpoint on child)
            if (!task.customAttachPoints) {
                task.customAttachPoints = {};
            }
            task.customAttachPoints[this.arrowDotDrag.relatedTaskId] = {
                edge: this.arrowDotDrag.edge,
                normalized: this.arrowDotDrag.normalized,
                timestamp: Date.now()  // For prioritization when overlapping
            };
        } else if (this.arrowDotDrag.dotType === 'source') {
            // Source dot: save to customSourcePoints (arrow start on parent)
            if (!task.customSourcePoints) {
                task.customSourcePoints = {};
            }
            task.customSourcePoints[this.arrowDotDrag.relatedTaskId] = {
                edge: this.arrowDotDrag.edge,
                normalized: this.arrowDotDrag.normalized,
                timestamp: Date.now()  // For prioritization when overlapping
            };
        }

        // GPU ACCEL: Remove dragging-arrow class
        // For source dots, the arrow is from taskId (parent) to relatedTaskId (child)
        // For target dots, the arrow is from relatedTaskId (parent) to taskId (child)
        const parentId = this.arrowDotDrag.dotType === 'source' ? this.arrowDotDrag.taskId : this.arrowDotDrag.relatedTaskId;
        const childId = this.arrowDotDrag.dotType === 'source' ? this.arrowDotDrag.relatedTaskId : this.arrowDotDrag.taskId;
        const arrowSelector = `.parent-visible[data-task-id="${childId}"][data-parent-id="${parentId}"]`;
        const arrowLine = document.querySelector(arrowSelector);
        if (arrowLine) {
            arrowLine.classList.remove('dragging-arrow');
        }

        // Clear drag state
        this.arrowDotDrag = {
            active: false,
            dotType: null,
            taskId: null,
            relatedTaskId: null,
            edge: null,
            normalized: 0.5,
            lastRenderTime: 0
        };

        // Update cursor
        const canvasContainer = document.getElementById('canvas-container');
        canvasContainer.style.cursor = 'default';

        // Save and render
        this.saveToStorage();
        this.render();

        this.showToast('Arrow position updated', 'success', 2000);
    },

    /**
     * Cancel arrow dot drag without saving
     */
    cancelArrowDotDrag() {
        // GPU ACCEL: Remove dragging-arrow class if exists
        if (this.arrowDotDrag.taskId && this.arrowDotDrag.relatedTaskId) {
            // For source dots: arrow is from taskId (parent) to relatedTaskId (child)
            // For target dots: arrow is from relatedTaskId (parent) to taskId (child)
            const parentId = this.arrowDotDrag.dotType === 'source' ? this.arrowDotDrag.taskId : this.arrowDotDrag.relatedTaskId;
            const childId = this.arrowDotDrag.dotType === 'source' ? this.arrowDotDrag.relatedTaskId : this.arrowDotDrag.taskId;
            const arrowSelector = `.parent-visible[data-task-id="${childId}"][data-parent-id="${parentId}"]`;
            const arrowLine = document.querySelector(arrowSelector);
            if (arrowLine) {
                arrowLine.classList.remove('dragging-arrow');
            }
        }

        this.arrowDotDrag = {
            active: false,
            dotType: null,
            taskId: null,
            relatedTaskId: null,
            edge: null,
            normalized: 0.5,
            lastRenderTime: 0
        };

        const canvasContainer = document.getElementById('canvas-container');
        canvasContainer.style.cursor = 'default';

        this.render();
    },

    /**
     * Update timestamp for a specific arrow (both source and target endpoints)
     * Used when selecting an arrow or moving a connected node
     *
     * @param {number} childId - Child task ID
     * @param {number} parentId - Parent task ID
     */
    updateArrowTimestamp(childId, parentId) {
        const child = this.tasks.find(t => t.id === childId);
        const parent = this.tasks.find(t => t.id === parentId);

        if (!child || !parent) return;

        const timestamp = Date.now();

        // Update target endpoint (arrow landing on child)
        if (child.customAttachPoints && child.customAttachPoints[parentId]) {
            child.customAttachPoints[parentId].timestamp = timestamp;
        }

        // Update source endpoint (arrow starting from parent)
        if (parent.customSourcePoints && parent.customSourcePoints[childId]) {
            parent.customSourcePoints[childId].timestamp = timestamp;
        }
    },

    /**
     * Update timestamps for all arrows connected to a node
     * Used when moving a node to prioritize its arrows
     *
     * @param {number} taskId - Task ID that was moved
     */
    updateConnectedArrowsTimestamps(taskId) {
        const task = this.tasks.find(t => t.id === taskId);
        if (!task) return;

        const timestamp = Date.now();

        // Update all parent arrows (arrows coming INTO this node)
        const allParents = [task.mainParent, ...(task.otherParents || [])].filter(p => p !== null);
        for (const parentId of allParents) {
            const parent = this.tasks.find(t => t.id === parentId);
            if (!parent) continue;

            // Update target endpoint on child
            if (task.customAttachPoints && task.customAttachPoints[parentId]) {
                task.customAttachPoints[parentId].timestamp = timestamp;
            }

            // Update source endpoint on parent
            if (parent.customSourcePoints && parent.customSourcePoints[taskId]) {
                parent.customSourcePoints[taskId].timestamp = timestamp;
            }
        }

        // Update all child arrows (arrows going OUT from this node)
        for (const childId of task.children || []) {
            const child = this.tasks.find(t => t.id === childId);
            if (!child) continue;

            // Update target endpoint on child
            if (child.customAttachPoints && child.customAttachPoints[taskId]) {
                child.customAttachPoints[taskId].timestamp = timestamp;
            }

            // Update source endpoint on this node
            if (task.customSourcePoints && task.customSourcePoints[childId]) {
                task.customSourcePoints[childId].timestamp = timestamp;
            }
        }
    },

    /**
     * Reset arrow to default position (double-click or context menu)
     *
     * @param {object} dotInfo - Dot information {type, taskId, parentId, childId}
     */
    resetArrowPosition(dotInfo) {
        if (!dotInfo) return;

        this.saveSnapshot(`Reset arrow position`);

        const task = this.tasks.find(t => t.id === dotInfo.taskId);
        if (!task) return;

        if (dotInfo.type === 'target') {
            // Remove custom attach point (child-side)
            if (task.customAttachPoints && task.customAttachPoints[dotInfo.parentId]) {
                delete task.customAttachPoints[dotInfo.parentId];

                this.saveToStorage();
                this.render();

                this.showToast('Arrow position reset', 'success', 2000);
            }
        } else if (dotInfo.type === 'source') {
            // Remove custom source point (parent-side)
            if (task.customSourcePoints && task.customSourcePoints[dotInfo.childId]) {
                delete task.customSourcePoints[dotInfo.childId];

                this.saveToStorage();
                this.render();

                this.showToast('Arrow position reset', 'success', 2000);
            }
        }
    }
});



// ============================================================
// INTERACTIONS/EDIT.JS (Order: 28, Category: interactions)
// ============================================================

/**
 * @module interactions/edit
 * @order 28
 * @category interactions
 *
 * Inline text editing for task nodes
 */

Object.assign(app, {
    startEditing(taskId) {
        this.editingTaskId = taskId;
        this.render();

        // Focus the input after render
        setTimeout(() => {
            const input = document.getElementById('edit-input');
            if (input) {
                input.focus();
                input.select();
            }
        }, 10);
    },

    finishEditing(save = true) {
        if (this.editingTaskId === null) return;

        if (save) {
            const input = document.getElementById('edit-input');
            if (input) {
                const task = this.tasks.find(t => t.id === this.editingTaskId);
                if (task) {
                    // Preserve all whitespace (tabs, spaces, newlines) - don't trim
                    let newTitle = input.value || 'Untitled';

                    // Extract URLs from text and add to links array
                    const foundURLs = this.extractURLsFromText(newTitle);
                    if (foundURLs.length > 0) {
                        // Initialize links array if doesn't exist
                        if (!task.links) task.links = [];

                        // Add new links (avoid duplicates)
                        let newLinksCount = 0;
                        foundURLs.forEach(url => {
                            if (this.isValidURL(url) && !task.links.includes(url)) {
                                task.links.push(url);
                                newLinksCount++;
                            }
                        });

                        // Remove URLs from visible text
                        newTitle = this.removeURLsFromText(newTitle) || 'Untitled';

                        // Show toast notification
                        if (newLinksCount > 0) {
                            const plural = newLinksCount > 1 ? 's' : '';
                            this.showToast(`üîó Added ${newLinksCount} link${plural}`, 'success', 3000);
                        }
                    }

                    // Save snapshot with 2-second grouping for edits to same task
                    const truncatedTitle = newTitle.length > 30 ? newTitle.substring(0, 27) + '...' : newTitle;
                    this.saveSnapshot(`Edited task '${truncatedTitle}'`, this.editingTaskId);
                    task.title = newTitle;

                    // PERF: Invalidate dimension cache since title changed
                    this.invalidateDimensionCache(this.editingTaskId);
                }
            }
        }

        this.editingTaskId = null;
        this.saveToStorage();
        this.updateStatusBar();
        this.render();
    },

    resizeEditingBox() {
        // Dynamically resize the editing textarea and its container rectangle
        // Called on every keystroke (oninput event) during editing

        if (this.editingTaskId === null) return;

        const textarea = document.getElementById('edit-input');
        if (!textarea) return;

        // Get current text from textarea
        const currentText = textarea.value || '';

        // Calculate new dimensions based on current text
        const { width: rectWidth, height: rectHeight, lines } = this.calculateTextBoxDimensions(currentText);

        // Find the task node and its child elements
        const taskNode = document.querySelector(`.task-node[data-id="${this.editingTaskId}"]`);
        if (!taskNode) return;

        const rect = taskNode.querySelector('rect');
        const foreignObject = taskNode.querySelector('foreignObject');

        if (!rect || !foreignObject) return;

        // Update rectangle dimensions (centered at 0,0)
        rect.setAttribute('x', -rectWidth / 2);
        rect.setAttribute('y', -rectHeight / 2);
        rect.setAttribute('width', rectWidth);
        rect.setAttribute('height', rectHeight);

        // Update foreignObject (container for textarea)
        foreignObject.setAttribute('x', -rectWidth / 2);
        foreignObject.setAttribute('y', -rectHeight / 2 + 5);
        foreignObject.setAttribute('width', rectWidth);
        foreignObject.setAttribute('height', rectHeight - 10);

        // Update textarea rows for better UX
        textarea.rows = Math.max(2, lines.length);
    }
});



// ============================================================
// INTERACTIONS/CURVE-CONTROL.JS (Order: 29, Category: interactions)
// ============================================================

/**
 * @module interactions/curve-control-v2
 * @order 29
 * @category interactions
 *
 * Miro-style bezier curve control for links
 * Simple, professional multi-point curve editing
 */

Object.assign(app, {
    /**
     * Setup curve control listeners
     */
    setupCurveControlListeners() {
        console.log('‚úì Curve control v2 listeners setup');
    },

    /**
     * Check if mouse is near any curve and update hover state
     * Shows control point dots when hovering over curved lines
     */
    updateCurveDotHover(mouseX, mouseY) {
        // Skip if editing or dragging
        if (this.editingTaskId !== null || this.dragMode !== null || this.arrowDotDrag.active) {
            this.hoveredCurveDot = null;
            return;
        }

        if (!isFinite(mouseX) || !isFinite(mouseY)) {
            return;
        }

        // Find nearby curve
        const result = this.findCurveNearMouse(mouseX, mouseY);

        if (result !== this.hoveredCurveDot) {
            this.hoveredCurveDot = result;
            // Always render when hover state changes (to show OR hide dots)
            this.render();
        }
    },

    /**
     * Find curve near mouse and determine interaction type
     * Returns: { taskId, parentId, controlPoints: [...], nearestPointIndex, addNewPoint, mouseX, mouseY }
     */
    findCurveNearMouse(mouseX, mouseY) {
        const hoverRadius = 30;
        const controlPointSnapRadius = 15;

        // Check all parent links
        for (const task of this.tasks) {
            if (task.hidden) continue;

            // Check main parent
            if (task.mainParent !== null) {
                const parent = this.tasks.find(t => t.id === task.mainParent);
                if (!parent || parent.hidden) continue;

                const result = this.checkCurveProximity(
                    mouseX, mouseY,
                    parent, task, task.mainParent,
                    hoverRadius, controlPointSnapRadius
                );
                if (result) return result;
            }

            // Check other parents
            for (const parentId of task.otherParents || []) {
                const parent = this.tasks.find(t => t.id === parentId);
                if (!parent || parent.hidden) continue;

                const result = this.checkCurveProximity(
                    mouseX, mouseY,
                    parent, task, parentId,
                    hoverRadius, controlPointSnapRadius
                );
                if (result) return result;
            }
        }

        return null;
    },

    /**
     * Check if mouse is near a specific link's curve
     */
    checkCurveProximity(mouseX, mouseY, parent, task, parentId, hoverRadius, snapRadius) {
        const arrowEnd = this.getArrowEndpoint(parent, task, 'target');

        // Get control points for this link
        const controlPoints = this.getCurvePoints(task.id, parentId);

        // Build complete curve path (start -> control points -> end)
        const curvePath = [
            { x: parent.x, y: parent.y },
            ...controlPoints,
            { x: arrowEnd.x, y: arrowEnd.y }
        ];

        // Check if near existing control point first (priority)
        for (let i = 0; i < controlPoints.length; i++) {
            const cp = controlPoints[i];
            const dist = Math.sqrt((mouseX - cp.x) ** 2 + (mouseY - cp.y) ** 2);
            if (dist < snapRadius) {
                return {
                    taskId: task.id,
                    parentId: parentId,
                    controlPoints: controlPoints,
                    nearestPointIndex: i,
                    addNewPoint: false,
                    mouseX: mouseX,
                    mouseY: mouseY
                };
            }
        }

        // Check if near the curve itself
        if (this.isNearCurvePath(mouseX, mouseY, curvePath, hoverRadius)) {
            // Find closest point on curve to add new control point
            const closest = this.findClosestPointOnCurvePath(mouseX, mouseY, curvePath);

            // Don't show curve control point if near arrow endpoints
            // (those areas are for arrow snap dots, not curve control)
            const distToStart = Math.sqrt((mouseX - parent.x) ** 2 + (mouseY - parent.y) ** 2);
            const distToEnd = Math.sqrt((mouseX - arrowEnd.x) ** 2 + (mouseY - arrowEnd.y) ** 2);
            const endpointExclusionRadius = 30; // Same as hoverRadius

            if (distToStart < endpointExclusionRadius || distToEnd < endpointExclusionRadius) {
                // Too close to endpoints - don't show curve control dot
                return null;
            }

            // Calculate insertion index:
            // curvePath = [parent, ...controlPoints, child]
            // segmentIndex 0 = parent->first control point (insert at index 0)
            // segmentIndex 1 = first->second control point (insert at index 1)
            // etc.
            const insertIndex = closest.segmentIndex;

            return {
                taskId: task.id,
                parentId: parentId,
                controlPoints: controlPoints,
                nearestPointIndex: null,
                addNewPoint: true,
                insertIndex: insertIndex,  // NEW: where to insert in controlPoints array
                mouseX: closest.x,
                mouseY: closest.y
            };
        }

        return null;
    },

    /**
     * Get control points for a link
     * Returns array of {x, y} points ON the curve
     */
    getCurvePoints(taskId, parentId) {
        const task = this.tasks.find(t => t.id === taskId);
        if (!task || !task.curveControlPoints) return [];

        const points = task.curveControlPoints[parentId];
        if (!points || !Array.isArray(points)) return [];

        // Return just x, y coordinates
        return points.map(p => ({ x: p.x, y: p.y }));
    },

    /**
     * Check if mouse is near curve path
     * Samples along Catmull-Rom spline
     */
    isNearCurvePath(mouseX, mouseY, points, radius) {
        if (points.length < 2) return false;

        const radiusSquared = radius * radius;
        const samples = 50;

        // Sample along curve
        for (let i = 0; i < points.length - 1; i++) {
            for (let s = 0; s <= samples; s++) {
                const t = s / samples;
                const p = this.sampleCatmullRom(points, i, t);

                const dx = mouseX - p.x;
                const dy = mouseY - p.y;
                if (dx * dx + dy * dy < radiusSquared) {
                    return true;
                }
            }
        }

        return false;
    },

    /**
     * Find closest point on curve path to mouse
     * Returns { x, y, segmentIndex } where segmentIndex indicates which segment (0 to points.length-2)
     */
    findClosestPointOnCurvePath(mouseX, mouseY, points) {
        if (points.length < 2) return { x: mouseX, y: mouseY, segmentIndex: 0 };

        let closest = null;
        let minDist = Infinity;
        let closestSegment = 0;
        const samples = 50;

        for (let i = 0; i < points.length - 1; i++) {
            for (let s = 0; s <= samples; s++) {
                const t = s / samples;
                const p = this.sampleCatmullRom(points, i, t);

                const dx = mouseX - p.x;
                const dy = mouseY - p.y;
                const dist = dx * dx + dy * dy;

                if (dist < minDist) {
                    minDist = dist;
                    closest = p;
                    closestSegment = i;
                }
            }
        }

        return { ...closest, segmentIndex: closestSegment };
    },

    /**
     * Sample point on Catmull-Rom curve at segment i, parameter t
     */
    sampleCatmullRom(points, segmentIndex, t) {
        const p0 = points[Math.max(0, segmentIndex - 1)];
        const p1 = points[segmentIndex];
        const p2 = points[segmentIndex + 1];
        const p3 = points[Math.min(points.length - 1, segmentIndex + 2)];

        // Catmull-Rom to Bezier conversion
        const c1x = p1.x + (p2.x - p0.x) / 6;
        const c1y = p1.y + (p2.y - p0.y) / 6;
        const c2x = p2.x - (p3.x - p1.x) / 6;
        const c2y = p2.y - (p3.y - p1.y) / 6;

        // Cubic bezier evaluation
        const t2 = t * t;
        const t3 = t2 * t;
        const mt = 1 - t;
        const mt2 = mt * mt;
        const mt3 = mt2 * mt;

        return {
            x: mt3 * p1.x + 3 * mt2 * t * c1x + 3 * mt * t2 * c2x + t3 * p2.x,
            y: mt3 * p1.y + 3 * mt2 * t * c1y + 3 * mt * t2 * c2y + t3 * p2.y
        };
    },

    /**
     * Start dragging a curve control point
     */
    startCurveDotDrag(hoverInfo) {
        if (!hoverInfo) return;

        this.saveSnapshot('Adjust curve');

        this.curveDotDrag = {
            active: true,
            taskId: hoverInfo.taskId,
            parentId: hoverInfo.parentId,
            controlPoints: [...hoverInfo.controlPoints], // Copy array
            editingIndex: hoverInfo.nearestPointIndex,
            isNewPoint: hoverInfo.addNewPoint,
            initialX: hoverInfo.mouseX,
            initialY: hoverInfo.mouseY
        };

        // If adding new point, insert it at the correct position
        if (hoverInfo.addNewPoint) {
            const newPoint = {
                x: hoverInfo.mouseX,
                y: hoverInfo.mouseY
            };

            // Insert at the correct position along the curve
            const insertIdx = hoverInfo.insertIndex || 0;
            this.curveDotDrag.controlPoints.splice(insertIdx, 0, newPoint);
            this.curveDotDrag.editingIndex = insertIdx;
        }

        const canvasContainer = document.getElementById('canvas-container');
        canvasContainer.style.cursor = 'grabbing';
    },

    /**
     * Update curve control point during drag
     */
    updateCurveDotDrag(mouseX, mouseY) {
        if (!this.curveDotDrag.active) return;
        if (!isFinite(mouseX) || !isFinite(mouseY)) return;

        const idx = this.curveDotDrag.editingIndex;
        if (idx !== null && idx >= 0 && idx < this.curveDotDrag.controlPoints.length) {
            this.curveDotDrag.controlPoints[idx] = { x: mouseX, y: mouseY };
        }

        this.render();
    },

    /**
     * Finish curve drag and save
     */
    finishCurveDotDrag() {
        if (!this.curveDotDrag.active) return;

        const task = this.tasks.find(t => t.id === this.curveDotDrag.taskId);
        if (!task) {
            this.cancelCurveDotDrag();
            return;
        }

        // Initialize if needed
        if (!task.curveControlPoints) {
            task.curveControlPoints = {};
        }

        // Check if moved significantly (otherwise remove point)
        const idx = this.curveDotDrag.editingIndex;
        const pt = this.curveDotDrag.controlPoints[idx];
        const dist = Math.sqrt(
            (pt.x - this.curveDotDrag.initialX) ** 2 +
            (pt.y - this.curveDotDrag.initialY) ** 2
        );

        if (this.curveDotDrag.isNewPoint && dist < 5) {
            // New point not moved - cancel
            this.cancelCurveDotDrag();
            return;
        }

        // Save control points
        if (this.curveDotDrag.controlPoints.length === 0) {
            // Remove all control points
            delete task.curveControlPoints[this.curveDotDrag.parentId];
        } else {
            task.curveControlPoints[this.curveDotDrag.parentId] = this.curveDotDrag.controlPoints;
        }

        // Clear state
        this.curveDotDrag = {
            active: false,
            taskId: null,
            parentId: null,
            controlPoints: [],
            editingIndex: null,
            isNewPoint: false,
            initialX: 0,
            initialY: 0,
            lastClickTime: 0,
            lastClickedDotId: null
        };

        const canvasContainer = document.getElementById('canvas-container');
        canvasContainer.style.cursor = 'default';

        this.saveToStorage();
        this.render();

        this.showToast('Curve adjusted', 'success', 2000);
    },

    /**
     * Cancel curve drag
     */
    cancelCurveDotDrag() {
        this.curveDotDrag = {
            active: false,
            taskId: null,
            parentId: null,
            controlPoints: [],
            editingIndex: null,
            isNewPoint: false,
            initialX: 0,
            initialY: 0,
            lastClickTime: 0,
            lastClickedDotId: null
        };

        const canvasContainer = document.getElementById('canvas-container');
        canvasContainer.style.cursor = 'default';

        this.render();
    },

    /**
     * Remove a specific control point from a curve
     * Called on double-click of curve control dot
     *
     * @param {object} linkInfo - {linkType, taskId, relatedTaskId, pointIndex}
     */
    removeControlPoint(linkInfo) {
        if (!linkInfo || !linkInfo.taskId || !linkInfo.relatedTaskId) return;

        const task = this.tasks.find(t => t.id === linkInfo.taskId);
        if (!task || !task.curveControlPoints || !task.curveControlPoints[linkInfo.relatedTaskId]) {
            return;
        }

        const controlPoints = task.curveControlPoints[linkInfo.relatedTaskId];
        const pointIndex = linkInfo.pointIndex;

        // Check if this is a valid existing point (not a preview point)
        if (pointIndex < 0 || pointIndex >= controlPoints.length) {
            return;
        }

        this.saveSnapshot('Remove curve control point');

        // Remove the specific control point
        controlPoints.splice(pointIndex, 1);

        // If no control points left, remove the curve entirely (becomes straight line)
        if (controlPoints.length === 0) {
            delete task.curveControlPoints[linkInfo.relatedTaskId];

            // Clean up empty object
            if (Object.keys(task.curveControlPoints).length === 0) {
                delete task.curveControlPoints;
            }
        }

        this.saveToStorage();
        this.render();

        const message = controlPoints.length === 0 ?
            'Curve reset to straight line' :
            'Control point removed';
        this.showToast(message, 'success', 2000);
    }
});

console.log('[curve-control-v2.js] Miro-style curve control loaded');



// ============================================================
// UI/MODALS.JS (Order: 30, Category: ui)
// ============================================================

/**
 * @module ui/modals
 * @order 30
 * @category ui
 *
 * Modal dialog system (confirm, alert, prompt)
 */

Object.assign(app, {
    showConfirm(title, message, onConfirm) {
        document.getElementById('confirm-title').textContent = title;
        document.getElementById('confirm-message').textContent = message;
        const modal = document.getElementById('confirm-modal');
        modal.classList.add('show');

        const yesBtn = document.getElementById('confirm-yes');
        const noBtn = document.getElementById('confirm-no');

        // Remove old listeners by cloning
        const newYesBtn = yesBtn.cloneNode(true);
        const newNoBtn = noBtn.cloneNode(true);
        yesBtn.replaceWith(newYesBtn);
        noBtn.replaceWith(newNoBtn);

        newYesBtn.onclick = () => {
            this.hideConfirm();
            onConfirm();
        };
        newNoBtn.onclick = () => this.hideConfirm();
    },

    hideConfirm() {
        const modal = document.getElementById('confirm-modal');
        modal.classList.remove('show');
    },

    showAlert(title, message) {
        document.getElementById('alert-title').textContent = title;
        document.getElementById('alert-message').textContent = message;
        const modal = document.getElementById('alert-modal');
        modal.classList.add('show');

        const okBtn = document.getElementById('alert-ok');
        const newOkBtn = okBtn.cloneNode(true);
        okBtn.replaceWith(newOkBtn);

        newOkBtn.onclick = () => this.hideAlert();
    },

    hideAlert() {
        const modal = document.getElementById('alert-modal');
        modal.classList.remove('show');
    },

    showPrompt(title, message, defaultValue, onConfirm) {
        document.getElementById('prompt-title').textContent = title;
        document.getElementById('prompt-message').textContent = message;
        const input = document.getElementById('prompt-input');
        input.value = defaultValue || '';

        const modal = document.getElementById('prompt-modal');
        modal.classList.add('show');

        // Focus input after modal shows
        setTimeout(() => input.focus(), 100);

        // Clone buttons to remove old event listeners
        const okBtn = document.getElementById('prompt-ok');
        const cancelBtn = document.getElementById('prompt-cancel');
        const newOkBtn = okBtn.cloneNode(true);
        const newCancelBtn = cancelBtn.cloneNode(true);
        okBtn.replaceWith(newOkBtn);
        cancelBtn.replaceWith(newCancelBtn);

        newOkBtn.onclick = () => {
            const value = input.value;
            this.hidePrompt();
            if (onConfirm) onConfirm(value);
        };

        newCancelBtn.onclick = () => {
            this.hidePrompt();
        };

        // Enter key submits
        input.onkeydown = (e) => {
            if (e.key === 'Enter') {
                e.preventDefault();
                const value = input.value;
                this.hidePrompt();
                if (onConfirm) onConfirm(value);
            } else if (e.key === 'Escape') {
                e.preventDefault();
                this.hidePrompt();
            }
        };
    },

    hidePrompt() {
        const modal = document.getElementById('prompt-modal');
        modal.classList.remove('show');
    },

    /**
     * Show time tracking history for a specific task
     * @param {number} taskId - ID of the task
     */
    showTimeHistoryModal(taskId) {
        const task = this.tasks.find(t => t.id === taskId);
        if (!task) return;

        const modal = document.getElementById('time-history-modal');
        const content = document.getElementById('time-history-content');

        const timeTracking = task.timeTracking || { totalSeconds: 0, sessions: [] };
        const totalTime = this.formatDuration(timeTracking.totalSeconds);
        const sessionCount = timeTracking.sessions.length;

        // Build content HTML
        let html = `
            <div style="background: #f8f9fa; padding: 16px; border-radius: 8px; margin-bottom: 16px;">
                <h3 style="margin: 0 0 12px 0; color: #333;">${this.getTaskDisplayTitle(task, 50)}</h3>
                <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 12px;">
                    <div>
                        <div style="font-size: 12px; color: #666; margin-bottom: 4px;">Total Time</div>
                        <div style="font-size: 24px; font-weight: bold; color: #4CAF50;">${totalTime}</div>
                    </div>
                    <div>
                        <div style="font-size: 12px; color: #666; margin-bottom: 4px;">Sessions</div>
                        <div style="font-size: 24px; font-weight: bold; color: #2196F3;">${sessionCount}</div>
                    </div>
                </div>
            </div>
        `;

        if (sessionCount === 0) {
            html += `<p style="text-align: center; color: #999; padding: 40px 0;">No time tracked yet for this task.</p>`;
        } else {
            html += `<h4 style="margin: 16px 0 12px 0; color: #333;">Session History</h4>`;
            html += `<div style="display: flex; flex-direction: column; gap: 8px;">`;

            // Show sessions in reverse order (most recent first)
            const sortedSessions = [...timeTracking.sessions].reverse();
            sortedSessions.forEach((session, index) => {
                const duration = this.formatDuration(session.duration);
                const startTime = new Date(session.startTime).toLocaleString();
                const endTime = new Date(session.endTime).toLocaleString();
                const relativeTime = this.formatRelativeTime(session.startTime);

                html += `
                    <div style="background: white; border: 1px solid #e0e0e0; border-radius: 6px; padding: 12px;">
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
                            <span style="font-weight: 600; color: #333;">Session ${sessionCount - index}</span>
                            <span style="font-size: 18px; font-weight: bold; color: #4CAF50;">${duration}</span>
                        </div>
                        <div style="font-size: 12px; color: #666;">
                            <div>Started: ${startTime}</div>
                            <div>Ended: ${endTime}</div>
                            <div style="margin-top: 4px; color: #999;">${relativeTime}</div>
                        </div>
                    </div>
                `;
            });

            html += `</div>`;
        }

        content.innerHTML = html;
        modal.classList.add('show');

        // Close on ESC or click outside
        const closeHandler = (e) => {
            if (e.key === 'Escape' || e.target === modal) {
                this.hideTimeHistoryModal();
                document.removeEventListener('keydown', closeHandler);
                modal.removeEventListener('click', closeHandler);
            }
        };
        document.addEventListener('keydown', closeHandler);
        modal.addEventListener('click', closeHandler);
    },

    /**
     * Hide time history modal
     */
    hideTimeHistoryModal() {
        const modal = document.getElementById('time-history-modal');
        modal.classList.remove('show');
    },

    /**
     * Show emoji picker modal for selecting an icon
     * @param {string} title - Modal title
     * @param {string} currentEmoji - Currently selected emoji
     * @param {function} onConfirm - Callback with selected emoji
     */
    showEmojiPicker(title, currentEmoji, onConfirm) {
        document.getElementById('emoji-picker-title').textContent = title;
        const input = document.getElementById('emoji-custom-input');
        input.value = currentEmoji || '';

        const modal = document.getElementById('emoji-picker-modal');
        modal.classList.add('show');

        // Popular emojis organized by category
        const emojiCategories = {
            'Places & Navigation': ['üè†', 'üè°', 'üè¢', 'üèõÔ∏è', 'üèóÔ∏è', 'üè∞', 'üóº', 'üóΩ', '‚õ™', 'üïå', 'üõï', 'üïç', '‚õ©Ô∏è', 'üóæ', 'üé™', 'üé≠'],
            'Symbols': ['‚≠ê', 'üåü', 'üí´', '‚ú®', 'üî•', 'üí•', '‚ö°', 'üåà', '‚òÄÔ∏è', 'üåô', '‚≠ï', '‚ùå', '‚úÖ', '‚ùó', '‚ùì', 'üíØ'],
            'Arrows & Directions': ['‚û°Ô∏è', '‚¨ÖÔ∏è', '‚¨ÜÔ∏è', '‚¨áÔ∏è', '‚ÜóÔ∏è', '‚ÜòÔ∏è', '‚ÜôÔ∏è', '‚ÜñÔ∏è', 'üîÑ', 'üîÅ', 'üîÄ', 'üîÉ', 'üîÇ', '‚ñ∂Ô∏è', '‚è∏Ô∏è', '‚èπÔ∏è'],
            'Flags & Markers': ['üö©', 'üèÅ', 'üè≥Ô∏è', 'üè¥', 'üéå', 'üéè', 'üìç', 'üìå', 'üìé', 'üîñ', 'üè∑Ô∏è', 'üíº', 'üóÇÔ∏è', 'üìÇ', 'üìÅ', 'üóÉÔ∏è'],
            'Activities': ['üéØ', 'üé≤', 'üéÆ', 'üé∞', 'üé≥', 'üé∏', 'üéπ', 'üé∫', 'üéª', 'üé¨', 'üé®', 'üé≠', 'üé™', 'üé¢', 'üé°', 'üé†'],
            'Work & Tools': ['üíº', 'üìä', 'üìà', 'üìâ', 'üóÇÔ∏è', 'üìã', 'üìù', 'üñäÔ∏è', '‚úèÔ∏è', 'üìå', 'üìç', 'üî®', '‚öíÔ∏è', 'üõ†Ô∏è', '‚öôÔ∏è', 'üîß'],
            'Nature': ['üå≤', 'üå≥', 'üå¥', 'üåµ', 'üåæ', 'üåø', '‚òòÔ∏è', 'üçÄ', 'üçÉ', 'üçÇ', 'üçÅ', 'üå∫', 'üåª', 'üåπ', 'üå∑', 'üíê'],
            'Food & Drink': ['‚òï', 'üçµ', 'üßÉ', 'üßã', 'üç∫', 'üçª', 'ü•Ç', 'üç∑', 'ü•É', 'üç∏', 'üçπ', 'üçæ', 'üç¥', 'üçΩÔ∏è', 'ü•Ñ', 'ü•¢']
        };

        const grid = document.getElementById('emoji-picker-grid');
        grid.innerHTML = '';

        // Add emojis to grid
        Object.entries(emojiCategories).forEach(([category, emojis]) => {
            // Category header spanning all columns
            const header = document.createElement('div');
            header.style.cssText = 'grid-column: 1 / -1; font-size: 11px; font-weight: 600; color: #666; margin-top: 8px; margin-bottom: 4px;';
            header.textContent = category;
            grid.appendChild(header);

            // Emoji buttons
            emojis.forEach(emoji => {
                const btn = document.createElement('button');
                btn.textContent = emoji;
                btn.style.cssText = 'font-size: 24px; padding: 8px; background: white; border: 2px solid #ddd; border-radius: 6px; cursor: pointer; transition: all 0.2s;';
                btn.onclick = () => {
                    input.value = emoji;
                    // Highlight selected
                    grid.querySelectorAll('button').forEach(b => b.style.borderColor = '#ddd');
                    btn.style.borderColor = '#007bff';
                };
                btn.onmouseenter = () => {
                    if (btn.style.borderColor !== 'rgb(0, 123, 255)') {
                        btn.style.borderColor = '#999';
                        btn.style.transform = 'scale(1.1)';
                    }
                };
                btn.onmouseleave = () => {
                    if (btn.style.borderColor !== 'rgb(0, 123, 255)') {
                        btn.style.borderColor = '#ddd';
                        btn.style.transform = 'scale(1)';
                    }
                };
                grid.appendChild(btn);
            });
        });

        // Clone buttons to remove old event listeners
        const okBtn = document.getElementById('emoji-picker-ok');
        const cancelBtn = document.getElementById('emoji-picker-cancel');
        const newOkBtn = okBtn.cloneNode(true);
        const newCancelBtn = cancelBtn.cloneNode(true);
        okBtn.replaceWith(newOkBtn);
        cancelBtn.replaceWith(newCancelBtn);

        newOkBtn.onclick = () => {
            const value = input.value.trim();
            this.hideEmojiPicker();
            if (value && onConfirm) onConfirm(value);
        };

        newCancelBtn.onclick = () => {
            this.hideEmojiPicker();
        };

        // Enter key submits
        input.onkeydown = (e) => {
            if (e.key === 'Enter') {
                e.preventDefault();
                const value = input.value.trim();
                this.hideEmojiPicker();
                if (value && onConfirm) onConfirm(value);
            } else if (e.key === 'Escape') {
                e.preventDefault();
                this.hideEmojiPicker();
            }
        };

        // Focus input after modal shows
        setTimeout(() => input.focus(), 100);
    },

    /**
     * Hide emoji picker modal
     */
    hideEmojiPicker() {
        const modal = document.getElementById('emoji-picker-modal');
        modal.classList.remove('show');
    }
});



// ============================================================
// UI/CONTEXT-MENU.JS (Order: 31, Category: ui)
// ============================================================

/**
 * @module ui/context-menu
 * @order 31
 * @category ui
 *
 * Right-click context menus for tasks and empty space
 */

Object.assign(app, {
    showNodeMenu(e, taskId) {
        this.closeMenu();

        const task = this.tasks.find(t => t.id === taskId);
        if (!task) {
            console.error('Task not found:', taskId);
            return;
        }

        // If right-clicking on a task that's not in selection, select just it
        // If it's in the selection, operate on the entire selection
        const isInSelection = this.selectedTaskIds.has(taskId);
        const isMultiSelect = this.selectedTaskIds.size > 1;

        if (!isInSelection) {
            this.selectedTaskIds.clear();
            this.selectedTaskIds.add(taskId);
        }

        const menu = document.createElement('div');
        menu.className = 'node-menu';
        menu.style.left = e.pageX + 'px';
        menu.style.top = e.pageY + 'px';

        // Show dependencies if any
        if (task.dependencies.length > 0) {
            const depSection = document.createElement('div');
            depSection.className = 'dependency-section';

            const header = document.createElement('h4');
            header.textContent = 'Dependencies';
            depSection.appendChild(header);

            task.dependencies.forEach(depId => {
                const depTask = this.tasks.find(t => t.id === depId);
                if (depTask) {
                    const depItem = document.createElement('div');
                    depItem.className = 'dependency-item';

                    const span = document.createElement('span');
                    span.textContent = `‚Üí ${depTask.title}`;

                    const removeBtn = document.createElement('button');
                    removeBtn.className = 'remove-btn';
                    removeBtn.textContent = 'X';
                    removeBtn.onclick = (evt) => {
                        evt.stopPropagation();
                        this.removeDependency(taskId, depId);
                        this.closeMenu();
                    };

                    depItem.appendChild(span);
                    depItem.appendChild(removeBtn);
                    depSection.appendChild(depItem);
                }
            });

            menu.appendChild(depSection);
        }

        const hasHiddenChildren = this.getHiddenChildrenCount(taskId) > 0;
        const hideButtonLabel = task.children.length > 0
            ? (hasHiddenChildren ? 'Show Children' : 'Hide Children')
            : null;

        const buttons = [];

        // Multi-select specific options
        if (isMultiSelect) {
            buttons.push({
                label: `‚úÖ Mark Done (${this.selectedTaskIds.size})`,
                action: () => {
                    const selectedArray = Array.from(this.selectedTaskIds);
                    selectedArray.forEach(id => this.toggleDone(id));
                }
            });
            buttons.push({
                label: `‚è∏Ô∏è Mark Pending (${this.selectedTaskIds.size})`,
                action: () => {
                    const selectedArray = Array.from(this.selectedTaskIds);
                    selectedArray.forEach(id => {
                        const t = this.tasks.find(t => t.id === id);
                        if (t && t.status !== 'pending') this.toggleDone(id);
                    });
                }
            });
            buttons.push({
                label: `üôà Hide Child (${this.selectedTaskIds.size})`,
                action: () => {
                    const selectedArray = Array.from(this.selectedTaskIds);
                    selectedArray.forEach(id => this.toggleHiddenSelf(id));
                }
            });
            buttons.push({
                label: `üóëÔ∏è Delete (${this.selectedTaskIds.size})`,
                action: () => {
                    const selectedArray = Array.from(this.selectedTaskIds);
                    this.deleteMultipleTasks(selectedArray);
                }
            });
        } else {
            // Single select options
            buttons.push({ label: '‚ûï Add Child', action: () => this.addChildTask(taskId) });
            buttons.push({ label: task.status === 'done' ? '‚è∏Ô∏è Mark Pending' : '‚úÖ Mark Done', action: () => this.toggleDone(taskId) });
            buttons.push({ label: task.currentlyWorking ? '‚èπÔ∏è Stop Working' : '‚ñ∂Ô∏è Start Working', action: () => this.toggleWorking(taskId) });

            // Mark as In Progress option (if task is working)
            if (task.currentlyWorking) {
                buttons.push({
                    label: 'üìã Mark as In Progress',
                    action: () => this.markAsInProgress(taskId)
                });
            }

            // Timer control (if timer is running for this task)
            if (this.timerState.isRunning && this.timerState.taskId === taskId) {
                buttons.push({
                    label: '‚è∏Ô∏è Pause Timer',
                    action: () => {
                        this.stopTimer();
                        this.showToast('‚è∏Ô∏è Timer paused and session saved', 'info', 2000);
                    }
                });
            }

            // Time tracking history (if task has tracked time)
            if (task.timeTracking && task.timeTracking.totalSeconds > 0) {
                buttons.push({ label: '‚è±Ô∏è View Time History', action: () => this.showTimeHistoryModal(taskId) });
            }

            // Priority submenu
            const currentPriorityEmoji = task.priority === 'high' ? 'üî¥' : task.priority === 'medium' ? 'üü†' : '‚ö™';
            buttons.push({ label: `${currentPriorityEmoji} Set Priority`, isPrioritySubmenu: true, currentPriority: task.priority });

            // Arrow routing submenu
            const currentRouting = task.arrowRouting || 'inherit';
            const routingEmoji = currentRouting === 'direct' ? '‚ÜóÔ∏è' : currentRouting === 'orthogonal' ? '‚Ü™Ô∏è' : '‚öôÔ∏è';
            buttons.push({ label: `${routingEmoji} Arrow Routing`, isArrowRoutingSubmenu: true, currentRouting: currentRouting });

            // Add hide option if task has a parent (not a root task)
            if (task.mainParent !== null) {
                buttons.push({ label: task.hidden ? 'üëÅÔ∏è Show' : 'üôà Hide', action: () => this.toggleHiddenSelf(taskId) });
            }

            // Only add hide/show children button if task has children
            if (hideButtonLabel) {
                const hideEmoji = hideButtonLabel.includes('Show') ? 'üìÇ' : 'üì¶';
                buttons.push({ label: `${hideEmoji} ${hideButtonLabel}`, action: () => this.toggleHidden(taskId) });
            }

            buttons.push({ label: 'üìã Copy Text', action: () => this.copyTaskText(task.title) });

            // Copy/paste subtree options
            const subtreeSize = this.getSubtreeSize(taskId);
            const subtreeLabel = subtreeSize === 1 ? 'üìã Copy Subtree' : `üìã Copy Subtree (${subtreeSize} nodes)`;
            buttons.push({ label: subtreeLabel, action: () => this.copySubtree(taskId) });

            if (this.copiedSubtree) {
                const pasteLabel = `üìã Paste as Child (${this.copiedSubtree.metadata.nodeCount} nodes)`;
                buttons.push({ label: pasteLabel, action: () => this.pasteSubtree(taskId) });
            }

            // Always show "Paste from Clipboard as Child" option (reads foreign JSON)
            buttons.push({ label: 'üìã Paste from Clipboard as Child', action: () => this.pasteFromClipboard(taskId) });

            // Link management options
            if (!task.links) task.links = [];

            if (task.links.length === 0) {
                // No links - show attach option
                buttons.push({ label: 'üìé Attach Link', action: () => this.attachLink(taskId) });
            } else if (task.links.length === 1) {
                // Single link - direct options
                buttons.push({ label: 'üîó Go to Link', action: () => this.openLink(task.links[0]) });
                buttons.push({ label: 'üìé Attach Another Link', action: () => this.attachLink(taskId) });
                buttons.push({ label: '‚ùå Remove Link', action: () => this.removeAllLinks(taskId) });
            } else {
                // Multiple links - will need submenu (handled separately below)
                buttons.push({ label: `üîó Links (${task.links.length})`, isLinksSubmenu: true });
                buttons.push({ label: 'üìé Attach Another Link', action: () => this.attachLink(taskId) });
                buttons.push({ label: 'üóëÔ∏è Remove All Links', action: () => this.removeAllLinks(taskId) });
            }

            // Image management options
            if (task.imageId) {
                // Task has image - show remove option
                buttons.push({ label: 'üóëÔ∏è Remove Image', action: () => this.removeTaskImage(taskId) });
            } else {
                // No image - show paste image option
                buttons.push({ label: 'üñºÔ∏è Paste Image', action: () => this.pasteImage(taskId) });
            }

            buttons.push({ label: 'üóëÔ∏è Delete', action: () => this.deleteTask(taskId) });
        }

        buttons.forEach(({ label, action, isLinksSubmenu, isPrioritySubmenu, currentPriority, isArrowRoutingSubmenu, currentRouting }) => {
            if (isArrowRoutingSubmenu) {
                // Create arrow routing submenu
                const routingBtn = document.createElement('button');
                routingBtn.className = 'menu-item-with-submenu';
                routingBtn.textContent = label;

                const routingSubmenu = document.createElement('div');
                routingSubmenu.className = 'submenu-nested';
                routingSubmenu.style.display = 'none';

                let hideTimeout = null;

                routingBtn.addEventListener('mouseenter', () => {
                    if (hideTimeout) {
                        clearTimeout(hideTimeout);
                        hideTimeout = null;
                    }
                    const rect = routingBtn.getBoundingClientRect();
                    routingSubmenu.style.left = `${rect.right}px`;
                    routingSubmenu.style.top = `${rect.top}px`;
                    routingSubmenu.style.display = 'block';
                });

                routingBtn.addEventListener('mouseleave', (evt) => {
                    hideTimeout = setTimeout(() => {
                        const hoveredElement = document.elementFromPoint(evt.clientX, evt.clientY);
                        if (!routingSubmenu.contains(hoveredElement)) {
                            routingSubmenu.style.display = 'none';
                        }
                    }, 100);
                });

                routingSubmenu.addEventListener('mouseenter', () => {
                    if (hideTimeout) {
                        clearTimeout(hideTimeout);
                        hideTimeout = null;
                    }
                });

                routingSubmenu.addEventListener('mouseleave', () => {
                    routingSubmenu.style.display = 'none';
                });

                // Add routing options
                const routingOptions = [
                    { value: 'inherit', label: 'Inherit from Parent', emoji: '‚öôÔ∏è' },
                    { value: 'direct', label: 'Direct (Straight/Curved)', emoji: '‚ÜóÔ∏è' },
                    { value: 'orthogonal', label: 'Orthogonal (90¬∞ Turns)', emoji: '‚Ü™Ô∏è' }
                ];

                routingOptions.forEach(({ value, label: routingLabel, emoji }) => {
                    const item = document.createElement('div');
                    item.className = 'submenu-item';
                    item.textContent = `${emoji} ${routingLabel}`;

                    // Add checkmark if this is the current routing
                    if (value === currentRouting) {
                        item.textContent = `‚úì ${emoji} ${routingLabel}`;
                        item.style.fontWeight = '600';
                    }

                    item.onclick = (evt) => {
                        evt.stopPropagation();
                        this.closeMenu();
                        this.setArrowRouting(taskId, value);
                    };
                    routingSubmenu.appendChild(item);
                });

                document.body.appendChild(routingSubmenu);
                menu.appendChild(routingBtn);
            } else if (isPrioritySubmenu) {
                // Create priority submenu
                const priorityBtn = document.createElement('button');
                priorityBtn.className = 'menu-item-with-submenu';
                priorityBtn.textContent = label;

                const prioritySubmenu = document.createElement('div');
                prioritySubmenu.className = 'submenu-nested';
                prioritySubmenu.style.display = 'none';

                let hideTimeout = null;

                priorityBtn.addEventListener('mouseenter', () => {
                    if (hideTimeout) {
                        clearTimeout(hideTimeout);
                        hideTimeout = null;
                    }
                    const rect = priorityBtn.getBoundingClientRect();
                    prioritySubmenu.style.left = `${rect.right}px`;
                    prioritySubmenu.style.top = `${rect.top}px`;
                    prioritySubmenu.style.display = 'block';
                });

                priorityBtn.addEventListener('mouseleave', (evt) => {
                    hideTimeout = setTimeout(() => {
                        const hoveredElement = document.elementFromPoint(evt.clientX, evt.clientY);
                        if (!prioritySubmenu.contains(hoveredElement)) {
                            prioritySubmenu.style.display = 'none';
                        }
                    }, 100);
                });

                prioritySubmenu.addEventListener('mouseenter', () => {
                    if (hideTimeout) {
                        clearTimeout(hideTimeout);
                        hideTimeout = null;
                    }
                });

                prioritySubmenu.addEventListener('mouseleave', () => {
                    prioritySubmenu.style.display = 'none';
                });

                // Add priority options
                const priorities = [
                    { value: 'high', label: 'High Priority', emoji: 'üî¥' },
                    { value: 'medium', label: 'Medium Priority', emoji: 'üü†' },
                    { value: 'normal', label: 'Normal Priority', emoji: '‚ö™' }
                ];

                priorities.forEach(({ value, label: priorityLabel, emoji }) => {
                    const item = document.createElement('div');
                    item.className = 'submenu-item';
                    item.textContent = `${emoji} ${priorityLabel}`;

                    // Add checkmark if this is the current priority
                    if (value === currentPriority) {
                        item.textContent = `‚úì ${emoji} ${priorityLabel}`;
                        item.style.fontWeight = '600';
                    }

                    item.onclick = (evt) => {
                        evt.stopPropagation();
                        this.closeMenu();
                        this.setPriority(taskId, value);
                    };
                    prioritySubmenu.appendChild(item);
                });

                document.body.appendChild(prioritySubmenu);
                menu.appendChild(priorityBtn);
            } else if (isLinksSubmenu) {
                // Create submenu for multiple links
                const linksBtn = document.createElement('button');
                linksBtn.className = 'menu-item-with-submenu';
                linksBtn.textContent = label;

                const linksSubmenu = document.createElement('div');
                linksSubmenu.className = 'submenu-nested';
                linksSubmenu.style.display = 'none';

                let hideTimeout = null;

                linksBtn.addEventListener('mouseenter', () => {
                    if (hideTimeout) {
                        clearTimeout(hideTimeout);
                        hideTimeout = null;
                    }
                    const rect = linksBtn.getBoundingClientRect();
                    linksSubmenu.style.left = `${rect.right}px`;
                    linksSubmenu.style.top = `${rect.top}px`;
                    linksSubmenu.style.display = 'block';
                });

                linksBtn.addEventListener('mouseleave', (evt) => {
                    hideTimeout = setTimeout(() => {
                        const hoveredElement = document.elementFromPoint(evt.clientX, evt.clientY);
                        if (!linksSubmenu.contains(hoveredElement)) {
                            linksSubmenu.style.display = 'none';
                        }
                    }, 100);
                });

                linksSubmenu.addEventListener('mouseenter', () => {
                    if (hideTimeout) {
                        clearTimeout(hideTimeout);
                        hideTimeout = null;
                    }
                });

                linksSubmenu.addEventListener('mouseleave', () => {
                    linksSubmenu.style.display = 'none';
                });

                // Add each link as a submenu item
                task.links.forEach(url => {
                    const linkItem = document.createElement('div');
                    linkItem.className = 'submenu-item';
                    linkItem.textContent = `üåê ${this.shortenURL(url)}`;
                    linkItem.onclick = (evt) => {
                        evt.stopPropagation();
                        this.closeMenu();
                        this.openLink(url);
                    };
                    linksSubmenu.appendChild(linkItem);
                });

                document.body.appendChild(linksSubmenu);
                menu.appendChild(linksBtn);
            } else {
                // Regular button
                const btn = document.createElement('button');
                btn.textContent = label;
                btn.onclick = (evt) => {
                    evt.stopPropagation();
                    this.closeMenu();
                    action();
                };
                menu.appendChild(btn);
            }
        });

        document.body.appendChild(menu);
    },

    showEmptySpaceMenu(e) {
        this.closeMenu();

        const menu = document.createElement('div');
        menu.className = 'node-menu';
        menu.style.left = e.pageX + 'px';
        menu.style.top = e.pageY + 'px';

        const buttons = [
            {
                label: '‚ûï Create New Task',
                action: () => {
                    this.saveSnapshot(`Created task`);

                    const pt = this.getSVGPoint(e);
                    const newTask = {
                        id: this.taskIdCounter++,
                        title: '',
                        x: pt.x,
                        y: pt.y,
                        mainParent: null,
                        otherParents: [],
                        children: [],
                        dependencies: [],
                        status: 'pending',
                        currentlyWorking: false,
                        hidden: false,
                        textExpanded: false,
                        textLocked: false,
                        links: []  // Array of URLs attached to this task
                    };
                    this.tasks.push(newTask);
                    this.startEditing(newTask.id);
                    this.saveToStorage();
                    this.render();
                }
            }
        ];

        // Add paste option if clipboard has data
        if (this.copiedSubtree) {
            const pt = this.getSVGPoint(e);
            buttons.push({
                label: `üìã Paste Subtree Here (${this.copiedSubtree.metadata.nodeCount} nodes)`,
                action: () => this.pasteSubtree(null, pt.x, pt.y)
            });
        }

        // Always show "Paste from Clipboard" option (reads foreign JSON)
        const pt = this.getSVGPoint(e);
        buttons.push({
            label: 'üìã Paste from Clipboard',
            action: () => this.pasteFromClipboard(null, pt.x, pt.y)
        });

        buttons.push({ label: 'üîç Zoom to Fit', action: () => this.zoomToFit() });
        buttons.push({ label: 'üéØ Mark Origin', action: () => this.markOrigin() });

        buttons.forEach(({ label, action }) => {
            const btn = document.createElement('button');
            btn.textContent = label;
            btn.onclick = (evt) => {
                evt.stopPropagation();
                this.closeMenu();
                action();
            };
            menu.appendChild(btn);
        });

        // Add Homes submenu
        const homesBtn = document.createElement('button');
        homesBtn.className = 'menu-item-with-submenu';
        homesBtn.textContent = 'üè† Homes';

        const submenu = document.createElement('div');
        submenu.className = 'submenu';

        if (this.homes.length === 0) {
            submenu.innerHTML = '<div class="submenu-empty">No homes yet</div>';
        } else {
            // Sort homes: "Origin Home" first, then alphabetically
            const sortedHomes = [...this.homes].sort((a, b) => {
                if (a.name === "Origin Home") return -1;
                if (b.name === "Origin Home") return 1;
                return a.name.localeCompare(b.name);
            });

            sortedHomes.forEach(home => {
                const item = document.createElement('div');
                item.className = 'submenu-item menu-item-with-submenu';
                if (home.name === "Origin Home") {
                    item.classList.add('special');
                }

                // Display home icon + name with keybind if it exists
                const icon = home.icon || 'üè†';
                const nameText = home.keybind ? `${home.name} [${home.keybind}]` : home.name;

                // Don't use textContent - it can interfere with appendChild
                // Instead, create a span for the text
                const textSpan = document.createElement('span');
                textSpan.textContent = `${icon} ${nameText}`;
                item.appendChild(textSpan);

                // Click on home name navigates to that home
                item.onclick = (evt) => {
                    // Only navigate if clicking the item itself, not the nested submenu
                    if (evt.target === item || evt.target === textSpan) {
                        evt.stopPropagation();
                        this.closeMenu();
                        this.jumpToHome(home.id);
                    }
                };

                // Create nested submenu for each home (uses fixed positioning)
                const homeSubmenu = document.createElement('div');
                homeSubmenu.className = 'submenu-nested';
                homeSubmenu.style.display = 'none'; // Start hidden

                // Show/hide nested submenu with JavaScript (CSS hover unreliable with fixed positioning)
                let hideTimeout = null;

                item.addEventListener('mouseenter', () => {
                    if (hideTimeout) {
                        clearTimeout(hideTimeout);
                        hideTimeout = null;
                    }
                    const rect = item.getBoundingClientRect();
                    homeSubmenu.style.left = `${rect.right}px`;
                    homeSubmenu.style.top = `${rect.top}px`;
                    homeSubmenu.style.display = 'block';

                    // Keep parent submenu visible while nested submenu is open
                    submenu.style.display = 'block';
                });

                item.addEventListener('mouseleave', (evt) => {
                    // Don't hide if mouse moved to the submenu
                    hideTimeout = setTimeout(() => {
                        const hoveredElement = document.elementFromPoint(evt.clientX, evt.clientY);
                        if (!homeSubmenu.contains(hoveredElement)) {
                            homeSubmenu.style.display = 'none';
                            // Allow parent submenu to use CSS hover again
                            submenu.style.display = '';
                        }
                    }, 100);
                });

                // Keep both submenus visible when hovering nested submenu
                homeSubmenu.addEventListener('mouseenter', () => {
                    if (hideTimeout) {
                        clearTimeout(hideTimeout);
                        hideTimeout = null;
                    }
                    // Force parent submenu to stay visible
                    submenu.style.display = 'block';
                });

                homeSubmenu.addEventListener('mouseleave', () => {
                    homeSubmenu.style.display = 'none';
                    // Allow parent submenu to use CSS hover again
                    submenu.style.display = '';
                });

                // Jump to Home option
                const jumpOption = document.createElement('div');
                jumpOption.className = 'submenu-item';
                jumpOption.textContent = 'üöÄ Jump to Home';
                jumpOption.onclick = (evt) => {
                    evt.stopPropagation();
                    this.closeMenu();
                    this.jumpToHome(home.id);
                };
                homeSubmenu.appendChild(jumpOption);

                // Update Home Position option
                const updateOption = document.createElement('div');
                updateOption.className = 'submenu-item';
                updateOption.textContent = 'üìç Update Home Position';
                updateOption.onclick = (evt) => {
                    evt.stopPropagation();
                    this.closeMenu();
                    this.updateHome(home.id);
                };
                homeSubmenu.appendChild(updateOption);

                // Set Icon option
                const setIconOption = document.createElement('div');
                setIconOption.className = 'submenu-item';
                setIconOption.textContent = `${home.icon || 'üè†'} Set Icon`;
                setIconOption.onclick = (evt) => {
                    evt.stopPropagation();
                    this.closeMenu();
                    this.setHomeIcon(home.id);
                };
                homeSubmenu.appendChild(setIconOption);

                // Append nested submenu to body (not to item) since it uses fixed positioning
                // This avoids parent overflow issues
                document.body.appendChild(homeSubmenu);

                submenu.appendChild(item);
            });

            // Add divider
            const divider = document.createElement('div');
            divider.className = 'submenu-divider';
            submenu.appendChild(divider);
        }

        // Add "Create New Home" option
        const createItem = document.createElement('div');
        createItem.className = 'submenu-item special';
        createItem.textContent = '‚ûï Create New Home';
        createItem.onclick = (evt) => {
            evt.stopPropagation();
            this.closeMenu();
            this.showCreateHomeModal();
        };
        submenu.appendChild(createItem);

        // Add "Manage Homes" option
        const manageItem = document.createElement('div');
        manageItem.className = 'submenu-item';
        manageItem.textContent = '‚öôÔ∏è Manage Homes';
        manageItem.onclick = (evt) => {
            evt.stopPropagation();
            this.closeMenu();
            this.showManageHomesModal();
        };
        submenu.appendChild(manageItem);

        homesBtn.appendChild(submenu);
        menu.appendChild(homesBtn);

        document.body.appendChild(menu);
    },

    closeMenu() {
        const menu = document.querySelector('.node-menu');
        if (menu) menu.remove();

        // Also remove any nested submenus that were appended to body
        const nestedMenus = document.querySelectorAll('.submenu-nested');
        nestedMenus.forEach(m => m.remove());

        // Close any link dropdowns
        this.closeLinksDropdown();
    },

    copyTaskText(text) {
        navigator.clipboard.writeText(text).then(() => {
            // Show toast notification (auto-dismisses after 4 seconds)
            this.showToast(`‚úì Copied: "${text}"`, 'success', 4000);
        }).catch(err => {
            // Show error toast
            this.showToast('Failed to copy to clipboard', 'error', 4000);
        });
    },

    // Link Management Functions
    attachLink(taskId) {
        this.showPrompt('Attach Link', 'Enter URL:', '', (url) => {
            if (!url) return;

            url = url.trim();
            if (!this.isValidURL(url)) {
                this.showToast('‚ùå Invalid URL format', 'error');
                return;
            }

            const task = this.tasks.find(t => t.id === taskId);
            if (!task) return;

            this.saveSnapshot(`Attached link to "${task.title}"`);

            if (!task.links) task.links = [];

            if (task.links.includes(url)) {
                this.showToast('‚ö†Ô∏è Link already exists', 'warning');
                return;
            }

            task.links.push(url);
            this.saveToStorage();
            this.render();
            this.showToast(`üîó Link attached: ${this.shortenURL(url)}`, 'success');
        });
    },

    openLink(url) {
        try {
            window.open(url, '_blank', 'noopener,noreferrer');
            this.showToast(`üîó Opened: ${this.shortenURL(url)}`, 'info', 2000);
        } catch (err) {
            this.showToast('‚ùå Failed to open link', 'error');
        }
    },

    removeAllLinks(taskId) {
        const task = this.tasks.find(t => t.id === taskId);
        if (!task || !task.links || task.links.length === 0) return;

        const count = task.links.length;
        const confirmMsg = count === 1
            ? 'Remove this link from the node?'
            : `Remove all ${count} links from this node?`;

        this.showConfirm('Remove Links', confirmMsg, () => {
            this.saveSnapshot(`Removed ${count} link(s) from "${task.title}"`);
            task.links = [];
            this.saveToStorage();
            this.render();
            this.showToast(`‚úì Removed ${count} link(s)`, 'success');
        });
    },

    showLinksDropdown(taskId, x, y) {
        // Close any existing dropdown first
        this.closeLinksDropdown();

        const task = this.tasks.find(t => t.id === taskId);
        if (!task || !task.links || task.links.length === 0) return;

        // Create dropdown menu
        const dropdown = document.createElement('div');
        dropdown.className = 'links-dropdown';
        dropdown.style.position = 'fixed';
        dropdown.style.left = x + 'px';
        dropdown.style.top = y + 'px';
        dropdown.style.zIndex = '10000';
        dropdown.style.background = 'white';
        dropdown.style.border = '1px solid #ccc';
        dropdown.style.borderRadius = '4px';
        dropdown.style.boxShadow = '0 2px 8px rgba(0,0,0,0.15)';
        dropdown.style.minWidth = '200px';
        dropdown.style.maxWidth = '400px';

        // Add each link as a clickable item
        task.links.forEach((url, index) => {
            const linkItem = document.createElement('div');
            linkItem.style.padding = '8px 12px';
            linkItem.style.cursor = 'pointer';
            linkItem.style.borderBottom = index < task.links.length - 1 ? '1px solid #eee' : 'none';
            linkItem.style.transition = 'background-color 0.15s';
            linkItem.textContent = `üîó ${this.shortenURL(url, 50)}`;
            linkItem.title = url;  // Show full URL on hover

            linkItem.addEventListener('mouseenter', () => {
                linkItem.style.backgroundColor = '#f0f0f0';
            });

            linkItem.addEventListener('mouseleave', () => {
                linkItem.style.backgroundColor = '';
            });

            linkItem.onclick = (evt) => {
                evt.stopPropagation();
                this.closeLinksDropdown();
                this.openLink(url);
            };

            dropdown.appendChild(linkItem);
        });

        document.body.appendChild(dropdown);

        // Close dropdown when clicking outside
        const closeHandler = (evt) => {
            if (!dropdown.contains(evt.target)) {
                this.closeLinksDropdown();
                document.removeEventListener('click', closeHandler);
            }
        };

        // Use setTimeout to avoid immediate closure from the badge click
        setTimeout(() => {
            document.addEventListener('click', closeHandler);
        }, 0);
    },

    closeLinksDropdown() {
        const dropdown = document.querySelector('.links-dropdown');
        if (dropdown) dropdown.remove();
    }
});

console.log('[context-menu.js] Context menu system loaded');



// ============================================================
// UI/STATUS-BAR.JS (Order: 32, Category: ui)
// ============================================================

/**
 * @module ui/status-bar
 * @order 32
 * @category ui
 *
 * Bottom status bar showing working task context
 */

Object.assign(app, {
    updateStatusBar() {
        const workingTask = this.tasks.find(t => t.currentlyWorking);
        const statusBar = document.getElementById('status-bar');
        const container = document.getElementById('canvas-container');
        const jumpBtn = document.getElementById('jump-to-working-btn');

        // Always show the status bar
        statusBar.classList.add('show');
        container.classList.add('has-status-bar');

        if (!workingTask) {
            // Show default message
            const pathEl = document.getElementById('status-path');
            pathEl.innerHTML = '<span class="status-task">No task selected</span>';

            const childrenEl = document.getElementById('status-children');
            childrenEl.textContent = '| Middle-click a task to start working on it';

            // Hide jump button when no working task
            if (jumpBtn) jumpBtn.classList.add('hidden');
            return;
        }

        // Show jump button when there's a working task
        if (jumpBtn) jumpBtn.classList.remove('hidden');

        // Get full path
        const path = this.getPathToRoot(workingTask.id);

        // Compress if too long
        let pathDisplay;
        if (path.length > 4) {
            // Root > ... > Parent > Current
            pathDisplay = `${path[0]} > ... > ${path[path.length - 2]} > `;
        } else if (path.length > 1) {
            pathDisplay = path.slice(0, -1).join(' > ') + ' > ';
        } else {
            pathDisplay = '';
        }

        // Add current task in yellow with priority indicator
        const pathEl = document.getElementById('status-path');
        const priorityEmoji = workingTask.priority === 'high' ? ' üî¥' : workingTask.priority === 'medium' ? ' üü†' : '';
        pathEl.innerHTML = pathDisplay + `<span class="status-task">${workingTask.title}${priorityEmoji}</span>`;

        // Children info with percentage and incomplete list
        const childrenEl = document.getElementById('status-children');
        const childCount = workingTask.children.length;

        if (childCount > 0) {
            const completeCount = workingTask.children.filter(childId => {
                const child = this.tasks.find(t => t.id === childId);
                return child && child.status === 'done';
            }).length;

            const percentage = Math.round((completeCount / childCount) * 100);

            const incompleteChildren = workingTask.children
                .filter(childId => {
                    const child = this.tasks.find(t => t.id === childId);
                    return child && child.status !== 'done';
                })
                .map(childId => {
                    const child = this.tasks.find(t => t.id === childId);
                    return child ? child.title : '';
                });

            let childText = `| Children: ${completeCount}/${childCount} (${percentage}%)`;
            if (incompleteChildren.length > 0) {
                childText += ` | Incomplete: ${incompleteChildren.join(', ')}`;
                childrenEl.innerHTML = childText + ' <span class="status-warning">‚ö†</span>';
            } else {
                childrenEl.innerHTML = childText;
            }
        } else {
            childrenEl.textContent = '| No children';
        }
    }
});



// ============================================================
// UI/SETTINGS.JS (Order: 33, Category: ui)
// ============================================================

/**
 * @module ui/settings
 * @order 33
 * @category ui
 *
 * Settings modal and configuration management
 *
 * KEY FUNCTIONS:
 *
 * showSettingsModal() - Display settings modal
 * - Generates form from configDefs metadata
 * - Renders inputs based on type (number, text, select, checkbox)
 * - Special handling for charWidth with calibration button
 * - Shows undo/redo history stats
 * - ESC to close, click-outside to close
 *
 * hideSettingsModal() - Close settings modal
 * - Removes show class
 * - Resets scroll position
 * - Cleans up event listeners
 *
 * applySettings() - Apply settings from form
 * - Reads all form values
 * - Updates app state properties
 * - Enforces undo limit if changed
 * - Auto-calibrates charWidth if font changed
 * - Saves to localStorage
 * - Re-renders canvas
 *
 * resetSettings() - Reset to defaults
 * - Shows confirmation dialog
 * - Resets all config values to defaults
 * - Auto-calibrates charWidth for default font
 * - Refreshes form with new values
 *
 * exportSettings() - Export settings as JSON
 * - Extracts all configuration parameters
 * - Formats as pretty JSON
 * - Copies to clipboard
 *
 * CONFIGURATION METADATA (configDefs):
 * Defines all user-customizable properties:
 * - textLengthThreshold: Text truncation length
 * - charWidth: Character width for node sizing
 * - nodePadding: Left/right padding inside rectangles
 * - wheelZoomSpeed: Mouse wheel zoom speed
 * - minNodeWidth: Minimum node width
 * - fontFamily: CSS font stack
 * - fontWeight: Font weight (300-700)
 * - showDeleteConfirmation: Show delete confirmation
 * - autoHideCompletedNodes: Auto-hide completed subtrees
 * - enableMultiline: Allow multiline text
 * - maxNodeWidth: Max node width before wrapping
 * - maxNodeHeight: Max node height (0 = unlimited)
 * - lineHeight: Vertical spacing between lines
 * - wordWrap: Wrap on word vs character boundaries
 * - arrowStyle: Straight or curved arrows
 * - arrowCurvature: Curve intensity (0.05-0.5)
 * - maxUndoSteps: Max undo history (5-200)
 */

Object.assign(app, {
    showSettingsModal() {
        // Configuration metadata - defines which app properties are user-customizable
        const configDefs = {
            textLengthThreshold: {
                label: 'Text Truncation Length',
                type: 'number',
                default: 80,
                min: 20,
                max: 200,
                description: 'Characters before text is truncated'
            },
            charWidth: {
                label: 'Character Width (px)',
                type: 'number',
                default: 8.5,
                min: 4,
                max: 15,
                step: 0.5,
                description: 'Pixels per character for node width calculation. Auto-calibrates when font changes, or click Calibrate to measure manually.'
            },
            nodePadding: {
                label: 'Node Padding (px)',
                type: 'number',
                default: 15,
                min: 0,
                max: 50,
                description: 'Left/right padding inside rectangles'
            },
            wheelZoomSpeed: {
                label: 'Wheel/Trackpad Zoom Speed',
                type: 'number',
                default: 0.18,
                min: 0.01,
                max: 0.5,
                step: 0.01,
                description: 'Adjust mouse wheel / trackpad zoom speed (higher = faster)'
            },
            minNodeWidth: {
                label: 'Minimum Node Width (px)',
                type: 'number',
                default: 100,
                min: 40,
                max: 200,
                description: 'Minimum rectangle width'
            },
            fontFamily: {
                label: 'Font Family',
                type: 'text',
                default: "'Fira Code', 'Consolas', 'Monaco', 'Courier New', monospace",
                description: 'CSS font stack for task text'
            },
            fontWeight: {
                label: 'Font Weight',
                type: 'select',
                default: 700,
                options: [
                    { value: 300, label: 'Light (300)' },
                    { value: 400, label: 'Normal (400)' },
                    { value: 500, label: 'Medium (500)' },
                    { value: 600, label: 'Semibold (600)' },
                    { value: 700, label: 'Bold (700)' }
                ],
                description: 'Font weight for task text'
            },
            showDeleteConfirmation: {
                label: 'Show Delete Confirmation',
                type: 'checkbox',
                default: true,
                description: 'Show confirmation dialog when deleting tasks (can still undo with Ctrl+Z)'
            },
            autoHideCompletedNodes: {
                label: 'Auto-Hide Completed Nodes',
                type: 'checkbox',
                default: true,
                description: 'Automatically hide child nodes when they and their parent are marked done'
            },
            enableMultiline: {
                label: 'Enable Multiline Text',
                type: 'checkbox',
                default: true,
                description: 'Allow task text to wrap to multiple lines when it exceeds max width'
            },
            maxNodeWidth: {
                label: 'Max Node Width (px)',
                type: 'number',
                default: 600,
                min: 100,
                max: 2000,
                description: 'Maximum node width in pixels before text wraps to next line'
            },
            maxNodeHeight: {
                label: 'Max Node Height (px)',
                type: 'number',
                default: 0,
                min: 0,
                max: 1000,
                description: 'Maximum node height in pixels (0 = unlimited)'
            },
            lineHeight: {
                label: 'Line Height (px)',
                type: 'number',
                default: 20,
                min: 12,
                max: 40,
                description: 'Vertical spacing between lines of text'
            },
            wordWrap: {
                label: 'Word Wrap',
                type: 'checkbox',
                default: true,
                description: 'Wrap text on word boundaries (more readable) vs character boundaries'
            },
            enableMarkdown: {
                label: 'Enable Markdown Formatting',
                type: 'checkbox',
                default: true,
                description: 'Parse markdown in task titles: **bold**, *italic*, `code`, - bullets, [links](url)'
            },
            arrowStyle: {
                label: 'Arrow Style',
                type: 'select',
                default: 'straight',
                options: [
                    { value: 'straight', label: 'Straight' },
                    { value: 'curved', label: 'Curved' }
                ],
                description: 'Visual style for arrows connecting tasks'
            },
            arrowCurvature: {
                label: 'Arrow Curvature',
                type: 'number',
                default: 0.25,
                min: 0.05,
                max: 0.5,
                step: 0.05,
                description: 'Intensity of curve for curved arrows (0.05 = subtle, 0.5 = dramatic)'
            },
            arrowOppositeEdge: {
                label: 'Arrows Land on Opposite Edge',
                type: 'checkbox',
                default: true,
                description: 'Arrows land on the opposite edge (center of far side) instead of the nearest edge. Creates more consistent, organized layouts.'
            },
            arrowRoutingMode: {
                label: 'Arrow Routing Mode',
                type: 'select',
                default: 'direct',
                options: [
                    { value: 'direct', label: 'Direct (Straight/Curved)' },
                    { value: 'orthogonal', label: 'Orthogonal (90¬∞ Turns)' }
                ],
                description: 'Direct: arrows go straight from source to target. Orthogonal: arrows use 90-degree turns for a structured, circuit-board look. Toggle with Ctrl+Alt+A.'
            },
            orthogonalCornerRadius: {
                label: 'Orthogonal Corner Radius',
                type: 'number',
                default: 15,
                min: 0,
                max: 30,
                step: 1,
                description: 'Roundness of corners in orthogonal routing mode (0 = sharp 90¬∞ angles, 30 = smooth curves)'
            },
            enableSnapping: {
                label: 'Enable Alignment Snapping',
                type: 'checkbox',
                default: true,
                description: 'Snap nodes to align with edges and centers of nearby nodes when dragging. Shows visual guide lines during drag.'
            },
            snapThreshold: {
                label: 'Snap Detection Distance (px)',
                type: 'number',
                default: 10,
                min: 0,
                max: 50,
                step: 1,
                description: 'Distance in pixels for snap to activate. Higher values make snapping more aggressive.'
            },
            gridEnabled: {
                label: 'Show Grid',
                type: 'checkbox',
                default: false,
                description: 'Display a visual grid on the canvas for alignment reference'
            },
            gridSize: {
                label: 'Grid Cell Size (px)',
                type: 'number',
                default: 20,
                min: 5,
                max: 100,
                step: 5,
                description: 'Size of grid cells in pixels. Common values: 20 (fine), 50 (medium), 100 (coarse)'
            },
            gridSnapEnabled: {
                label: 'Snap to Grid',
                type: 'checkbox',
                default: true,
                description: 'Snap task positions to grid when grid is enabled. Disable for free positioning with visible grid.'
            },
            maxUndoSteps: {
                label: 'Max Undo History',
                type: 'number',
                default: 50,
                min: 5,
                max: 200,
                step: 5,
                description: 'Maximum number of undo steps to keep in history (5-200). Higher values use more memory.'
            }
        };

        // Generate form HTML
        const formContainer = document.getElementById('settings-form');
        let html = '<div style="display: flex; flex-direction: column; gap: 12px;">';

        for (const [key, def] of Object.entries(configDefs)) {
            const currentValue = this[key];
            html += `
                <div class="settings-field">
                    <label style="display: block; font-weight: 600; margin-bottom: 3px; font-size: 13px;">
                        ${def.label}
                    </label>
                    <div style="font-size: 11px; color: #666; margin-bottom: 5px;">
                        ${def.description}
                    </div>`;

            if (def.type === 'number') {
                // Special handling for charWidth: add calibration button
                if (key === 'charWidth') {
                    html += `
                        <div style="display: flex; gap: 8px; align-items: center;">
                            <input
                                type="number"
                                id="setting-${key}"
                                value="${currentValue}"
                                min="${def.min || ''}"
                                max="${def.max || ''}"
                                step="${def.step || 1}"
                                style="flex: 1; padding: 6px; font-size: 13px; border: 1px solid #ccc; border-radius: 4px;"
                            />
                            <button
                                onclick="app.calibrateCharWidth()"
                                style="padding: 6px 12px; font-size: 12px; white-space: nowrap; background: #2196f3; color: white; border: 1px solid #1976d2; border-radius: 4px; cursor: pointer;"
                                onmouseover="this.style.background='#1976d2'"
                                onmouseout="this.style.background='#2196f3'"
                                title="Measure actual character width for current font">
                                üìè Calibrate
                            </button>
                        </div>`;
                } else {
                    html += `
                        <input
                            type="number"
                            id="setting-${key}"
                            value="${currentValue}"
                            min="${def.min || ''}"
                            max="${def.max || ''}"
                            step="${def.step || 1}"
                            style="width: 100%; padding: 6px; font-size: 13px; border: 1px solid #ccc; border-radius: 4px;"
                        />`;
                }
            } else if (def.type === 'text') {
                html += `
                    <input
                        type="text"
                        id="setting-${key}"
                        value="${currentValue}"
                        style="width: 100%; padding: 6px; font-size: 13px; border: 1px solid #ccc; border-radius: 4px;"
                    />`;
            } else if (def.type === 'select') {
                html += `<select id="setting-${key}" style="width: 100%; padding: 6px; font-size: 13px; border: 1px solid #ccc; border-radius: 4px;">`;
                for (const opt of def.options) {
                    const selected = currentValue == opt.value ? 'selected' : '';
                    html += `<option value="${opt.value}" ${selected}>${opt.label}</option>`;
                }
                html += `</select>`;
            } else if (def.type === 'checkbox') {
                const checked = currentValue ? 'checked' : '';
                html += `
                    <label style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
                        <input
                            type="checkbox"
                            id="setting-${key}"
                            ${checked}
                            style="width: 18px; height: 18px; cursor: pointer;"
                        />
                        <span style="font-size: 14px;">Enable this option</span>
                    </label>`;
            }

            html += `</div>`;
        }

        html += '</div>';
        formContainer.innerHTML = html;

        // Store config defs for later use
        this._configDefs = configDefs;

        // Add ESC key handler
        this._settingsEscHandler = (e) => {
            if (e.key === 'Escape') {
                this.hideSettingsModal();
            }
        };
        document.addEventListener('keydown', this._settingsEscHandler);

        // Add click-outside handler
        this._settingsClickHandler = (e) => {
            const modal = document.getElementById('settings-modal');
            if (e.target === modal) {
                this.hideSettingsModal();
            }
        };
        const modal = document.getElementById('settings-modal');
        modal.addEventListener('click', this._settingsClickHandler);

        // Update history stats
        document.getElementById('undo-count').textContent = this.undoStack.length;
        document.getElementById('undo-limit').textContent = this.maxUndoSteps;
        document.getElementById('redo-count').textContent = this.redoStack.length;

        // Estimate memory usage
        const historyJSON = JSON.stringify({
            undoStack: this.undoStack,
            redoStack: this.redoStack
        });
        const sizeKB = Math.round(historyJSON.length / 1024);
        document.getElementById('history-size').textContent = sizeKB;

        // Show modal
        modal.classList.add('show');
    },

    hideSettingsModal() {
        const modal = document.getElementById('settings-modal');
        modal.classList.remove('show');

        // Reset scroll position for next time modal is opened
        const modalContent = modal.querySelector('.modal-content');
        if (modalContent) {
            modalContent.scrollTop = 0;
        }

        // Remove event listeners
        if (this._settingsEscHandler) {
            document.removeEventListener('keydown', this._settingsEscHandler);
            this._settingsEscHandler = null;
        }
        if (this._settingsClickHandler) {
            modal.removeEventListener('click', this._settingsClickHandler);
            this._settingsClickHandler = null;
        }
    },

    applySettings() {
        // Store old font settings to detect changes
        const oldFontFamily = this.fontFamily;
        const oldFontWeight = this.fontWeight;

        // Read values from form and update app state
        for (const key of Object.keys(this._configDefs)) {
            const input = document.getElementById(`setting-${key}`);
            const def = this._configDefs[key];

            if (def.type === 'number') {
                this[key] = parseFloat(input.value);
            } else if (def.type === 'select') {
                // Check if select values are numeric or string
                // If first option value is a number, parse as int, otherwise keep as string
                const firstOptionValue = def.options[0].value;
                if (typeof firstOptionValue === 'number' || !isNaN(parseInt(firstOptionValue))) {
                    this[key] = parseInt(input.value);
                } else {
                    this[key] = input.value; // Keep as string for non-numeric selects
                }
            } else if (def.type === 'checkbox') {
                this[key] = input.checked;
            } else {
                this[key] = input.value;
            }
        }

        // Enforce undo limit if maxUndoSteps was changed
        this.enforceUndoLimit();

        // Auto-calibrate charWidth if font settings changed
        const fontChanged = (this.fontFamily !== oldFontFamily || this.fontWeight !== oldFontWeight);
        if (fontChanged) {
            // Calibrate before render/save so the new charWidth is applied
            this.calibrateCharWidth(true); // true = automatic
            // Note: calibrateCharWidth already calls render() and saveToStorage()
        } else {
            // Re-render to apply visual changes
            this.render();

            // Save to localStorage
            this.saveToStorage();
        }

        // Hide modal
        this.hideSettingsModal();

        // Show success feedback
        this.showToast('Settings applied successfully', 'success');
    },

    resetSettings() {
        // Confirm before resetting
        this.showConfirm(
            'Reset Settings',
            'Are you sure you want to reset all settings to their default values?',
            () => {
                // Reset all config values to defaults
                for (const [key, def] of Object.entries(this._configDefs)) {
                    this[key] = def.default;
                }

                // Auto-calibrate charWidth for default font settings
                this.calibrateCharWidth(true); // true = automatic
                // Note: calibrateCharWidth already calls render() and saveToStorage()

                // Re-populate form with new values
                this.hideSettingsModal();
                this.showSettingsModal();

                // Show success feedback
                this.showToast('Settings reset to defaults', 'success');
            }
        );
    },

    exportSettings() {
        // Extract configuration parameters
        const settings = {
            textLengthThreshold: this.textLengthThreshold,
            charWidth: this.charWidth,
            nodePadding: this.nodePadding,
            wheelZoomSpeed: this.wheelZoomSpeed,
            minNodeWidth: this.minNodeWidth,
            fontFamily: this.fontFamily,
            fontWeight: this.fontWeight
        };

        // Format as pretty JSON
        const json = JSON.stringify(settings, null, 2);

        // Copy to clipboard
        navigator.clipboard.writeText(json).then(() => {
            this.showToast('Settings copied to clipboard!', 'success');
        }).catch(err => {
            this.showAlert('Export Failed', 'Failed to copy to clipboard: ' + err.message);
        });
    }
});

console.log('[settings.js] Settings modal and configuration management loaded');



// ============================================================
// UI/SHORTCUTS.JS (Order: 34, Category: ui)
// ============================================================

/**
 * @module ui/shortcuts
 * @order 34
 * @category ui
 *
 * Keyboard shortcuts modal - comprehensive reference for all keyboard interactions
 *
 * KEY FUNCTIONS:
 *
 * showShortcutsModal() - Display shortcuts reference modal
 * - Generates comprehensive keyboard shortcuts reference
 * - Platform-aware key names (Cmd vs Ctrl, Option vs Alt)
 * - Organized into 7 categories with emojis
 * - Pro Tips for advanced workflows
 * - ESC to close, click-outside to close
 *
 * hideShortcutsModal() - Close shortcuts modal
 * - Removes show class
 * - Cleans up event listeners
 *
 * SHORTCUT CATEGORIES:
 *
 * 1. ‚úèÔ∏è Editing - Task creation, editing, deletion
 *    - Double-click to edit
 *    - Cmd+Double-click to create child
 *    - Backspace to delete
 *
 * 2. üéØ Selection - Selecting, multi-selecting, clearing
 *    - Click to select
 *    - Cmd+Click to multi-select
 *    - Cmd+Drag for box selection
 *    - Escape to clear
 *
 * 3. üìä Status & Priority - Status changes, priority cycling
 *    - Middle-click to cycle status
 *    - P key to cycle priority
 *
 * 4. üîó Relationships - Reparenting, dependencies, subtree movement
 *    - Cmd+Drag to reparent
 *    - Alt+Drag to add dependency
 *    - Shift+Drag to move subtree
 *
 * 5. üöÄ Navigation - Movement, zooming, jumping, collapsing
 *    - Drag to move
 *    - Scroll wheel to zoom
 *    - J to jump to working task
 *    - Shift+Double-click to collapse
 *
 * 6. üîó Links - Link attachment, opening links
 *    - Cmd+K to attach URL
 *    - Click link icon to open
 *    - Pro Tip: Auto-detection when editing
 *
 * 7. ‚èÆÔ∏è Undo/Redo - Undo and redo operations
 *    - Cmd+Z to undo
 *    - Cmd+Shift+Z to redo
 *
 * PLATFORM-AWARE KEY NAMES:
 * - macOS: ‚åò (Cmd), ‚å• (Option), ‚áß (Shift)
 * - Windows/Linux: Ctrl, Alt, Shift
 *
 * Pro Tips are shown as highlighted boxes with blue left border,
 * providing advanced workflow guidance.
 */

Object.assign(app, {
    showShortcutsModal() {
        const modal = document.getElementById('shortcuts-modal');
        const platformInfo = document.getElementById('shortcuts-platform-info');
        const content = document.getElementById('shortcuts-content');

        // Set platform info
        const platform = this.isMac ? 'macOS' : this.isWindows ? 'Windows' : 'Linux';
        platformInfo.textContent = `Detected platform: ${platform}`;

        // Get platform-specific key names
        const mod = this.getModifierKey(false); // 'Cmd' or 'Ctrl'
        const modSymbol = this.getModifierKey(true); // '‚åò' or 'Ctrl'
        const alt = this.getAltKey(false);
        const altSymbol = this.getAltKey(true);
        const shift = this.getShiftKey(false);
        const shiftSymbol = this.getShiftKey(true);

        // Build shortcuts by category
        const shortcuts = [
            {
                category: '‚úèÔ∏è Editing',
                items: [
                    { keys: 'Double-click node', description: 'Edit task name' },
                    { keys: `${modSymbol}+Double-click node`, description: 'Create child task under node' },
                    { keys: `${modSymbol}+Double-click empty`, description: 'Create root task at cursor' },
                    { keys: 'Backspace', description: 'Delete selected task(s)' },
                    { keys: `${altSymbol}+Click node`, description: 'Delete task (alternative method)' }
                ]
            },
            {
                category: 'üéØ Selection',
                items: [
                    { keys: 'Click node', description: 'Select task (clears other selections)' },
                    { keys: `${modSymbol}+Click node`, description: 'Multi-select (toggle selection)' },
                    { keys: `${modSymbol}+Drag empty`, description: 'Box select (select all nodes in rectangle)' },
                    { keys: 'Escape', description: 'Clear all selections' },
                    { keys: '‚Üê ‚Üí ‚Üë ‚Üì Arrow keys', description: 'Move selected task(s) 1 pixel in direction' }
                ],
                tip: 'üí° <strong>Pro Tip:</strong> Use arrow keys for precise positioning of selected tasks - great for perfect alignment!'
            },
            {
                category: 'üìä Status & Priority',
                items: [
                    { keys: 'Middle-click', description: 'Cycle task status (pending ‚Üí working ‚Üí done ‚Üí pending)' },
                    { keys: 'P (hover)', description: 'Cycle priority of hovered task' },
                    { keys: 'P (selected)', description: 'Cycle priority of selected task(s)' }
                ]
            },
            {
                category: 'üîó Relationships',
                items: [
                    { keys: `${modSymbol}+Drag A ‚Üí B`, description: 'Reparent: Make task A a child of task B' },
                    { keys: `${modSymbol}+Drag A ‚Üí empty`, description: 'Create child task at cursor position (with preview)' },
                    { keys: `${altSymbol}+Drag A ‚Üí B`, description: 'Add dependency: A depends on B (A waits for B)' },
                    { keys: `${altSymbol}+Drag on dependency`, description: 'Remove dependency link' },
                    { keys: `${shiftSymbol}+Drag node`, description: 'Move entire subtree (preserves relative positions)' }
                ],
                tip: 'üí° <strong>Pro Tip:</strong> When Ctrl+dragging, a ghost preview node shows where the new child will be created!'
            },
            {
                category: 'üöÄ Navigation',
                items: [
                    { keys: 'Drag node', description: 'Move single task to new position' },
                    { keys: 'Scroll wheel', description: 'Zoom in/out at cursor position' },
                    { keys: `${modSymbol}++`, description: 'Zoom in' },
                    { keys: `${modSymbol}+‚àí`, description: 'Zoom out' },
                    { keys: 'J or üéØ button', description: 'Jump to currently working task (cinematic animation)' },
                    { keys: `${shiftSymbol}+Double-click`, description: 'Toggle subtree visibility (collapse/expand)' }
                ]
            },
            {
                category: 'üîó Links',
                items: [
                    { keys: `${modSymbol}+K`, description: 'Attach URL to selected task' },
                    { keys: 'Click üîó', description: 'Open attached link in new tab' }
                ],
                tip: 'üí° <strong>Pro Tip:</strong> Paste a URL as the last text in a task - it will be automatically detected, removed from the task name, and added as a link!'
            },
            {
                category: '‚èÆÔ∏è Undo/Redo',
                items: [
                    { keys: `${modSymbol}+Z`, description: 'Undo last action' },
                    { keys: `${modSymbol}+${shiftSymbol}+Z`, description: 'Redo previously undone action' }
                ]
            }
        ];

        // Build HTML for shortcuts
        let html = '';
        shortcuts.forEach(section => {
            html += `
                <div class="shortcut-section">
                    <h3 style="font-size: 15px; font-weight: 600; margin-bottom: 12px; color: ${this.darkMode ? '#fff' : '#333'};">${section.category}</h3>
                    <table style="width: 100%; border-collapse: collapse;">
                        ${section.items.map(item => `
                            <tr style="border-bottom: 1px solid ${this.darkMode ? '#444' : '#eee'};">
                                <td style="padding: 8px 16px 8px 0; font-family: 'Fira Code', monospace; font-size: 13px; color: ${this.darkMode ? '#4fc3f7' : '#1976d2'}; white-space: nowrap;">${item.keys}</td>
                                <td style="padding: 8px 0; font-size: 13px; color: ${this.darkMode ? '#ccc' : '#666'};">${item.description}</td>
                            </tr>
                        `).join('')}
                    </table>
                    ${section.tip ? `<div style="margin-top: 12px; padding: 10px; background: ${this.darkMode ? 'rgba(76, 195, 247, 0.1)' : 'rgba(25, 118, 210, 0.05)'}; border-left: 3px solid ${this.darkMode ? '#4fc3f7' : '#1976d2'}; border-radius: 4px; font-size: 13px; color: ${this.darkMode ? '#ccc' : '#666'};">${section.tip}</div>` : ''}
                </div>
            `;
        });

        content.innerHTML = html;

        // Add ESC key handler
        this._shortcutsEscHandler = (e) => {
            if (e.key === 'Escape') {
                this.hideShortcutsModal();
            }
        };
        document.addEventListener('keydown', this._shortcutsEscHandler);

        // Add click-outside handler
        this._shortcutsClickHandler = (e) => {
            if (e.target === modal) {
                this.hideShortcutsModal();
            }
        };
        modal.addEventListener('click', this._shortcutsClickHandler);

        modal.classList.add('show');
    },

    hideShortcutsModal() {
        const modal = document.getElementById('shortcuts-modal');
        modal.classList.remove('show');

        // Remove event listeners
        if (this._shortcutsEscHandler) {
            document.removeEventListener('keydown', this._shortcutsEscHandler);
            this._shortcutsEscHandler = null;
        }
        if (this._shortcutsClickHandler) {
            modal.removeEventListener('click', this._shortcutsClickHandler);
            this._shortcutsClickHandler = null;
        }
    }
});

console.log('[shortcuts.js] Keyboard shortcuts modal loaded');



// ============================================================
// UI/TEST-CHECKLIST.JS (Order: 35, Category: ui)
// ============================================================

/**
 * @module ui/test-checklist
 * @order 35
 * @category ui
 *
 * Test data injection - comprehensive checklist for testing features
 *
 * KEY FUNCTION:
 *
 * loadTestChecklist() - Inject comprehensive test task tree
 * - Creates hierarchical test structure
 * - Root: "üß™ Test Recent Changes"
 * - 7 categories with specific test scenarios
 * - Positioned at (200, 200) with children spread out
 * - Shows alert notification when loaded
 *
 * TEST CATEGORIES:
 *
 * 1. Middle-Click Status Cycling
 *    - Pending ‚Üí Working ‚Üí Done ‚Üí Pending cycle
 *    - Status bar updates
 *    - Single working task constraint
 *
 * 2. Shift+Drag Subtree Movement
 *    - Entire subtree moves together
 *    - Relative positions preserved
 *    - Distances unchanged
 *
 * 3. Incomplete Children Highlighting
 *    - Working task with children
 *    - Red borders on incomplete children
 *    - Disappear when marked done
 *
 * 4. Custom Modals Work
 *    - Delete confirmation modal
 *    - Cancel vs Yes buttons
 *    - Clear All Data modal
 *
 * 5. Enhanced Status Bar
 *    - Full path display
 *    - Completion percentage
 *    - Incomplete children list
 *    - Path compression (>4 levels)
 *
 * 6. Dependency Cleanup on Reparent
 *    - Create dependency
 *    - Reparent removes dependency
 *    - Visual verification
 *
 * 7. Visual Alt+Drag Distinction
 *    - Ctrl+drag = dashed blue (reparent)
 *    - Alt+drag = solid green (dependency)
 *
 * USAGE:
 * - Click "üß™ Test Checklist" button to inject
 * - Mark tasks as done after verifying
 * - Provides known-good state for debugging
 * - Covers all major features systematically
 */

Object.assign(app, {
    loadTestChecklist() {
        // Create root test node
        const testRoot = {
            id: this.taskIdCounter++,
            title: 'üß™ Test Recent Changes',
            x: 200,
            y: 200,
            vx: 0,
            vy: 0,
            mainParent: null,
            otherParents: [],
            children: [],
            dependencies: [],
            status: 'pending',
            hidden: false,
            currentlyWorking: false
        };
        this.tasks.push(testRoot);

        // Test items for recent features
        const tests = [
            {
                title: 'Middle-Click Status Cycling',
                children: [
                    'Middle-click pending task ‚Üí becomes Working (yellow)',
                    'Middle-click again ‚Üí becomes Done (green)',
                    'Middle-click again ‚Üí becomes Pending (white)',
                    'Verify status bar updates when task is Working',
                    'Verify only one task can be Working at a time'
                ]
            },
            {
                title: 'Shift+Drag Subtree Movement',
                children: [
                    'Create task with children',
                    'Shift+drag parent task',
                    'Verify entire subtree moves together',
                    'Verify relative positions preserved',
                    'Verify distances between nodes unchanged'
                ]
            },
            {
                title: 'Incomplete Children Highlighting',
                children: [
                    'Create task with children',
                    'Mark task as "Working"',
                    'Verify incomplete children have red border',
                    'Mark a child done - red border should disappear'
                ]
            },
            {
                title: 'Custom Modals Work',
                children: [
                    'Click Delete on a task - modal should appear',
                    'Click Cancel - modal closes, task remains',
                    'Click Delete again > Yes - task deletes',
                    'Test Clear All Data modal works'
                ]
            },
            {
                title: 'Enhanced Status Bar',
                children: [
                    'Mark nested task as Working',
                    'Verify full path shows (Root > ... > Current)',
                    'Check completion percentage displays',
                    'Verify incomplete children listed by name',
                    'Path compresses correctly if >4 levels deep'
                ]
            },
            {
                title: 'Dependency Cleanup on Reparent',
                children: [
                    'Create dependency A‚ÜíB with Ctrl+drag',
                    'Alt+drag A to B (reparent)',
                    'Verify dependency arrow disappears',
                    'Verify A is now child of B'
                ]
            },
            {
                title: 'Visual Alt+Drag Distinction',
                children: [
                    'Ctrl+drag - verify dashed blue line',
                    'Alt+drag - verify solid green line',
                    'Complete both operations successfully'
                ]
            }
        ];

        let yOffset = 0;
        tests.forEach((category, idx) => {
            const categoryTask = {
                id: this.taskIdCounter++,
                title: category.title,
                x: 400,
                y: 200 + yOffset,
                vx: 0,
                vy: 0,
                mainParent: testRoot.id,
                otherParents: [],
                children: [],
                dependencies: [],
                status: 'pending',
                hidden: false,
                currentlyWorking: false
            };
            this.tasks.push(categoryTask);
            testRoot.children.push(categoryTask.id);

            category.children.forEach((testName, childIdx) => {
                const testTask = {
                    id: this.taskIdCounter++,
                    title: testName,
                    x: 600,
                    y: 200 + yOffset + (childIdx * 60),
                    vx: 0,
                    vy: 0,
                    mainParent: categoryTask.id,
                    otherParents: [],
                    children: [],
                    dependencies: [],
                    status: 'pending',
                    hidden: false,
                    currentlyWorking: false
                };
                this.tasks.push(testTask);
                categoryTask.children.push(testTask.id);
            });

            yOffset += category.children.length * 60 + 80;
        });

        this.saveToStorage();
        this.render();

        this.showAlert('Test Checklist Loaded', 'Testing tasks have been added to your graph. Check them off as you test!');
    }
});

console.log('[test-checklist.js] Test data injection loaded');



// ============================================================
// UI/TOAST.JS (Order: 36, Category: ui)
// ============================================================

/**
 * @module ui/toast
 * @order 36
 * @category ui
 *
 * Toast notification system
 */

Object.assign(app, {
    showToast(message, type = 'success', duration = 4000) {
        // Create container if it doesn't exist
        let container = document.querySelector('.toast-container');
        if (!container) {
            container = document.createElement('div');
            container.className = 'toast-container';
            document.body.appendChild(container);
        }

        // Create toast element
        const toast = document.createElement('div');
        toast.className = `toast ${type}`;
        toast.textContent = message;

        // Add to container
        container.appendChild(toast);

        // Auto-remove after duration
        setTimeout(() => {
            toast.remove();
        }, duration);

        // Allow clicking to dismiss early
        toast.onclick = () => toast.remove();
    }
});



// ============================================================
// UI/TIMER-WINDOW.JS (Order: 37, Category: UI)
// ============================================================

/**
 * @module ui/timer-window
 * @order 37
 * @category UI
 * @description Floating timer window for time tracking
 */

Object.assign(app, {
    /**
     * Render or update the timer window
     */
    updateTimerDisplay() {
        const container = document.getElementById('timer-window');
        if (!container) return;

        // Show window if there's a working task (even if timer paused)
        const workingTask = this.tasks.find(t => t.currentlyWorking);
        if (!workingTask) {
            container.style.display = 'none';
            return;
        }

        container.style.display = 'block';

        // Use working task, not necessarily the one with running timer
        const task = workingTask;
        if (!task) return;

        // Get current session time
        const sessionSeconds = this.getCurrentSessionSeconds();
        const totalSeconds = this.getTotalTimeForTask(task.id);

        // Update content based on minimized state
        if (this.timerWindowMinimized) {
            container.innerHTML = `
                <div class="timer-badge" onclick="app.toggleTimerWindow()">
                    ‚è±Ô∏è ${this.formatDuration(sessionSeconds)}
                </div>
            `;
        } else {
            const sessionCount = task.timeTracking ? task.timeTracking.sessions.length : 0;
            const taskTitle = this.truncateTitle(task.title || 'Untitled', 30);

            // Get recent sessions for display
            let sessionsHTML = '';
            if (task.timeTracking && task.timeTracking.sessions.length > 0) {
                const recentSessions = task.timeTracking.sessions.slice(-3).reverse();
                sessionsHTML = recentSessions.map(session => `
                    <div class="session-item">
                        ‚Ä¢ ${this.formatDuration(session.duration)} (${this.formatRelativeTime(session.startTime)})
                    </div>
                `).join('');
            }

            // Check if timer is currently running for this task
            const isTimerRunning = this.timerState.isRunning && this.timerState.taskId === task.id;
            const playPauseButton = isTimerRunning
                ? `<button onclick="app.stopTimer(); app.showToast('‚è∏Ô∏è Timer paused', 'info', 2000);" class="timer-btn-pause" title="Pause Timer">‚è∏Ô∏è</button>`
                : `<button onclick="app.startTimer(${task.id}); app.showToast('‚ñ∂Ô∏è Timer resumed', 'info', 2000);" class="timer-btn-play" title="Start Timer">‚ñ∂Ô∏è</button>`;

            container.innerHTML = `
                <div class="timer-window-header">
                    <span class="timer-title">‚è±Ô∏è Time Tracker</span>
                    <div class="timer-controls">
                        ${playPauseButton}
                        <button onclick="app.toggleTimerWindow()" class="timer-btn-minimize" title="Minimize">‚àí</button>
                        <button onclick="app.stopTimer()" class="timer-btn-close" title="Stop Timer">√ó</button>
                    </div>
                </div>
                <div class="timer-content">
                    <div class="timer-task-name">üìå ${taskTitle}</div>
                    <div class="timer-display">
                        <div class="timer-stat">
                            <span class="timer-label">Current Session:</span>
                            <span class="timer-value">${this.formatDuration(sessionSeconds)}</span>
                        </div>
                        <div class="timer-stat">
                            <span class="timer-label">Total Time:</span>
                            <span class="timer-value">${this.formatDuration(totalSeconds)}</span>
                        </div>
                        <div class="timer-stat">
                            <span class="timer-label">Sessions:</span>
                            <span class="timer-value">${sessionCount + 1}</span>
                        </div>
                    </div>
                    ${sessionsHTML ? `
                        <div class="timer-sessions">
                            <div class="timer-sessions-label">Recent Sessions:</div>
                            ${sessionsHTML}
                        </div>
                    ` : ''}
                </div>
            `;
        }
    },

    /**
     * Toggle timer window between expanded and minimized
     */
    toggleTimerWindow() {
        this.timerWindowMinimized = !this.timerWindowMinimized;
        this.updateTimerDisplay();
    }
});

console.log('[timer-window.js] Timer window UI loaded');



// ============================================================
// UI/TIME-TRACKING-DASHBOARD.JS (Order: 38, Category: UI)
// ============================================================

/**
 * @module ui/time-tracking-dashboard
 * @order 38
 * @category UI
 *
 * Global time tracking dashboard - shows all tasks with tracked time
 */

Object.assign(app, {
    /**
     * Show global time tracking dashboard
     * Displays sortable table of all tasks with tracked time
     */
    showTimeTrackingDashboard() {
        const modal = document.getElementById('time-dashboard-modal');
        const content = document.getElementById('time-dashboard-content');

        // Get all tasks with tracked time
        const tasksWithTime = this.tasks
            .filter(t => t.timeTracking && t.timeTracking.totalSeconds > 0)
            .map(t => ({
                id: t.id,
                title: this.getTaskDisplayTitle(t, 40),
                totalSeconds: t.timeTracking.totalSeconds,
                sessionCount: t.timeTracking.sessions.length,
                lastWorked: t.timeTracking.sessions.length > 0
                    ? Math.max(...t.timeTracking.sessions.map(s => s.endTime))
                    : 0
            }))
            .sort((a, b) => b.lastWorked - a.lastWorked); // Default sort: most recent first

        if (tasksWithTime.length === 0) {
            content.innerHTML = `
                <p style="text-align: center; color: #999; padding: 60px 20px;">
                    No time tracked yet. Start working on a task (middle-click) to begin tracking time.
                </p>
            `;
        } else {
            // Build table HTML
            let html = `
                <div style="margin-bottom: 16px; display: flex; justify-content: space-between; align-items: center;">
                    <div>
                        <strong>${tasksWithTime.length}</strong> task${tasksWithTime.length !== 1 ? 's' : ''} with tracked time
                    </div>
                    <button onclick="app.exportTimeTracking()" style="padding: 6px 12px; font-size: 12px;">
                        üì• Export CSV
                    </button>
                </div>
                <table class="time-dashboard-table">
                    <thead>
                        <tr>
                            <th style="text-align: left; cursor: pointer;" onclick="app.sortTimeDashboard('title')">
                                Task <span style="font-size: 11px;">‚ñº</span>
                            </th>
                            <th style="cursor: pointer;" onclick="app.sortTimeDashboard('totalTime')">
                                Total Time <span style="font-size: 11px;">‚ñº</span>
                            </th>
                            <th style="cursor: pointer;" onclick="app.sortTimeDashboard('sessions')">
                                Sessions <span style="font-size: 11px;">‚ñº</span>
                            </th>
                            <th style="cursor: pointer;" onclick="app.sortTimeDashboard('lastWorked')">
                                Last Worked <span style="font-size: 11px;">‚ñº</span>
                            </th>
                            <th></th>
                        </tr>
                    </thead>
                    <tbody>
            `;

            tasksWithTime.forEach(task => {
                const totalTime = this.formatDurationCompact(task.totalSeconds);
                const lastWorked = this.formatRelativeTime(task.lastWorked);

                html += `
                    <tr>
                        <td style="max-width: 250px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;">
                            ${task.title}
                        </td>
                        <td style="text-align: center; font-weight: 600; color: #4CAF50;">
                            ${totalTime}
                        </td>
                        <td style="text-align: center;">
                            ${task.sessionCount}
                        </td>
                        <td style="text-align: center; color: #666;">
                            ${lastWorked}
                        </td>
                        <td style="text-align: right;">
                            <button onclick="app.jumpToTaskFromDashboard(${task.id})" style="padding: 4px 8px; font-size: 11px;">
                                üéØ Jump
                            </button>
                        </td>
                    </tr>
                `;
            });

            html += `
                    </tbody>
                </table>
            `;

            content.innerHTML = html;
        }

        modal.classList.add('show');

        // Close on ESC or click outside
        const closeHandler = (e) => {
            if (e.key === 'Escape' || e.target === modal) {
                this.hideTimeTrackingDashboard();
                document.removeEventListener('keydown', closeHandler);
                modal.removeEventListener('click', closeHandler);
            }
        };
        document.addEventListener('keydown', closeHandler);
        modal.addEventListener('click', closeHandler);

        // Store current sort state
        this.timeDashboardSort = { field: 'lastWorked', ascending: false };
    },

    /**
     * Hide time tracking dashboard
     */
    hideTimeTrackingDashboard() {
        const modal = document.getElementById('time-dashboard-modal');
        modal.classList.remove('show');
    },

    /**
     * Sort time dashboard table
     * @param {string} field - Field to sort by ('title', 'totalTime', 'sessions', 'lastWorked')
     */
    sortTimeDashboard(field) {
        // Toggle sort direction if clicking same field
        if (this.timeDashboardSort && this.timeDashboardSort.field === field) {
            this.timeDashboardSort.ascending = !this.timeDashboardSort.ascending;
        } else {
            this.timeDashboardSort = { field, ascending: false };
        }

        // Re-render with new sort
        this.showTimeTrackingDashboard();
    },

    /**
     * Jump to task from dashboard (with animation)
     * @param {number} taskId - Task ID to jump to
     */
    jumpToTaskFromDashboard(taskId) {
        const task = this.tasks.find(t => t.id === taskId);
        if (!task) return;

        this.hideTimeTrackingDashboard();

        // Select the task
        this.selectedTaskIds.clear();
        this.selectedTaskIds.add(taskId);

        // Animate to task
        this.animateViewportTo(task.x, task.y, 1, {
            overviewZoom: 0.3,
            onComplete: () => {
                this.updateZoomDisplay();
                this.saveToStorage();
                this.showToast(`Jumped to "${this.getTaskDisplayTitle(task, 30)}"`, 'success', 2000);
            }
        });
    },

    /**
     * Export time tracking data as CSV
     */
    exportTimeTracking() {
        const tasksWithTime = this.tasks.filter(t => t.timeTracking && t.timeTracking.totalSeconds > 0);

        if (tasksWithTime.length === 0) {
            this.showToast('‚ö†Ô∏è No time tracking data to export', 'warning');
            return;
        }

        // Build CSV content
        let csv = 'Task,Total Time (seconds),Total Time (formatted),Sessions,Last Worked\n';

        tasksWithTime.forEach(task => {
            const title = task.title.replace(/"/g, '""'); // Escape quotes
            const totalSeconds = task.timeTracking.totalSeconds;
            const totalFormatted = this.formatDuration(totalSeconds);
            const sessionCount = task.timeTracking.sessions.length;
            const lastWorked = sessionCount > 0
                ? new Date(Math.max(...task.timeTracking.sessions.map(s => s.endTime))).toLocaleString()
                : 'Never';

            csv += `"${title}",${totalSeconds},"${totalFormatted}",${sessionCount},"${lastWorked}"\n`;
        });

        // Download CSV
        const blob = new Blob([csv], { type: 'text/csv' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `time-tracking-${new Date().toISOString().split('T')[0]}.csv`;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);

        this.showToast(`üì• Exported ${tasksWithTime.length} tasks to CSV`, 'success');
    }
});

console.log('‚úì Time tracking dashboard mixin loaded');



// ============================================================
// UTILS/VIEWPORT-ANIMATION.JS (Order: 39, Category: Utils)
// ============================================================

/**
 * @module utils/viewport-animation
 * @order 39
 * @category Utils
 *
 * Smooth viewport navigation animations
 * Extracts duplicate code from jump.js and homes.js
 */

Object.assign(app, {
    /**
     * Smoothly animate viewport to target position with zoom
     *
     * Three-phase animation for smooth UX:
     * 1. Zoom out to overview (see both current and target)
     * 2. Pan to target location
     * 3. Zoom in to target zoom level
     *
     * This creates a natural "fly-over" effect that helps users
     * maintain spatial awareness during navigation.
     *
     * @param {number} targetX - Target X coordinate (center point)
     * @param {number} targetY - Target Y coordinate (center point)
     * @param {number} targetZoom - Target zoom level (default 1.0)
     * @param {Object} options - Animation options
     * @param {number} options.overviewZoom - Zoom level for overview phase (default 0.3)
     * @param {Function} options.onComplete - Callback when animation completes
     * @returns {Promise} Resolves when animation completes
     *
     * @example
     * // Jump to task with smooth animation
     * await app.animateViewportTo(task.x, task.y, 1.0, {
     *     onComplete: () => app.showToast('Navigation complete')
     * });
     */
    animateViewportTo(targetX, targetY, targetZoom = 1.0, options = {}) {
        const {
            overviewZoom = 0.3,
            onComplete = null,
        } = options;

        return new Promise((resolve) => {
            // Store starting state
            const startX = this.viewBox.x + this.viewBox.width / 2;
            const startY = this.viewBox.y + this.viewBox.height / 2;
            const startZoom = this.zoomLevel;

            // Calculate distances for pan
            const dx = targetX - startX;
            const dy = targetY - startY;

            // Phase 1: Zoom out to overview
            this._animatePhase(0, this.ANIMATION.ZOOM_OUT_MS, (progress) => {
                const t = this.ANIMATION.EASING(progress);
                this.zoomLevel = startZoom + (overviewZoom - startZoom) * t;
                this.render();
            }, () => {
                // Phase 2: Pan to target location
                this._animatePhase(0, this.ANIMATION.PAN_MS, (progress) => {
                    const t = this.ANIMATION.EASING(progress);
                    const currentX = startX + dx * t;
                    const currentY = startY + dy * t;

                    // Update viewBox center
                    this.viewBox.x = currentX - this.viewBox.width / 2;
                    this.viewBox.y = currentY - this.viewBox.height / 2;
                    this.render();
                }, () => {
                    // Phase 3: Zoom in to target level
                    this._animatePhase(0, this.ANIMATION.ZOOM_IN_MS, (progress) => {
                        const t = this.ANIMATION.EASING(progress);
                        this.zoomLevel = overviewZoom + (targetZoom - overviewZoom) * t;

                        // Recenter on target during zoom to prevent drift
                        this.viewBox.x = targetX - this.viewBox.width / 2;
                        this.viewBox.y = targetY - this.viewBox.height / 2;
                        this.render();
                    }, () => {
                        // Final positioning - ensure exact target state
                        this.zoomLevel = targetZoom;
                        this.viewBox.x = targetX - this.viewBox.width / 2;
                        this.viewBox.y = targetY - this.viewBox.height / 2;
                        this.render();

                        // Execute callback and resolve promise
                        if (onComplete) onComplete();
                        resolve();
                    });
                });
            });
        });
    },

    /**
     * Helper: Animate a single phase using requestAnimationFrame
     *
     * @param {number} startTime - Animation start time (0 for first frame)
     * @param {number} duration - Phase duration in milliseconds
     * @param {Function} onProgress - Callback with progress (0 to 1)
     * @param {Function} onComplete - Callback when phase complete
     * @private
     */
    _animatePhase(startTime, duration, onProgress, onComplete) {
        const animate = (currentTime) => {
            // Initialize start time on first frame
            if (startTime === 0) startTime = currentTime;

            // Calculate progress (0 to 1)
            const elapsed = currentTime - startTime;
            const progress = Math.min(elapsed / duration, 1.0);

            // Update via callback
            onProgress(progress);

            // Continue or complete
            if (progress < 1.0) {
                requestAnimationFrame(animate);
            } else {
                onComplete();
            }
        };

        requestAnimationFrame(animate);
    },

    /**
     * Instant jump to position (no animation)
     * Useful for immediate navigation or when animation is disabled
     *
     * @param {number} targetX - Target X coordinate (center)
     * @param {number} targetY - Target Y coordinate (center)
     * @param {number} targetZoom - Target zoom level (default 1.0)
     */
    jumpToPosition(targetX, targetY, targetZoom = 1.0) {
        this.zoomLevel = targetZoom;
        this.viewBox.x = targetX - this.viewBox.width / 2;
        this.viewBox.y = targetY - this.viewBox.height / 2;
        this.render();
    },
});

console.log('[viewport-animation.js] Smooth viewport navigation animations loaded');



// ============================================================
// NAVIGATION/VIEWPORT.JS (Order: 40, Category: navigation)
// ============================================================

/**
 * @module navigation/viewport
 * @order 40
 * @category navigation
 *
 * Zoom and pan viewport controls
 */

Object.assign(app, {
    zoomIn() {
        this.zoomLevel = Math.min(this.zoomLevel + this.zoomSpeed, this.maxZoom);
        this.updateZoomDisplay();
        this.render();
        this.saveToStorage();
    },

    zoomOut() {
        this.zoomLevel = Math.max(this.zoomLevel - this.zoomSpeed, this.minZoom);
        this.updateZoomDisplay();
        this.render();
        this.saveToStorage();
    },

    resetZoom() {
        this.zoomLevel = 1;
        this.updateZoomDisplay();
        this.render();
        this.saveToStorage();
    },

    zoomToFit() {
        if (this.tasks.length === 0) {
            this.resetZoom();
            return;
        }

        // Find bounding box of all visible tasks
        let minX = Infinity, maxX = -Infinity;
        let minY = Infinity, maxY = -Infinity;

        this.tasks.forEach(task => {
            if (!task.hidden) {
                minX = Math.min(minX, task.x - 50);
                maxX = Math.max(maxX, task.x + 50);
                minY = Math.min(minY, task.y - 30);
                maxY = Math.max(maxY, task.y + 30);
            }
        });

        if (minX === Infinity) {
            this.resetZoom();
            return;
        }

        const padding = 100;
        const width = maxX - minX + padding * 2;
        const height = maxY - minY + padding * 2;

        // Calculate zoom to fit
        const scaleX = this.viewBox.width / width;
        const scaleY = this.viewBox.height / height;
        this.zoomLevel = Math.min(scaleX, scaleY, this.maxZoom);
        this.zoomLevel = Math.max(this.zoomLevel, this.minZoom);

        this.updateZoomDisplay();
        this.render();
        this.saveToStorage();
    },

    calibrateCharWidth(isAutomatic = false) {
        // Measure actual character width for current font settings
        const svg = document.getElementById('canvas');

        // Create temporary text element with current font settings
        const tempText = document.createElementNS('http://www.w3.org/2000/svg', 'text');
        tempText.style.fontFamily = this.fontFamily;
        tempText.style.fontWeight = this.fontWeight;
        tempText.style.fontSize = '14px'; // Match task text size

        // Use a representative sample of characters (100 chars of varied types)
        const sampleText = 'The quick brown fox jumps over the lazy dog 0123456789 ABCDEFGHIJKLMNOPQRSTUVWXYZ abcdefghijklmnop';
        tempText.textContent = sampleText;
        tempText.setAttribute('x', 0);
        tempText.setAttribute('y', 0);

        // Temporarily add to DOM to measure
        svg.appendChild(tempText);
        const bbox = tempText.getBBox();
        const totalWidth = bbox.width;
        svg.removeChild(tempText);

        // Calculate average character width
        const measuredCharWidth = totalWidth / sampleText.length;

        // Update charWidth
        const oldCharWidth = this.charWidth;
        this.charWidth = Math.round(measuredCharWidth * 10) / 10; // Round to 1 decimal

        // Update the input field in settings modal
        const input = document.getElementById('setting-charWidth');
        if (input) {
            input.value = this.charWidth;
        }

        // Save and re-render
        this.saveToStorage();
        this.render();

        // Show feedback (different message for automatic vs manual calibration)
        if (!isAutomatic) {
            this.showToast(
                `Character width calibrated: ${oldCharWidth}px ‚Üí ${this.charWidth}px`,
                'success',
                3000
            );
        } else {
            this.showToast(
                `Auto-calibrated for new font: ${this.charWidth}px`,
                'info',
                2000
            );
        }
    },

    updateZoomDisplay() {
        const percent = Math.round(this.zoomLevel * 100);
        const display = document.getElementById('zoomLevel');
        if (display) {
            display.textContent = `${percent}%`;
        }
    },

    updateViewBoxOnly() {
        // Update just the SVG viewBox for smooth zoom animation
        // Used during animated transitions to avoid full re-render
        const svg = document.getElementById('canvas');
        const viewBoxWidth = this.viewBox.width / this.zoomLevel;
        const viewBoxHeight = this.viewBox.height / this.zoomLevel;
        svg.setAttribute('viewBox',
            `${this.viewBox.x - (viewBoxWidth - this.viewBox.width) / 2} ` +
            `${this.viewBox.y - (viewBoxHeight - this.viewBox.height) / 2} ` +
            `${viewBoxWidth} ${viewBoxHeight}`
        );
    }
});



// ============================================================
// NAVIGATION/HOMES.JS (Order: 41, Category: navigation)
// ============================================================

/**
 * @module navigation/homes
 * @order 41
 * @category navigation
 *
 * Home bookmarks for quick navigation with keyboard shortcuts
 *
 * Homes are saved viewport positions (centerX, centerY, zoomLevel) that can be:
 * - Created at current view position
 * - Navigated to with cinematic 3-phase animation
 * - Updated to current position
 * - Assigned keyboard shortcuts (0-9)
 * - Renamed and deleted
 *
 * KEY FUNCTIONS:
 *
 * createHome(name) - Create new home at current position
 * - Validates unique name
 * - Saves center of viewport + zoom level
 * - Warns if >20 homes exist
 *
 * jumpToHome(homeId, animate) - Navigate to home
 * - 3-phase cinematic animation (zoom out ‚Üí pan ‚Üí zoom in)
 * - Smooth easing for professional feel
 * - Total duration: 1300ms (300ms + 500ms + 500ms)
 * - Lines fade during animation, reappear perfectly after
 *
 * updateHome(homeId) - Update home to current position
 * - Preserves name and keybind
 * - Updates coordinates and zoom
 *
 * deleteHome(homeId) - Delete home with confirmation
 * - Respects showDeleteConfirmation setting
 *
 * setKeybindForHome(homeId) - Assign 0-9 keyboard shortcut
 * - Validates 0-9 keys only
 * - Handles conflicts (reassign keybind)
 * - ESC to clear keybind
 *
 * renameHome(homeId, newName) - Rename home
 * - Validates unique name (case-insensitive)
 *
 * SPECIAL HOME:
 * - "Origin Home" - Migrated from old origin system
 * - Always shown first in lists
 * - Special purple styling
 *
 * MODAL SYSTEM:
 * - Create Home modal (simple name input)
 * - Manage Homes modal (full CRUD interface)
 *
 * DROPDOWN MENU:
 * - Shows all homes sorted (Origin first, then alphabetical)
 * - Displays keybind if assigned: "Home Name [3]"
 * - Quick actions: Create New, Manage Homes
 */

Object.assign(app, {
    markOrigin() {
        // Create or update "Origin Home" to current view
        const originHome = this.homes.find(h => h.name === "Origin Home");

        if (originHome) {
            // Update existing Origin Home
            this.updateHome(originHome.id);
        } else {
            // Create new Origin Home
            this.createHome("Origin Home");
        }
    },

    createHome(name) {
        // Create a new home bookmark at current view position
        // Validates unique name and warns if >20 homes

        if (!name || name.trim() === '') {
            this.showToast('Home name cannot be empty', 'error');
            return false;
        }

        const trimmedName = name.trim();

        // Check for duplicate name (case-insensitive)
        const duplicate = this.homes.find(h => h.name.toLowerCase() === trimmedName.toLowerCase());
        if (duplicate) {
            this.showToast(`Home "${trimmedName}" already exists`, 'error');
            return false;
        }

        // Calculate center of current viewport (where user is currently looking)
        const centerX = this.viewBox.x + this.viewBox.width / 2;
        const centerY = this.viewBox.y + this.viewBox.height / 2;

        // Create new home
        const newHome = {
            id: this.homeIdCounter++,
            name: trimmedName,
            centerX: centerX,
            centerY: centerY,
            zoomLevel: this.zoomLevel,
            timestamp: Date.now(),
            keybind: null,  // No keybind by default
            icon: 'üè†'  // Default home icon
        };

        this.homes.push(newHome);
        this.saveToStorage();

        // Warn if >20 homes
        if (this.homes.length > 20) {
            this.showToast(`‚ö†Ô∏è Home "${trimmedName}" created (${this.homes.length} homes - consider organizing)`, 'warning', 3000);
        } else {
            this.showToast(`‚úì Home "${trimmedName}" created`, 'success');
        }

        return true;
    },

    jumpToHome(homeId, animate = true) {
        // Navigate to a saved home bookmark
        // Smoothly animates pan and zoom if animate=true

        const home = this.homes.find(h => h.id === homeId);
        if (!home) {
            this.showToast('Home not found', 'error');
            return;
        }

        if (this.tasks.length === 0) {
            this.showToast(`No tasks to navigate. Home "${home.name}" will apply when tasks exist.`, 'warning');
            return;
        }

        if (animate) {
            // Use utility function for smooth three-phase animation
            const startZoom = this.zoomLevel;
            const targetZoom = home.zoomLevel;
            const overviewZoom = Math.min(startZoom, targetZoom) * 0.5;

            this.animateViewportTo(home.centerX, home.centerY, targetZoom, {
                overviewZoom: overviewZoom,
                onComplete: () => {
                    this.updateZoomDisplay();
                    this.saveToStorage();
                    this.showToast(`‚Üí Jumped to "${home.name}"`, 'success');
                }
            });
        } else {
            // Instant jump without animation
            this.jumpToPosition(home.centerX, home.centerY, home.zoomLevel);
            this.updateZoomDisplay();
            this.saveToStorage();
            this.showToast(`‚Üí Jumped to "${home.name}"`, 'success');
        }
    },

    updateHome(homeId) {
        // Update an existing home to current view position and zoom

        const home = this.homes.find(h => h.id === homeId);
        if (!home) {
            this.showToast('Home not found', 'error');
            return;
        }

        // Calculate center of current viewport (where user is currently looking)
        const centerX = this.viewBox.x + this.viewBox.width / 2;
        const centerY = this.viewBox.y + this.viewBox.height / 2;

        home.centerX = centerX;
        home.centerY = centerY;
        home.zoomLevel = this.zoomLevel;
        home.timestamp = Date.now();

        this.saveToStorage();
        this.showToast(`‚úì Updated "${home.name}" to current view`, 'success');
    },

    deleteHome(homeId) {
        // Delete a home bookmark (with confirmation if enabled)

        const home = this.homes.find(h => h.id === homeId);
        if (!home) {
            this.showToast('Home not found', 'error');
            return;
        }

        const confirmDelete = () => {
            this.homes = this.homes.filter(h => h.id !== homeId);
            this.saveToStorage();
            this.showToast(`‚úì Deleted home "${home.name}"`, 'success');
        };

        if (this.showDeleteConfirmation) {
            this.showConfirmDialog(
                `Delete home "${home.name}"?`,
                'This action cannot be undone.',
                confirmDelete
            );
        } else {
            confirmDelete();
        }
    },

    setKeybindForHome(homeId) {
        // Set a keyboard shortcut for a home
        const home = this.homes.find(h => h.id === homeId);
        if (!home) return;

        // Show alert instructing user to press a key
        const message = home.keybind
            ? `Current keybind for "${home.name}": ${home.keybind}\n\nPress a key (0-9) to set new keybind, or press Escape to clear keybind.`
            : `Press a key (0-9) to set keybind for "${home.name}", or press Escape to cancel.`;

        this.showAlert('Set Keybind', message);

        // Capture next keypress
        const keyHandler = (e) => {
            // Remove listener immediately
            document.removeEventListener('keydown', keyHandler);

            // Close alert modal
            this.hideAlert();

            // Handle Escape key
            if (e.key === 'Escape') {
                if (home.keybind) {
                    // Clear existing keybind
                    home.keybind = null;
                    this.saveToStorage();
                    this.renderManageHomesModal();
                    this.showToast(`‚úì Keybind cleared for "${home.name}"`, 'success');
                }
                // Otherwise just cancel
                return;
            }

            // Only allow 0-9 keys
            if (!/^[0-9]$/.test(e.key)) {
                this.showToast('Only keys 0-9 are allowed for keybinds', 'error');
                return;
            }

            // Check if keybind is already used by another home
            const existingHome = this.homes.find(h => h.id !== homeId && h.keybind === e.key);
            if (existingHome) {
                this.showConfirm(
                    'Keybind Conflict',
                    `Key "${e.key}" is already assigned to "${existingHome.name}". Reassign it to "${home.name}"?`,
                    () => {
                        // Remove from old home
                        existingHome.keybind = null;
                        // Assign to new home
                        home.keybind = e.key;
                        this.saveToStorage();
                        this.renderManageHomesModal();
                        this.showToast(`‚úì Keybind "${e.key}" assigned to "${home.name}"`, 'success');
                    }
                );
            } else {
                // No conflict, assign keybind
                home.keybind = e.key;
                this.saveToStorage();
                this.renderManageHomesModal();
                this.showToast(`‚úì Keybind "${e.key}" assigned to "${home.name}"`, 'success');
            }
        };

        // Add listener for next keypress
        document.addEventListener('keydown', keyHandler);
    },

    renameHome(homeId, newName) {
        // Rename a home bookmark (validates unique name)

        const home = this.homes.find(h => h.id === homeId);
        if (!home) {
            this.showToast('Home not found', 'error');
            return false;
        }

        if (!newName || newName.trim() === '') {
            this.showToast('Home name cannot be empty', 'error');
            return false;
        }

        const trimmedName = newName.trim();

        // Check for duplicate name (case-insensitive), excluding current home
        const duplicate = this.homes.find(h =>
            h.id !== homeId && h.name.toLowerCase() === trimmedName.toLowerCase()
        );
        if (duplicate) {
            this.showToast(`Home "${trimmedName}" already exists`, 'error');
            return false;
        }

        const oldName = home.name;
        home.name = trimmedName;
        home.timestamp = Date.now();

        this.saveToStorage();
        this.showToast(`‚úì Renamed "${oldName}" to "${trimmedName}"`, 'success');
        return true;
    },

    setHomeIcon(homeId) {
        // Set a custom emoji icon for a home
        const home = this.homes.find(h => h.id === homeId);
        if (!home) return;

        // Show emoji picker to get emoji from user
        const title = `Set Icon for "${home.name}"`;

        this.showEmojiPicker(title, home.icon || 'üè†', (newIcon) => {
            if (!newIcon || newIcon.trim() === '') {
                this.showToast('Icon cannot be empty', 'error');
                return;
            }

            const trimmedIcon = newIcon.trim();

            // Update the icon
            home.icon = trimmedIcon;
            home.timestamp = Date.now();

            this.saveToStorage();
            this.renderManageHomesModal();
            this.render();  // Update indicators
            this.showToast(`‚úì Icon updated for "${home.name}"`, 'success');
        });
    },

    toggleHomesDropdown(event) {
        // Toggle the Homes dropdown menu
        event.stopPropagation();
        const dropdown = document.getElementById('homesDropdown');

        if (dropdown.classList.contains('show')) {
            dropdown.classList.remove('show');
        } else {
            this.renderHomesDropdown();
            dropdown.classList.add('show');

            // Close dropdown when clicking outside
            const closeDropdown = (e) => {
                if (!dropdown.contains(e.target) && !e.target.closest('.dropdown button')) {
                    dropdown.classList.remove('show');
                    document.removeEventListener('click', closeDropdown);
                }
            };
            setTimeout(() => document.addEventListener('click', closeDropdown), 0);
        }
    },

    renderHomesDropdown() {
        // Populate the Homes dropdown with current homes
        const dropdown = document.getElementById('homesDropdown');
        dropdown.innerHTML = '';

        if (this.homes.length === 0) {
            dropdown.innerHTML = '<div class="dropdown-empty">No homes created yet</div>';
        } else {
            // Sort homes: "Origin Home" first, then alphabetically
            const sortedHomes = [...this.homes].sort((a, b) => {
                if (a.name === "Origin Home") return -1;
                if (b.name === "Origin Home") return 1;
                return a.name.localeCompare(b.name);
            });

            sortedHomes.forEach(home => {
                const item = document.createElement('div');
                item.className = 'dropdown-item';
                if (home.name === "Origin Home") {
                    item.classList.add('special');
                }

                // Display home icon + name with keybind if it exists
                const icon = home.icon || 'üè†';
                const nameText = home.keybind ? `${home.name} [${home.keybind}]` : home.name;
                item.textContent = `${icon} ${nameText}`;

                item.onclick = (e) => {
                    e.stopPropagation();
                    this.jumpToHome(home.id);
                    dropdown.classList.remove('show');
                };
                dropdown.appendChild(item);
            });
        }

        // Add divider and actions
        if (this.homes.length > 0) {
            const divider = document.createElement('div');
            divider.className = 'dropdown-divider';
            dropdown.appendChild(divider);
        }

        const createItem = document.createElement('div');
        createItem.className = 'dropdown-item special';
        createItem.innerHTML = '+ Create New Home';
        createItem.onclick = (e) => {
            e.stopPropagation();
            this.showCreateHomeModal();
            dropdown.classList.remove('show');
        };
        dropdown.appendChild(createItem);

        const manageItem = document.createElement('div');
        manageItem.className = 'dropdown-item';
        manageItem.innerHTML = '‚öôÔ∏è Manage Homes';
        manageItem.onclick = (e) => {
            e.stopPropagation();
            this.showManageHomesModal();
            dropdown.classList.remove('show');
        };
        dropdown.appendChild(manageItem);
    },

    showCreateHomeModal() {
        // Show the Create Home modal
        const modal = document.getElementById('create-home-modal');
        const input = document.getElementById('home-name-input');
        input.value = '';
        modal.style.display = 'flex';
        setTimeout(() => input.focus(), 100);
    },

    hideCreateHomeModal() {
        // Hide the Create Home modal
        document.getElementById('create-home-modal').style.display = 'none';
    },

    createHomeFromModal() {
        // Create a new home from the modal input
        const input = document.getElementById('home-name-input');
        const name = input.value.trim();

        if (this.createHome(name)) {
            this.hideCreateHomeModal();
        }
    },

    showManageHomesModal() {
        // Show the Manage Homes modal
        const modal = document.getElementById('manage-homes-modal');
        this.renderManageHomesModal();
        modal.style.display = 'flex';
    },

    hideManageHomesModal() {
        // Hide the Manage Homes modal
        document.getElementById('manage-homes-modal').style.display = 'none';
    },

    renderManageHomesModal() {
        // Populate the Manage Homes modal with current homes
        const container = document.getElementById('homes-list');
        container.innerHTML = '';

        if (this.homes.length === 0) {
            container.innerHTML = '<div style="text-align: center; color: #999; padding: 40px; font-style: italic;">No homes created yet</div>';
            return;
        }

        // Sort homes: "Origin Home" first, then alphabetically
        const sortedHomes = [...this.homes].sort((a, b) => {
            if (a.name === "Origin Home") return -1;
            if (b.name === "Origin Home") return 1;
            return a.name.localeCompare(b.name);
        });

        sortedHomes.forEach(home => {
            const homeCard = document.createElement('div');
            homeCard.style.cssText = `
                background: ${home.name === "Origin Home" ? 'rgba(156, 39, 176, 0.1)' : 'rgba(255, 255, 255, 0.05)'};
                border: 1px solid ${home.name === "Origin Home" ? 'rgba(156, 39, 176, 0.3)' : 'rgba(255, 255, 255, 0.1)'};
                border-radius: 8px;
                padding: 16px;
                margin-bottom: 12px;
                display: flex;
                justify-content: space-between;
                align-items: center;
            `;

            const infoDiv = document.createElement('div');
            infoDiv.style.cssText = 'flex: 1;';

            const nameSpan = document.createElement('div');
            const icon = home.icon || 'üè†';
            nameSpan.textContent = `${icon} ${home.name}`;
            // Use light colors in dark mode for visibility
            const isDarkMode = document.body.classList.contains('dark-mode');
            const nameColor = home.name === "Origin Home" ? '#9c27b0' : (isDarkMode ? '#e2e8f0' : '#333');
            nameSpan.style.cssText = `
                font-weight: 600;
                font-size: 15px;
                margin-bottom: 6px;
                color: ${nameColor};
            `;

            const detailsSpan = document.createElement('div');
            const keybindText = home.keybind ? ` ‚Ä¢ Keybind: ${home.keybind}` : '';
            detailsSpan.textContent = `Zoom: ${home.zoomLevel.toFixed(1)}x ‚Ä¢ Position: (${Math.round(home.centerX)}, ${Math.round(home.centerY)})${keybindText}`;
            const detailsColor = isDarkMode ? '#94a3b8' : '#666';
            detailsSpan.style.cssText = `font-size: 12px; color: ${detailsColor};`;

            infoDiv.appendChild(nameSpan);
            infoDiv.appendChild(detailsSpan);

            const actionsDiv = document.createElement('div');
            actionsDiv.style.cssText = 'display: flex; gap: 8px;';

            // Jump button
            const jumpBtn = document.createElement('button');
            jumpBtn.textContent = '‚Üí Jump';
            jumpBtn.style.cssText = 'padding: 6px 12px; font-size: 13px;';
            jumpBtn.onclick = () => {
                this.jumpToHome(home.id);
                this.hideManageHomesModal();
            };
            actionsDiv.appendChild(jumpBtn);

            // Update button
            const updateBtn = document.createElement('button');
            updateBtn.className = 'secondary';
            updateBtn.textContent = '‚Üª Update';
            updateBtn.style.cssText = 'padding: 6px 12px; font-size: 13px;';
            updateBtn.onclick = () => {
                this.updateHome(home.id);
                this.renderManageHomesModal();
            };
            actionsDiv.appendChild(updateBtn);

            // Keybind button
            const keybindBtn = document.createElement('button');
            keybindBtn.className = 'secondary';
            keybindBtn.textContent = home.keybind ? `‚å® ${home.keybind}` : '‚å® Set Key';
            keybindBtn.style.cssText = 'padding: 6px 12px; font-size: 13px;';
            keybindBtn.onclick = () => {
                this.setKeybindForHome(home.id);
            };
            actionsDiv.appendChild(keybindBtn);

            // Set Icon button
            const setIconBtn = document.createElement('button');
            setIconBtn.className = 'secondary';
            setIconBtn.textContent = `${home.icon || 'üè†'} Icon`;
            setIconBtn.style.cssText = 'padding: 6px 12px; font-size: 13px;';
            setIconBtn.onclick = () => {
                this.setHomeIcon(home.id);
            };
            actionsDiv.appendChild(setIconBtn);

            // Rename button
            const renameBtn = document.createElement('button');
            renameBtn.className = 'secondary';
            renameBtn.textContent = '‚úé Rename';
            renameBtn.style.cssText = 'padding: 6px 12px; font-size: 13px;';
            renameBtn.onclick = () => {
                const newName = prompt(`Rename "${home.name}" to:`, home.name);
                if (newName) {
                    if (this.renameHome(home.id, newName)) {
                        this.renderManageHomesModal();
                    }
                }
            };
            actionsDiv.appendChild(renameBtn);

            // Delete button
            const deleteBtn = document.createElement('button');
            deleteBtn.className = 'secondary';
            deleteBtn.textContent = '‚úï Delete';
            deleteBtn.style.cssText = 'padding: 6px 12px; font-size: 13px; color: #f44336;';
            deleteBtn.onclick = () => {
                this.deleteHome(home.id);
                this.renderManageHomesModal();
            };
            actionsDiv.appendChild(deleteBtn);

            homeCard.appendChild(infoDiv);
            homeCard.appendChild(actionsDiv);
            container.appendChild(homeCard);
        });
    }
});

console.log('[homes.js] Home bookmarks navigation loaded');



// ============================================================
// NAVIGATION/JUMP.JS (Order: 42, Category: navigation)
// ============================================================

/**
 * @module navigation/jump
 * @order 42
 * @category navigation
 *
 * Jump to working tasks with smart defaults
 *
 * NOTE: Jump functions remain in task-tree.html (lines 7082-7381)
 * This file documents the jump navigation architecture.
 *
 * KEY FUNCTIONS:
 *
 * jumpToWorkingTask(taskId) - Line 7082-7217
 * - Animates viewport to center on working task
 * - Smooth easing animation (60 steps)
 * - Updates viewBox during transition
 * - Updates parent link arrows during animation (golden path)
 * - Tracks lastWorkingTaskId for smart defaults
 * - Shows toast notification with task name
 * - Adjusts zoom if needed
 *
 * showWorkingTasksDropdown() - Line 7219-7381
 * - Shows dropdown of all working tasks
 * - One per root graph (multi-project support)
 * - Menu features:
 *   - Numbered items (1-9) for keyboard selection
 *   - "(last)" indicator for lastWorkingTaskId
 *   - Task name + root path
 *   - Click to jump to task
 *   - Keyboard: Press number key to jump
 *   - ESC to close
 * - Positioned below "Jump to Working" button
 * - Keyboard handler for 1-9 and J keys
 * - Smart behavior:
 *   - Single working task: Jump directly (no dropdown)
 *   - Multiple tasks: Show dropdown
 *   - Press J again: Jump to last selected
 *
 * SMART DEFAULT BEHAVIOR:
 * - lastWorkingTaskId tracks most recently jumped-to task
 * - Updated on:
 *   - jumpToWorkingTask() call
 *   - Selecting task from dropdown
 *   - Middle-clicking task (cycleStatus ‚Üí working)
 * - Used for:
 *   - J key double-press (open menu ‚Üí press J again ‚Üí jump to last)
 *   - Default menu item highlighting
 *
 * KEYBOARD NAVIGATION:
 * - J: Open working tasks menu
 * - J (again): Jump to last selected working task
 * - 1-9: Jump to numbered task in menu
 * - ESC: Close menu
 *
 * MULTI-PROJECT SUPPORT:
 * - Finds one working task per root graph
 * - Uses workingTasksByRoot map for O(1) lookup
 * - Shows root path for context
 * - Allows working on multiple independent projects
 *
 * ANIMATION:
 * - 60-step smooth easing
 * - Updates viewBox each frame (updateViewBoxOnly)
 * - Updates parent links during animation
 * - Golden path arrows animate smoothly
 * - 16ms per frame (~60 FPS)
 *
 * VIEWPORT ADJUSTMENT:
 * - Centers task in viewport
 * - Adjusts zoom if task is too small/large
 * - Maintains reasonable zoom range (0.5-2.0)
 * - Preserves zoom if task already visible
 */

Object.assign(app, {
    jumpToWorkingTask(taskId = null, animate = true) {
        let workingTask = null;
        if (taskId) {
            workingTask = this.tasks.find(t => t.id === taskId && t.currentlyWorking);
            if (workingTask) {
                this.lastWorkingTaskId = taskId;
            }
        } else if (this.lastWorkingTaskId) {
            workingTask = this.tasks.find(t => t.id === this.lastWorkingTaskId && t.currentlyWorking);
        }

        if (!workingTask) {
            workingTask = this.tasks.find(t => t.currentlyWorking);
        }

        if (!workingTask) {
            this.showToast('No task is currently being worked on', 'warning');
            return;
        }

        if (this.tasks.length === 0) return;

        const wasHidden = workingTask.hidden;
        if (wasHidden) {
            workingTask.hidden = false;
        }

        const targetZoom = 1.2;
        const taskTitle = this.truncateTitle(workingTask.title);

        if (animate) {
            // Use utility function for smooth three-phase animation
            const startZoom = this.zoomLevel;
            const overviewZoom = Math.min(startZoom, targetZoom) * 0.5;

            this.animateViewportTo(workingTask.x, workingTask.y, targetZoom, {
                overviewZoom: overviewZoom,
                onComplete: () => {
                    this.updateZoomDisplay();
                    this.saveToStorage();
                    this.showToast(`üéØ Jumped to "${taskTitle}"`, 'success');
                }
            });
        } else {
            // Instant jump without animation
            this.jumpToPosition(workingTask.x, workingTask.y, targetZoom);
            this.updateZoomDisplay();
            this.saveToStorage();
            this.showToast(`üéØ Jumped to "${taskTitle}"`, 'success');
        }
    },

    showWorkingTasksDropdown(event, keyboardMode = false) {
        if (event) event.stopPropagation();
        const workingTasks = this.tasks.filter(t => t.currentlyWorking);
        if (workingTasks.length === 0) {
            this.showToast('No task is currently being worked on', 'warning');
            return;
        }
        if (workingTasks.length === 1 && !keyboardMode) {
            this.jumpToWorkingTask();
            return;
        }
        const dropdown = document.createElement('div');
        dropdown.id = 'working-tasks-dropdown';
        const bgColor = this.darkMode ? '#1e293b' : 'white';
        const borderColor = this.darkMode ? '#475569' : '#ccc';
        dropdown.style.cssText = `position:fixed;bottom:60px;right:10px;background:${bgColor};border:1px solid ${borderColor};border-radius:8px;box-shadow:0 4px 12px rgba(0,0,0,0.3);z-index:3000;min-width:250px;max-height:400px;overflow-y:auto;`;

        const header = document.createElement('div');
        header.style.cssText = `padding:10px 12px;border-bottom:1px solid ${borderColor};display:flex;justify-content:space-between;align-items:center;`;
        const headerTitle = document.createElement('span');
        const textColor = this.darkMode ? '#f1f5f9' : '#333';
        headerTitle.style.cssText = `font-weight:600;font-size:13px;color:${textColor};`;
        headerTitle.textContent = 'Working On:';
        const headerHint = document.createElement('span');
        const hintColor = this.darkMode ? '#94a3b8' : '#999';
        headerHint.style.cssText = `font-size:11px;color:${hintColor};font-weight:400;`;
        headerHint.textContent = 'Press 1-9 or J';
        header.appendChild(headerTitle);
        header.appendChild(headerHint);
        dropdown.appendChild(header);

        workingTasks.forEach((task, index) => {
            const item = document.createElement('div');
            const truncatedTitle = task.title.length > 35 ? task.title.substring(0, 32) + '...' : task.title;
            const isLast = task.id === this.lastWorkingTaskId;
            const number = index + 1;
            const itemTextColor = this.darkMode ? '#e2e8f0' : '#333';
            const lastBg = isLast ? (this.darkMode ? 'rgba(59,130,246,0.2)' : 'rgba(33,150,243,0.1)') : 'transparent';
            const borderLeftColor = isLast ? '#2196f3' : 'transparent';
            item.style.cssText = `padding:10px 12px;cursor:pointer;font-size:13px;color:${itemTextColor};background:${lastBg};border-left:3px solid ${borderLeftColor};display:flex;align-items:center;gap:10px;`;

            const badge = document.createElement('span');
            const badgeBg = this.darkMode ? 'rgba(59,130,246,0.4)' : 'rgba(33,150,243,0.2)';
            const badgeColor = this.darkMode ? '#93c5fd' : '#1565c0';
            badge.style.cssText = `background:${badgeBg};color:${badgeColor};padding:2px 7px;border-radius:3px;font-size:11px;font-weight:600;min-width:18px;text-align:center;`;
            badge.textContent = number;

            const text = document.createElement('span');
            text.textContent = `üîÑ ${truncatedTitle}${isLast ? ' (last)' : ''}`;
            item.appendChild(badge);
            item.appendChild(text);

            const hoverBg = this.darkMode ? 'rgba(59,130,246,0.3)' : 'rgba(33,150,243,0.2)';
            item.onmouseover = () => { item.style.background = hoverBg; };
            item.onmouseout = () => { item.style.background = lastBg; };
            item.onclick = () => {
                this.jumpToWorkingTask(task.id);
                dropdown.remove();
            };
            dropdown.appendChild(item);
        });

        const keyboardHandler = (e) => {
            if (e.key === 'Escape') {
                e.preventDefault();
                dropdown.remove();
                document.removeEventListener('keydown', keyboardHandler);
                document.removeEventListener('click', closeDropdown);
                return;
            }
            if (/^[1-9]$/.test(e.key)) {
                e.preventDefault();
                const index = parseInt(e.key) - 1;
                if (index < workingTasks.length) {
                    this.jumpToWorkingTask(workingTasks[index].id);
                    dropdown.remove();
                    document.removeEventListener('keydown', keyboardHandler);
                    document.removeEventListener('click', closeDropdown);
                }
            }
        };

        const closeDropdown = (e) => {
            if (!dropdown.contains(e.target) && e.target.id !== 'jump-dropdown-btn') {
                dropdown.remove();
                document.removeEventListener('click', closeDropdown);
                document.removeEventListener('keydown', keyboardHandler);
            }
        };

        document.body.appendChild(dropdown);
        setTimeout(() => {
            document.addEventListener('click', closeDropdown);
            document.addEventListener('keydown', keyboardHandler);
        }, 10);
    }
});

console.log('[jump.js] Jump to working task navigation loaded');



// ============================================================
// NAVIGATION/TEXT-LOCK.JS (Order: 43, Category: navigation)
// ============================================================

/**
 * @module navigation/text-lock
 * @order 43
 * @category navigation
 *
 * Text expansion and lock controls
 *
 * NOTE: Text expansion functions remain in task-tree.html (lines 7776-7807)
 * This file documents the text expansion architecture.
 *
 * KEY FUNCTIONS:
 *
 * updateTextLengthThreshold() - Line 7776-7785
 * - Updates text length threshold from input
 * - Reads value from settings form
 * - Updates app.textLengthThreshold
 * - Saves to localStorage
 * - Re-renders canvas
 *
 * expandText(taskId) - Line 7787-7795
 * - Expands truncated text temporarily
 * - Sets task.textExpanded = true
 * - Re-renders to show full text
 * - Used for:
 *   - Clicking on truncated text
 *   - Selecting task
 *   - Editing task
 *
 * toggleTextLock(taskId) - Line 7797-7807
 * - Toggles persistent text expansion
 * - Sets task.textLocked = true/false
 * - Saves to localStorage
 * - Re-renders canvas
 * - Shows lock/unlock icon (üîí/üîì)
 * - Disabled for working tasks (always expanded)
 *
 * TEXT EXPANSION LOGIC:
 *
 * A task's text is expanded (full text shown) if ANY of:
 * 1. task.currentlyWorking = true (working tasks always expanded)
 * 2. task.textLocked = true (user explicitly locked expansion)
 * 3. task.textExpanded = true AND task is selected (temporary expansion)
 *
 * A task's text is truncated if:
 * - task.title.length > textLengthThreshold
 * - AND charsOverLimit > 5 (don't truncate for minor overflow)
 * - AND NOT expanded (none of above conditions met)
 *
 * LOCK BUTTON:
 * - Appears on expanded long text
 * - Positioned to left of task node
 * - Shows üîí (locked) or üîì (unlocked)
 * - Click to toggle lock state
 * - Disabled for working tasks (cursor: not-allowed, opacity: 0.4)
 * - Gray background circle for visibility
 *
 * TRUNCATION THRESHOLD:
 * - Default: 60 characters
 * - Configurable in settings
 * - Only truncates if >5 chars over threshold
 * - Shows "..." at end
 * - Multiline: truncates last visible line
 *
 * INTERACTION:
 * - Clicking truncated text expands it
 * - Selecting task expands text temporarily
 * - Lock persists across selection changes
 * - Working tasks always show full text
 * - Editing always shows full text
 *
 * USE CASES:
 * - Long task descriptions
 * - URLs in task text (before extraction)
 * - Multiline notes
 * - Keep important tasks expanded
 * - Declutter canvas with truncation
 */

Object.assign(app, {
    /**
     * Update text length threshold from input
     * Reads value from settings form, validates, and saves
     */
    updateTextLengthThreshold() {
        const input = document.getElementById('textLengthInput');
        if (!input) return; // Input removed, use Settings modal instead
        const value = parseInt(input.value);
        if (value >= 10 && value <= 100) {
            this.textLengthThreshold = value;
            this.saveToStorage();
            this.render();
        }
    },

    /**
     * Expand truncated text temporarily
     * Sets task.textExpanded = true to show full text
     * Used when clicking on truncated text or selecting task
     * @param {number} taskId - Task ID to expand
     */
    expandText(taskId) {
        // Expand text on click
        const task = this.tasks.find(t => t.id === taskId);
        if (task) {
            task.textExpanded = true;
            this.saveToStorage();
            this.render();
        }
    },

    /**
     * Toggle text expansion lock for a task
     * When locked, task text stays expanded even when not selected/working
     * When unlocked and not selected/working, text collapses immediately
     * @param {number} taskId - Task ID to toggle lock for
     */
    toggleTextLock(taskId) {
        // Toggle lock state
        const task = this.tasks.find(t => t.id === taskId);
        if (task) {
            task.textLocked = !task.textLocked;

            // If unlocking and node is NOT selected, collapse immediately
            if (!task.textLocked && !this.selectedTaskIds.has(taskId) && !task.currentlyWorking) {
                task.textExpanded = false;
            }

            this.saveToStorage();
            this.render();
        }
    }
});

console.log('[text-lock.js] Text expansion and lock controls loaded');



// ============================================================
// APP.JS (Order: 100, Category: app)
// ============================================================

// @order: 100
// @category: app
// @description: Main application entry point - initialization and event listeners

/**
 * Application Initialization and Event Listeners
 *
 * This module contains:
 * - init(): Application initialization sequence
 * - setupEventListeners(): Wire up all DOM event handlers
 * - updateShortcutsHelp(): Update keyboard shortcut help text
 *
 * Load Order: This file has @order: 100 to ensure it loads LAST,
 * after all mixin methods have been added to the app object.
 */

Object.assign(app, {
    /**
     * Initialize the application
     *
     * Sequence:
     * 1. Load data from localStorage
     * 2. Repair corrupted working task states
     * 3. Center viewBox on tasks (first-time users only)
     * 4. Setup DOM event listeners
     * 5. Update UI help text
     * 6. Initial render
     */
    async init() {
        const data = localStorage.getItem('taskTree');
        const parsed = data ? JSON.parse(data) : null;
        const hasStoredViewBox = parsed && parsed.viewBoxX !== undefined && parsed.viewBoxY !== undefined;

        // Initialize IndexedDB image store
        await this.initImageStore();

        this.loadFromStorage();

        // Auto-repair any corrupted working task states on load (silent mode)
        this.repairWorkingTasks(true);

        // Center viewBox on tasks ONLY if no saved viewBox position exists
        // (for first-time users or migrating from old version)
        if (!hasStoredViewBox && this.tasks.length > 0) {
            const centerX = this.tasks.reduce((sum, t) => sum + t.x, 0) / this.tasks.length;
            const centerY = this.tasks.reduce((sum, t) => sum + t.y, 0) / this.tasks.length;
            this.viewBox.x = centerX - this.viewBox.width / 2;
            this.viewBox.y = centerY - this.viewBox.height / 2;
        }

        this.setupEventListeners();
        this.updateShortcutsHelp();
        this.updateStatusBar();
        this.render();
    },

    /**
     * Update keyboard shortcuts help text in UI
     *
     * Updates:
     * - #shortcuts-help element with platform-specific modifiers
     * - Button tooltips with keyboard hints
     */
    updateShortcutsHelp() {
        // Update the shortcuts help text with platform-specific modifiers
        const mod = this.getModifierKey();
        const shift = this.getShiftKey();

        const helpElement = document.getElementById('shortcuts-help');
        if (helpElement) {
            helpElement.textContent = `Double-click: edit | ${mod}+Dbl-click: create | ${shift}+Double-click: hide/show | ${mod}+Drag: reparent | Right-click: menu | ${mod}+Click: multi-select | Backspace: delete | Middle-click: cycle | ${mod}+K: link | P: priority | J: jump | ${shift}+Drag: subtree | ${mod}+C: copy | ${mod}+V: paste (auto-detects image) | ${mod}+Z: undo`;
        }

        // Update tooltips with platform-specific text
        const jumpBtn = document.getElementById('jump-to-working-btn');
        if (jumpBtn) {
            jumpBtn.title = 'Jump to working task (J)';
        }
    },

    /**
     * Setup all DOM event listeners
     *
     * Event categories:
     * - Mouse: click, dblclick, mousedown, mousemove, mouseup, contextmenu
     * - Keyboard: keydown for all shortcuts
     * - Wheel: zoom with mouse wheel/trackpad
     * - Window: resize to adjust viewBox
     * - Modals: click outside to close
     */
    setupEventListeners() {
        const container = document.getElementById('canvas-container');
        const svg = document.getElementById('canvas');

        // ========================================
        // Mouse Events (delegate to mouse.js handlers)
        // ========================================
        svg.addEventListener('mousedown', (e) => this.onCanvasMouseDown(e));
        svg.addEventListener('mousemove', (e) => this.onCanvasMouseMove(e));
        svg.addEventListener('mouseup', (e) => this.onCanvasMouseUp(e));

        // ========================================
        // Double-Click Events
        // ========================================
        svg.addEventListener('dblclick', (e) => {
            if (this.editingTaskId !== null) return; // Already editing

            // Check if double-clicking on arrow dot (reset to default position)
            if (e.target.classList && e.target.classList.contains('arrow-dot')) {
                const dotType = e.target.getAttribute('data-dot-type');
                const taskId = parseInt(e.target.getAttribute('data-task-id'));
                const relatedId = parseInt(e.target.getAttribute('data-related-id'));

                // For source dots: taskId is parent, relatedId is child
                // For target dots: taskId is child, relatedId is parent
                const dotInfo = {
                    type: dotType,
                    taskId: taskId
                };

                if (dotType === 'source') {
                    dotInfo.childId = relatedId;
                } else {
                    dotInfo.parentId = relatedId;
                }

                this.resetArrowPosition(dotInfo);

                e.preventDefault();
                e.stopPropagation();
                return;
            }

            // Check if double-clicking on curve control dot (remove this control point)
            // ONLY works when Ctrl is held
            if (e.target.classList && e.target.classList.contains('curve-dot') && (e.ctrlKey || e.metaKey)) {
                const linkType = e.target.getAttribute('data-link-type');
                const taskId = parseInt(e.target.getAttribute('data-task-id'));
                const relatedId = parseInt(e.target.getAttribute('data-related-id'));
                const pointIndex = parseInt(e.target.getAttribute('data-point-index'));

                this.removeControlPoint({
                    linkType: linkType,
                    taskId: taskId,
                    relatedTaskId: relatedId,
                    pointIndex: pointIndex
                });

                e.preventDefault();
                e.stopPropagation();
                return;
            }

            // Try to find task-node by traversing up DOM
            let element = e.target;
            while (element && element !== svg) {
                if (element.dataset && element.dataset.id && element.classList?.contains('task-node')) {
                    const taskId = parseInt(element.dataset.id);

                    if (e.ctrlKey || e.metaKey) {
                        // Ctrl+double click on node: create child task
                        this.addChildTask(taskId);
                    } else if (e.shiftKey) {
                        // Shift+double click: hide/show the node itself
                        this.toggleHiddenSelf(taskId);
                    } else {
                        // Normal double click: edit task name
                        this.startEditing(taskId);
                    }

                    e.preventDefault();
                    e.stopPropagation();
                    return;
                }
                element = element.parentElement;
            }

            // Ctrl+double-click on empty space: create root task at cursor
            if (e.ctrlKey || e.metaKey) {
                const pt = this.getSVGPoint(e);
                this.addRootTaskAtPosition(pt.x, pt.y);
                e.preventDefault();
                e.stopPropagation();
            }
        });

        // ========================================
        // Middle Mouse Button (cycle status)
        // ========================================
        svg.addEventListener('mousedown', (e) => {
            if (e.button === 1) { // Middle mouse button
                const node = e.target.closest('.task-node');
                if (node) {
                    const taskId = parseInt(node.dataset.id);
                    this.cycleStatus(taskId);
                    e.preventDefault();
                    e.stopPropagation();
                }
            }
        });

        // ========================================
        // Click Events (selection, multi-select)
        // ========================================
        svg.addEventListener('click', (e) => {
            const node = e.target.closest('.task-node');

            if (node) {
                const taskId = parseInt(node.dataset.id);

                // Alt+click: Delete node
                if (e.altKey && !e.ctrlKey && !e.metaKey) {
                    this.deleteTask(taskId);
                    e.preventDefault();
                    e.stopPropagation();
                    return;
                }

                // Ctrl+click: Multi-select (toggle selection)
                if ((e.ctrlKey || e.metaKey) && !e.altKey) {
                    if (this.selectedTaskIds.has(taskId)) {
                        this.selectedTaskIds.delete(taskId);
                    } else {
                        this.selectedTaskIds.add(taskId);
                    }
                    this.lastClickedTaskId = taskId;
                    requestAnimationFrame(() => this.render());
                    e.preventDefault();
                    e.stopPropagation();
                    return;
                }

                // Plain left-click: Select only this node (clear others)
                if (!e.ctrlKey && !e.metaKey && !e.altKey && !e.shiftKey) {
                    this.selectedTaskIds.clear();
                    this.selectedTaskIds.add(taskId);
                    this.lastClickedTaskId = taskId;
                    requestAnimationFrame(() => this.render());
                    return;
                }

                // Shift+click: Reserved for future use
                if (e.shiftKey && !e.ctrlKey && !e.metaKey && !e.altKey) {
                    // Currently unused - available for future feature
                    // For now, treat as regular click
                    this.selectedTaskIds.clear();
                    this.selectedTaskIds.add(taskId);
                    this.lastClickedTaskId = taskId;
                    requestAnimationFrame(() => this.render());
                    return;
                }
            }

            // Click on arrow: select it (arrows can be <path> or <line> elements)
            if ((e.target.tagName === 'path' || e.target.tagName === 'line') && e.target.classList.contains('link')) {
                const arrow = e.target;
                if (arrow.dataset.type && !e.ctrlKey && !e.metaKey && !e.altKey) {
                    // Select the arrow
                    if (arrow.dataset.type === 'parent') {
                        this.selectedLine = {
                            type: 'parent',
                            taskId: parseInt(arrow.dataset.taskId),
                            parentId: parseInt(arrow.dataset.parentId)
                        };

                        // Update timestamp to prioritize this arrow's dots
                        this.updateArrowTimestamp(parseInt(arrow.dataset.taskId), parseInt(arrow.dataset.parentId));
                    } else if (arrow.dataset.type === 'dependency') {
                        this.selectedLine = {
                            type: 'dependency',
                            from: parseInt(arrow.dataset.from),
                            to: parseInt(arrow.dataset.to)
                        };
                    }
                    this.selectedTaskIds.clear(); // Clear node selection
                    this.render();
                    e.preventDefault();
                    e.stopPropagation();
                    return;
                }
            }
        });

        // ========================================
        // Context Menu (right-click)
        // ========================================
        svg.addEventListener('contextmenu', (e) => {
            e.preventDefault();
            e.stopPropagation();

            const node = e.target.closest('.task-node');
            if (node) {
                // Right-click on node
                const taskId = parseInt(node.dataset.id);
                this.showNodeMenu(e, taskId);
            } else {
                // Right-click on empty space
                this.showEmptySpaceMenu(e);
            }
        });

        // Close menu when clicking elsewhere
        document.addEventListener('click', (e) => {
            const menu = document.querySelector('.node-menu');
            if (menu) {
                if (!e.target.closest('.node-menu')) {
                    this.closeMenu();
                }
            }
        });

        // ========================================
        // Keyboard Events (shortcuts)
        // ========================================

        // Backspace/Delete to delete selected node(s) or line
        document.addEventListener('keydown', (e) => {
            // Don't trigger shortcuts when modal is open
            const anyModalOpen = document.querySelector('.modal.show');
            if (anyModalOpen) return;

            if (e.key === 'Backspace' && this.editingTaskId === null) {
                if (this.selectedTaskIds.size > 0) {
                    e.preventDefault();
                    // Delete all selected tasks
                    const selectedArray = Array.from(this.selectedTaskIds);
                    if (selectedArray.length === 1) {
                        this.deleteTask(selectedArray[0]);
                    } else {
                        this.deleteMultipleTasks(selectedArray);
                    }
                } else if (this.selectedLine) {
                    e.preventDefault();
                    this.deleteLine(this.selectedLine);
                }
            }

            // Escape to clear selection
            if (e.key === 'Escape' && this.editingTaskId === null) {
                // Check if any modal is open - if so, let the modal's handler handle it
                const anyModalOpen = document.querySelector('.modal.show');
                if (!anyModalOpen && (this.selectedTaskIds.size > 0 || this.selectedLine)) {
                    this.selectedTaskIds.clear();
                    this.selectedLine = null;
                    this.render();
                }
            }

            // P to cycle priority of hovered task (or selected if not hovering)
            if ((e.key === 'p' || e.key === 'P') && this.editingTaskId === null) {
                if (this.hoveredTaskId !== null) {
                    // Hovering over a task - change its priority
                    e.preventDefault();
                    this.cyclePriority(this.hoveredTaskId);
                } else if (this.selectedTaskIds.size > 0) {
                    // Not hovering - fall back to selected task(s)
                    e.preventDefault();
                    const selectedArray = Array.from(this.selectedTaskIds);
                    selectedArray.forEach(id => this.cyclePriority(id));
                }
            }

            // Ctrl+Alt+A to toggle arrow routing mode
            if ((e.key === 'a' || e.key === 'A') && (e.ctrlKey || e.metaKey) && e.altKey && this.editingTaskId === null) {
                e.preventDefault();
                // Toggle between 'direct' and 'orthogonal'
                this.arrowRoutingMode = this.arrowRoutingMode === 'direct' ? 'orthogonal' : 'direct';
                const modeName = this.arrowRoutingMode === 'direct' ? 'Direct' : 'Orthogonal';
                this.showToast(`Arrow routing: ${modeName}`, 'info', 2000);
                this.saveToStorage();
                this.render();
            }
        });

        // ========================================
        // Window Resize
        // ========================================
        window.addEventListener('resize', () => {
            this.viewBox.width = window.innerWidth;
            this.viewBox.height = window.innerHeight - 60;
            this.render();
        });

        // ========================================
        // Modal Click-Outside Handlers
        // ========================================
        document.getElementById('import-modal').addEventListener('click', (e) => {
            if (e.target.id === 'import-modal') {
                this.hideImportModal();
            }
        });

        document.getElementById('confirm-modal').addEventListener('click', (e) => {
            if (e.target.id === 'confirm-modal') {
                this.hideConfirm();
            }
        });

        document.getElementById('alert-modal').addEventListener('click', (e) => {
            if (e.target.id === 'alert-modal') {
                this.hideAlert();
            }
        });

        document.getElementById('create-home-modal').addEventListener('click', (e) => {
            if (e.target.id === 'create-home-modal') {
                this.hideCreateHomeModal();
            }
        });

        document.getElementById('manage-homes-modal').addEventListener('click', (e) => {
            if (e.target.id === 'manage-homes-modal') {
                this.hideManageHomesModal();
            }
        });

        // Enter key to create home from modal
        document.getElementById('home-name-input').addEventListener('keydown', (e) => {
            if (e.key === 'Enter') {
                this.createHomeFromModal();
            }
        });

        // ========================================
        // Mouse Wheel Zoom (zooms toward cursor position)
        // ========================================
        svg.addEventListener('wheel', (e) => {
            e.preventDefault();

            // Get cursor position in SVG coordinates BEFORE zoom
            const cursorBeforeZoom = this.getSVGPoint(e);

            // Normalize deltaY based on deltaMode
            // deltaMode: 0 = pixels, 1 = lines, 2 = pages
            let delta = e.deltaY;
            if (e.deltaMode === 1) delta *= 33;  // Lines to pixels
            if (e.deltaMode === 2) delta *= 100; // Pages to pixels

            // Clamp to prevent extreme jumps
            delta = Math.max(-100, Math.min(100, delta));

            // Scale zoom change proportionally to delta magnitude
            const zoomChange = (delta / 100) * this.wheelZoomSpeed;
            const zoomFactor = 1 + zoomChange;

            const oldZoomLevel = this.zoomLevel;
            this.zoomLevel = Math.max(
                this.minZoom,
                Math.min(this.maxZoom, this.zoomLevel * zoomFactor)
            );

            // Calculate how viewBox dimensions change
            const oldWidth = this.viewBox.width;
            const oldHeight = this.viewBox.height;
            const newWidth = window.innerWidth / this.zoomLevel;
            const newHeight = (window.innerHeight - 60) / this.zoomLevel;

            // Calculate cursor position as ratio in old viewBox
            const cursorRatioX = (cursorBeforeZoom.x - this.viewBox.x) / oldWidth;
            const cursorRatioY = (cursorBeforeZoom.y - this.viewBox.y) / oldHeight;

            // Adjust viewBox position to keep cursor at same SVG coordinate
            this.viewBox.x = cursorBeforeZoom.x - (cursorRatioX * newWidth);
            this.viewBox.y = cursorBeforeZoom.y - (cursorRatioY * newHeight);
            this.viewBox.width = newWidth;
            this.viewBox.height = newHeight;

            this.updateZoomDisplay();
            this.render();

            // Debounce saveToStorage for smooth zooming
            clearTimeout(this._zoomSaveTimeout);
            this._zoomSaveTimeout = setTimeout(() => {
                this.saveToStorage();
            }, 500);
        }, { passive: false });

        // ========================================
        // Keyboard Shortcuts (Zoom, Undo/Redo, Copy/Paste, etc.)
        // ========================================
        document.addEventListener('keydown', (e) => {
            // Don't trigger shortcuts when modal is open
            const anyModalOpen = document.querySelector('.modal.show');
            if (anyModalOpen) return;

            if (this.editingTaskId !== null) return; // Don't run shortcuts while editing text

            // Arrow keys = move selected nodes 1 pixel
            if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(e.key)) {
                if (this.selectedTaskIds.size > 0) {
                    e.preventDefault();

                    const selectedTasks = Array.from(this.selectedTaskIds)
                        .map(id => this.tasks.find(t => t.id === id))
                        .filter(t => t);

                    if (selectedTasks.length === 0) return;

                    // Save snapshot for undo
                    const taskNames = selectedTasks.map(t => this.truncateTitle(t.title || 'Untitled', 20)).join(', ');
                    this.saveSnapshot(`Move ${selectedTasks.length} task(s): ${taskNames}`);

                    // Move all selected tasks by 1 pixel
                    selectedTasks.forEach(task => {
                        if (e.key === 'ArrowUp') task.y -= 1;
                        else if (e.key === 'ArrowDown') task.y += 1;
                        else if (e.key === 'ArrowLeft') task.x -= 1;
                        else if (e.key === 'ArrowRight') task.x += 1;
                    });

                    this.render();
                    this.saveToStorage();
                }
            }

            // Ctrl/Cmd + Plus/Equals = zoom in
            if ((e.ctrlKey || e.metaKey) && (e.key === '+' || e.key === '=')) {
                e.preventDefault();
                this.zoomIn();
            }

            // Ctrl/Cmd + Minus = zoom out
            if ((e.ctrlKey || e.metaKey) && e.key === '-') {
                e.preventDefault();
                this.zoomOut();
            }

            // Ctrl/Cmd + 0 = reset zoom
            if ((e.ctrlKey || e.metaKey) && e.key === '0') {
                e.preventDefault();
                this.resetZoom();
            }

            // Ctrl/Cmd + 1 = zoom to fit
            if ((e.ctrlKey || e.metaKey) && e.key === '1') {
                e.preventDefault();
                this.zoomToFit();
            }

            // Ctrl/Cmd + Z = undo
            if ((e.ctrlKey || e.metaKey) && e.key === 'z' && !e.shiftKey) {
                e.preventDefault();
                this.undo();
            }

            // Ctrl/Cmd + Shift + Z or Ctrl + Y = redo
            if (((e.ctrlKey || e.metaKey) && e.key.toLowerCase() === 'z' && e.shiftKey) ||
                (e.ctrlKey && e.key.toLowerCase() === 'y')) {
                e.preventDefault();
                this.redo();
            }

            // Ctrl/Cmd + C = copy subtree
            if ((e.ctrlKey || e.metaKey) && e.key.toLowerCase() === 'c') {
                e.preventDefault();
                if (this.selectedTaskIds.size === 1) {
                    const taskId = Array.from(this.selectedTaskIds)[0];
                    this.copySubtree(taskId);
                } else if (this.selectedTaskIds.size > 1) {
                    this.showToast('‚ö†Ô∏è Select a single node to copy its subtree', 'warning', 2000);
                } else {
                    this.showToast('‚ö†Ô∏è Select a task first to copy', 'warning', 2000);
                }
            }

            // Ctrl/Cmd + V = smart paste (auto-detect image vs subtree)
            if ((e.ctrlKey || e.metaKey) && e.key.toLowerCase() === 'v') {
                e.preventDefault();
                // Smart paste: check clipboard for image first, then fall back to subtree
                this.smartPaste();
            }

            // Ctrl/Cmd + K = attach link to selected node
            if ((e.ctrlKey || e.metaKey) && e.key.toLowerCase() === 'k') {
                e.preventDefault();
                if (this.selectedTaskIds.size === 1) {
                    const taskId = Array.from(this.selectedTaskIds)[0];
                    this.attachLink(taskId);
                } else if (this.selectedTaskIds.size > 1) {
                    this.showToast('‚ö†Ô∏è Select a single node to attach a link', 'warning');
                } else {
                    this.showToast('‚ö†Ô∏è Select a task first to attach a link', 'warning');
                }
            }

            // J = show working tasks menu / jump to working task
            if ((e.key === 'j' || e.key === 'J') && this.editingTaskId === null && !e.ctrlKey && !e.metaKey && !e.altKey) {
                e.preventDefault();
                // Check if dropdown is already open
                const existingDropdown = document.getElementById('working-tasks-dropdown');
                if (existingDropdown) {
                    // J pressed again while menu open ‚Üí jump to default
                    this.jumpToWorkingTask();
                    existingDropdown.remove();
                } else {
                    // Open the dropdown menu
                    this.showWorkingTasksDropdown(null, true); // true = keyboard mode
                }
            }

            // T = toggle timer window (expand/minimize)
            if ((e.key === 't' || e.key === 'T') && this.editingTaskId === null && !e.ctrlKey && !e.metaKey && !e.altKey) {
                e.preventDefault();
                if (this.timerState.isRunning) {
                    this.toggleTimerWindow();
                } else {
                    this.showToast('‚è±Ô∏è No timer running. Middle-click a task to start working.', 'info', 2000);
                }
            }

            // Number keys (0-9) = jump to home with that keybind
            if (!e.ctrlKey && !e.metaKey && !e.altKey && /^[0-9]$/.test(e.key)) {
                // Find home with this keybind
                const home = this.homes.find(h => h.keybind === e.key);
                if (home) {
                    e.preventDefault();
                    this.jumpToHome(home.id);
                }
            }
        });
    },

    clearAllData() {
        this.showConfirm(
            'Clear All Data',
            'Delete ALL tasks and reset everything? This can be undone with Ctrl+Z.',
            () => {
                this.saveSnapshot('Cleared all data');
                localStorage.removeItem('taskTree');
                this.tasks = [];
                this.taskIdCounter = 0;
                this.editingTaskId = null;

                this.updateStatusBar();
                this.render();
            }
        );
    }
});

console.log('‚úì App initialization loaded');




// Initialize app on load
document.addEventListener('DOMContentLoaded', async () => {
    if (typeof app !== 'undefined' && typeof app.init === 'function') {
        await app.init();
    } else {
        console.error('App initialization failed: app.init() not found');
    }
});
</script>
</body>
</html>
