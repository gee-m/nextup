<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Task Tree PoC</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', sans-serif;
            background: linear-gradient(135deg, #f5f7fa 0%, #e9ecef 100%);
            overflow: hidden;
        }

        #controls {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            padding: 14px 24px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.5);
            z-index: 100;
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            align-items: center;
        }

        button {
            padding: 9px 18px;
            border: none;
            border-radius: 8px;
            background: rgba(255, 255, 255, 0.95);
            color: #1a1a2e;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            transition: all 0.3s ease;
            box-shadow: 0 2px 8px rgba(0,0,0,0.2);
        }

        button:hover {
            background: white;
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
        }

        button.secondary {
            background: rgba(255, 255, 255, 0.15);
            color: white;
            box-shadow: 0 2px 6px rgba(0,0,0,0.2);
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        button.secondary:hover {
            background: rgba(255, 255, 255, 0.25);
            box-shadow: 0 3px 10px rgba(0,0,0,0.3);
        }

        /* Dropdown menu for Homes button */
        .dropdown {
            position: relative;
            display: inline-block;
        }

        .dropdown-content {
            display: none;
            position: absolute;
            top: 100%;
            left: 0;
            background: rgba(255, 255, 255, 0.98);
            min-width: 200px;
            max-height: 400px;
            overflow-y: auto;
            box-shadow: 0 8px 24px rgba(0,0,0,0.15);
            border-radius: 8px;
            margin-top: 8px;
            z-index: 1000;
            border: 1px solid rgba(0, 0, 0, 0.1);
        }

        .dropdown-content.show {
            display: block;
        }

        .dropdown-item {
            padding: 12px 16px;
            color: #333;
            cursor: pointer;
            transition: background 0.2s;
            border-bottom: 1px solid rgba(0, 0, 0, 0.08);
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .dropdown-item:last-child {
            border-bottom: none;
        }

        .dropdown-item:hover {
            background: rgba(0, 0, 0, 0.05);
        }

        .dropdown-item.special {
            background: rgba(156, 39, 176, 0.1);
            font-weight: 600;
        }

        .dropdown-item.special:hover {
            background: rgba(156, 39, 176, 0.2);
        }

        .dropdown-divider {
            height: 1px;
            background: rgba(0, 0, 0, 0.1);
            margin: 4px 0;
        }

        .dropdown-empty {
            padding: 16px;
            color: rgba(0, 0, 0, 0.4);
            text-align: center;
            font-style: italic;
        }

        /* Nested submenu for context menu */
        .menu-item-with-submenu {
            position: relative;
        }

        .menu-item-with-submenu::after {
            content: '▶';
            margin-left: 8px;
            font-size: 10px;
        }

        .submenu {
            display: none;
            position: absolute;
            left: 100%;
            top: 0;
            background: rgba(255, 255, 255, 0.98);
            min-width: 180px;
            max-height: 350px;
            overflow-y: auto;
            overflow-x: hidden; /* Prevent horizontal scrollbar */
            box-shadow: 0 8px 24px rgba(0,0,0,0.15);
            border-radius: 8px;
            margin-left: -2px; /* Overlap slightly to remove gap */
            border: 1px solid rgba(0, 0, 0, 0.1);
            z-index: 1001;
            /* Add invisible padding on left to create "hover bridge" */
            padding-left: 6px;
        }

        /* Show submenu when hovering parent OR the submenu itself */
        .menu-item-with-submenu:hover .submenu,
        .submenu:hover {
            display: block;
        }

        /* Compensate for padding on first item */
        .submenu-item:first-child {
            margin-left: -6px;
            padding-left: 14px;
            width: calc(100% + 6px);
        }

        .submenu-item {
            margin-left: -6px;
            padding-left: 14px;
            width: calc(100% + 6px);
        }

        .submenu-item {
            padding: 10px 14px;
            color: #333;
            cursor: pointer;
            transition: background 0.2s;
            border-bottom: 1px solid rgba(0, 0, 0, 0.08);
            white-space: nowrap;
        }

        .submenu-item:last-child {
            border-bottom: none;
        }

        .submenu-item:hover {
            background: rgba(0, 0, 0, 0.05);
        }

        .submenu-item.special {
            background: rgba(156, 39, 176, 0.1);
            font-weight: 600;
        }

        .submenu-item.special:hover {
            background: rgba(156, 39, 176, 0.2);
        }

        /* Fix margin for submenu items that have nested submenus */
        .submenu-item.menu-item-with-submenu {
            margin-left: 0 !important;
            width: 100% !important;
            position: relative;
            display: block;
            cursor: pointer;
        }

        .submenu-item.menu-item-with-submenu > span {
            display: inline-block;
            width: 100%;
        }

        /* Nested submenu - uses fixed positioning to break out of overflow context */
        .submenu-nested {
            display: none;
            position: fixed; /* Fixed instead of absolute to escape overflow container */
            background: rgba(255, 255, 255, 0.98);
            min-width: 200px;
            box-shadow: 0 8px 24px rgba(0,0,0,0.2);
            border-radius: 8px;
            border: 1px solid rgba(0, 0, 0, 0.1);
            z-index: 1002; /* Higher than parent submenu */
            padding: 0;
        }

        .submenu-item.menu-item-with-submenu:hover .submenu-nested,
        .submenu-nested:hover {
            display: block !important;
        }

        .submenu-nested .submenu-item {
            margin-left: 0;
            padding-left: 14px;
            width: 100%;
        }

        .submenu-nested .submenu-item:first-child {
            margin-left: 0;
            padding-left: 14px;
            width: 100%;
        }

        .submenu-empty {
            padding: 12px;
            color: rgba(0, 0, 0, 0.4);
            text-align: center;
            font-style: italic;
            font-size: 12px;
        }

        .submenu-divider {
            height: 1px;
            background: rgba(0, 0, 0, 0.1);
            margin: 4px 0;
        }

        input {
            padding: 10px 16px;
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 8px;
            font-size: 14px;
            flex: 1;
            max-width: 300px;
            background: rgba(255, 255, 255, 0.95);
            color: #333;
            transition: all 0.3s ease;
        }

        input:focus {
            outline: none;
            border-color: white;
            box-shadow: 0 0 0 3px rgba(255, 255, 255, 0.3);
            background: white;
        }

        #zoomLevel {
            color: white;
            font-weight: 600;
            text-shadow: 0 1px 2px rgba(0,0,0,0.1);
        }

        #canvas-container {
            position: fixed;
            top: 65px;
            left: 0;
            right: 0;
            bottom: 0;
            cursor: grab;
        }

        #canvas-container.has-status-bar {
            bottom: 44px;
        }

        #canvas-container.dragging {
            cursor: grabbing;
        }

        svg {
            width: 100%;
            height: 100%;
        }

        .task-node {
            cursor: move;
        }

        .task-node rect {
            stroke: #555;
            stroke-width: 2;
            transition: all 0.2s ease;
            rx: 8;
            ry: 8;
            fill: white;
            filter: drop-shadow(0 2px 4px rgba(0, 0, 0, 0.1));
        }

        .task-node.done rect {
            fill: linear-gradient(135deg, #d4edda 0%, #c3e6cb 100%);
            fill: #e8f5e9;
            stroke: #4caf50;
            filter: drop-shadow(0 2px 6px rgba(76, 175, 80, 0.3));
        }

        .task-node.working rect {
            fill: #fff8e1;
            stroke: #ff9800;
            stroke-width: 3;
            filter: drop-shadow(0 3px 8px rgba(255, 152, 0, 0.4));
        }

        .task-node.parent-of-working rect {
            stroke: #ff9800;
            stroke-width: 3;
            filter: drop-shadow(0 0 4px rgba(255, 152, 0, 0.4));
        }

        .task-node.incomplete-child-of-working rect {
            stroke: #e74c3c;
            stroke-width: 2.5;
            filter: drop-shadow(0 0 2px rgba(231, 76, 60, 0.3));
        }

        .task-node.hidden {
            display: none; /* Completely hide nodes with hidden property */
        }

        .task-node text {
            pointer-events: none;
            user-select: none;
            font-size: 14px;
            font-weight: 500; /* Will be overridden by inline style from app.fontWeight */
            fill: #37474f;
            font-family: 'Fira Code', 'Consolas', 'Monaco', 'Courier New', monospace;
        }


        .hidden-indicator {
            cursor: pointer;
            fill: #ff6b6b;
            stroke: #c92a2a;
            stroke-width: 1;
        }

        .hidden-indicator-text {
            pointer-events: none;
            font-size: 12px;
            font-weight: bold;
            fill: white;
            text-anchor: middle;
            dominant-baseline: middle;
        }

        .hidden-indicator:hover {
            fill: #ff5252;
            stroke: #a01919;
        }

        .task-node:hover rect {
            filter: brightness(0.95);
            stroke-width: 2.5;
        }

        .text-expand-button circle {
            transition: fill 0.3s ease;
        }

        .text-expand-button:hover circle {
            filter: brightness(1.1);
        }

        .task-node.selected rect {
            stroke: #007bff;
            stroke-width: 3;
            filter: drop-shadow(0 0 4px rgba(0, 123, 255, 0.6));
        }

        .preview-node rect {
            fill: #e8e8ff;
            stroke: #007bff;
            stroke-width: 2;
            stroke-dasharray: 5,3;
            opacity: 0.6;
            filter: none;
        }

        .preview-node text {
            fill: #4a7c9e;
            opacity: 0.7;
            font-style: italic;
        }

        /* Custom cursor arrow for drag operations */
        #canvas-container.dragging-relationship {
            cursor: none !important;
        }

        #canvas-container.dragging-relationship * {
            cursor: none !important;
        }

        .cursor-arrow {
            pointer-events: none;
            position: fixed;
            z-index: 10000;
            width: 24px;
            height: 24px;
        }

        .cursor-arrow path {
            stroke: #007bff;
            fill: none;
            filter: drop-shadow(0 2px 4px rgba(0,0,0,0.3));
        }

        .link {
            stroke: #90a4ae;
            stroke-width: 2;
            fill: none;
            transition: all 0.3s ease;
        }

        .link.dependency {
            stroke: #78909c;
            stroke-width: 2;
            stroke-dasharray: 5,5;
        }

        /* Hit detection lines - invisible, wide for easy clicking */
        .link.dependency-hit,
        .link.parent-hit,
        .link.other-parent-hit {
            cursor: pointer;
            stroke: transparent;
            stroke-width: 15;
            pointer-events: stroke;
        }

        /* Visible line styling */
        .link.parent-visible {
            stroke: #90a4ae;
            stroke-width: 2;
        }

        /* Hover effects - style visible line when hit line is hovered */
        .link.dependency-hit:hover + .link.dependency,
        .link.parent-hit:hover + .link.parent-visible,
        .link.other-parent-hit:hover + .link.other-parent {
            stroke: #007bff !important;
            stroke-width: 3 !important;
        }

        .link.other-parent {
            stroke: #b0bec5;
            stroke-width: 1.5;
            stroke-dasharray: 3,3;
        }

        .link.selected {
            stroke: #007bff !important;
            stroke-width: 4 !important;
            filter: drop-shadow(0 0 3px rgba(0, 123, 255, 0.7));
        }

        .temp-line {
            stroke-width: 2;
            pointer-events: none;
        }

        .node-menu {
            position: fixed;
            background: white;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            padding: 8px 0;
            z-index: 1000;
            min-width: 180px;
        }

        .node-menu button {
            display: block;
            width: 100%;
            text-align: left;
            background: none;
            color: #333;
            padding: 10px 16px;
            border-radius: 0;
        }

        .node-menu button:hover {
            background: #f8f9fa;
        }

        .node-menu .dependency-section {
            padding: 8px 16px;
            border-bottom: 1px solid #e9ecef;
            margin-bottom: 4px;
        }

        .node-menu .dependency-section h4 {
            margin: 0 0 8px 0;
            font-size: 12px;
            color: #666;
            text-transform: uppercase;
            font-weight: 600;
        }

        .node-menu .dependency-item {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 4px 0;
            font-size: 13px;
        }

        .node-menu .dependency-item span {
            color: #333;
        }

        .node-menu .dependency-item .remove-btn {
            background: #dc3545;
            color: white;
            border: none;
            border-radius: 3px;
            padding: 2px 6px;
            font-size: 11px;
            cursor: pointer;
            margin-left: 8px;
            min-width: 20px;
            height: 20px;
            line-height: 1;
        }

        .node-menu .dependency-item .remove-btn:hover {
            background: #c82333;
        }

        .info {
            margin-left: auto;
            font-size: 12px;
            color: #666;
        }

        .marker {
            fill: #78909c;
        }

        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.5);
            z-index: 2000;
            align-items: center;
            justify-content: center;
        }

        .modal.show {
            display: flex;
        }

        .modal-content {
            background: white;
            padding: 24px;
            border-radius: 12px;
            max-width: 500px;
            width: 90%;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.2);
        }

        .modal-content h2 {
            margin: 0 0 12px 0;
            font-size: 20px;
        }

        .modal-content p {
            margin: 0 0 16px 0;
            color: #666;
            font-size: 14px;
        }

        #import-textarea {
            width: 100%;
            height: 200px;
            padding: 12px;
            border: 1px solid #ddd;
            border-radius: 6px;
            font-family: monospace;
            font-size: 12px;
            resize: vertical;
            margin-bottom: 16px;
        }

        .modal-buttons {
            display: flex;
            gap: 12px;
            justify-content: flex-end;
        }

        /* Fix button visibility in modals - override toolbar button colors */
        .modal-content button {
            background: rgba(33, 150, 243, 0.1);
            color: #1976d2;
            border: 1px solid rgba(33, 150, 243, 0.3);
        }

        .modal-content button:hover {
            background: rgba(33, 150, 243, 0.2);
            color: #1565c0;
        }

        .modal-content button.secondary {
            background: rgba(158, 158, 158, 0.1);
            color: #424242;
            border: 1px solid rgba(158, 158, 158, 0.3);
        }

        .modal-content button.secondary:hover {
            background: rgba(158, 158, 158, 0.2);
            color: #212121;
        }

        #status-bar {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            background: linear-gradient(135deg, #434343 0%, #000000 100%);
            color: white;
            padding: 12px 24px;
            height: 44px;
            font-size: 13px;
            z-index: 50;
            display: none;
            align-items: center;
            box-shadow: 0 -4px 16px rgba(0,0,0,0.2);
        }

        #status-bar.show {
            display: flex;
        }

        #status-bar .status-label {
            font-weight: 600;
            margin-right: 10px;
            opacity: 0.8;
        }

        #status-bar .status-task {
            color: #ffb74d;
            font-weight: 600;
            text-shadow: 0 1px 2px rgba(0,0,0,0.2);
        }

        #status-bar .status-path {
            color: #e0e0e0;
        }

        #status-bar .status-detail {
            margin-left: 20px;
            color: #bdbdbd;
        }

        #status-bar .status-warning {
            color: #ff5252;
            margin-left: 10px;
            font-weight: 600;
        }

        /* Dark Mode Styles */
        body.dark-mode {
            background: #0a0a0a;
        }

        body.dark-mode #canvas-container {
            background: #000000;
        }

        /* Smooth animation for home jumps - Transform is GPU accelerated! */
        #canvas.animating-view .task-node {
            transition: transform 0.5s cubic-bezier(0.4, 0.0, 0.2, 1);
        }

        /* Also transition preview node during create-child drag */
        #canvas.animating-view .preview-node {
            transition: transform 0.5s cubic-bezier(0.4, 0.0, 0.2, 1);
        }

        /* Hide lines during animation - CSS transitions don't work on SVG line attributes */
        /* This is the standard approach for non-transitionable SVG elements */
        #canvas.animating-view line {
            opacity: 0;
            transition: opacity 0.15s ease-out;
        }

        /* Keep buttons white in dark mode, just add white borders */
        body.dark-mode button.secondary {
            border: 1px solid rgba(255, 255, 255, 0.5);
        }

        body.dark-mode .task-node rect {
            fill: #2d3748;
            stroke: #4a5568;
            filter: drop-shadow(0 2px 8px rgba(0, 0, 0, 0.5));
        }

        body.dark-mode .task-node.done rect {
            fill: #2d4a2f;
            stroke: #48bb78;
            filter: drop-shadow(0 2px 8px rgba(72, 187, 120, 0.4));
        }

        body.dark-mode .task-node.working rect {
            fill: #4a3f2d;
            stroke: #ed8936;
            filter: drop-shadow(0 3px 10px rgba(237, 137, 54, 0.5));
        }

        body.dark-mode .task-node.parent-of-working rect {
            stroke: #ed8936;
            filter: drop-shadow(0 0 6px rgba(237, 137, 54, 0.5));
        }

        body.dark-mode .task-node.incomplete-child-of-working rect {
            stroke: #fc8181;
            filter: drop-shadow(0 0 4px rgba(252, 129, 129, 0.4));
        }

        body.dark-mode .task-node.selected rect {
            stroke: #4299e1;
            filter: drop-shadow(0 0 6px rgba(66, 153, 225, 0.7));
        }

        body.dark-mode .task-node text {
            fill: #e2e8f0;
        }

        body.dark-mode .preview-node rect {
            fill: #1a365d;
            stroke: #4299e1;
            stroke-width: 2;
            stroke-dasharray: 5,3;
            opacity: 0.7;
            filter: none;
        }

        body.dark-mode .preview-node text {
            fill: #90cdf4;
            opacity: 0.8;
            font-style: italic;
        }

        body.dark-mode .cursor-arrow path {
            stroke: #4299e1;
            fill: none;
            filter: drop-shadow(0 2px 4px rgba(0,0,0,0.5));
        }

        /* Dark mode: Only style VISIBLE lines, NOT hit lines */
        body.dark-mode .link.dependency {
            stroke: #ffffff;
            stroke-width: 2.5;
            stroke-dasharray: 5,5;
        }

        body.dark-mode .link.parent-visible {
            stroke: #ffffff;
            stroke-width: 2.5;
        }

        body.dark-mode .link.other-parent {
            stroke: #ffffff;
            stroke-width: 2;
            stroke-dasharray: 3,3;
        }

        /* Keep hit lines transparent with 15px width for easy clicking */
        body.dark-mode .link.dependency-hit,
        body.dark-mode .link.parent-hit,
        body.dark-mode .link.other-parent-hit {
            stroke: transparent;
            stroke-width: 15;
        }

        body.dark-mode .marker {
            fill: #ffffff;
        }

        body.dark-mode .link.dependency-hit:hover + .link.dependency,
        body.dark-mode .link.parent-hit:hover + .link.parent-visible,
        body.dark-mode .link.other-parent-hit:hover + .link.other-parent {
            stroke: #4299e1 !important;
        }

        body.dark-mode .link.selected {
            stroke: #4299e1 !important;
        }

        body.dark-mode .task-node:hover rect {
            filter: brightness(1.2);
        }

        /* Dark mode modal styling */
        body.dark-mode .modal-content {
            background: #1e293b;
            color: #e2e8f0;
        }

        body.dark-mode .modal-content h2 {
            color: #f1f5f9;
        }

        body.dark-mode .modal-content p {
            color: #94a3b8;
        }

        body.dark-mode .modal-content button {
            background: rgba(59, 130, 246, 0.2);
            color: #60a5fa;
            border: 1px solid rgba(59, 130, 246, 0.4);
        }

        body.dark-mode .modal-content button:hover {
            background: rgba(59, 130, 246, 0.3);
            color: #93c5fd;
        }

        body.dark-mode .modal-content button.secondary {
            background: rgba(148, 163, 184, 0.15);
            color: #cbd5e1;
            border: 1px solid rgba(148, 163, 184, 0.3);
        }

        body.dark-mode .modal-content button.secondary:hover {
            background: rgba(148, 163, 184, 0.25);
            color: #e2e8f0;
        }

        body.dark-mode #import-textarea {
            background: #0f172a;
            color: #e2e8f0;
            border-color: #475569;
        }

        body.dark-mode .node-menu {
            background: #1e293b;
            border: 1px solid #475569;
        }

        body.dark-mode .node-menu button {
            color: #e2e8f0;
        }

        body.dark-mode .node-menu button:hover {
            background: #334155;
        }

        body.dark-mode .node-menu .dependency-section {
            border-bottom-color: #475569;
        }

        body.dark-mode .node-menu .dependency-section h4 {
            color: #94a3b8;
        }

        body.dark-mode .node-menu .dependency-item span {
            color: #e2e8f0;
        }

        /* Dark mode dropdown and submenu styling */
        body.dark-mode .dropdown-content {
            background: rgba(30, 41, 59, 0.98);
            border: 1px solid rgba(148, 163, 184, 0.3);
        }

        body.dark-mode .dropdown-item {
            color: #e2e8f0;
            border-bottom: 1px solid rgba(148, 163, 184, 0.15);
        }

        body.dark-mode .dropdown-item:hover {
            background: rgba(148, 163, 184, 0.2);
        }

        body.dark-mode .dropdown-item.special {
            background: rgba(156, 39, 176, 0.25);
        }

        body.dark-mode .dropdown-item.special:hover {
            background: rgba(156, 39, 176, 0.4);
        }

        body.dark-mode .dropdown-empty {
            color: rgba(226, 232, 240, 0.5);
        }

        body.dark-mode .submenu {
            background: rgba(30, 41, 59, 0.98);
            border: 1px solid rgba(148, 163, 184, 0.3);
        }

        body.dark-mode .submenu-item {
            color: #e2e8f0;
            border-bottom: 1px solid rgba(148, 163, 184, 0.15);
        }

        body.dark-mode .submenu-item:hover {
            background: rgba(148, 163, 184, 0.2);
        }

        body.dark-mode .submenu-item.special {
            background: rgba(156, 39, 176, 0.25);
        }

        body.dark-mode .submenu-item.special:hover {
            background: rgba(156, 39, 176, 0.4);
        }

        body.dark-mode .submenu-empty {
            color: rgba(226, 232, 240, 0.5);
        }

        body.dark-mode .submenu-nested {
            background: rgba(30, 41, 59, 0.98);
            border: 1px solid rgba(148, 163, 184, 0.3);
        }

        /* Toast Notification System */
        .toast-container {
            position: fixed;
            bottom: 24px;
            right: 24px;
            z-index: 9999;
            display: flex;
            flex-direction: column;
            gap: 12px;
            pointer-events: none;
        }

        .toast {
            background: white;
            color: #333;
            padding: 14px 20px;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            font-size: 14px;
            font-weight: 500;
            border-left: 4px solid #4caf50;
            animation: slideIn 0.3s ease, slideOut 0.3s ease 3.7s;
            pointer-events: auto;
            cursor: pointer;
        }

        .toast.success {
            border-left-color: #4caf50;
            background: #f1f8e9;
        }

        .toast.error {
            border-left-color: #f44336;
            background: #ffebee;
            color: #c62828;
        }

        .toast.info {
            border-left-color: #2196f3;
            background: #e3f2fd;
            color: #1565c0;
        }

        @keyframes slideIn {
            from {
                transform: translateX(400px);
                opacity: 0;
            }
            to {
                transform: translateX(0);
                opacity: 1;
            }
        }

        @keyframes slideOut {
            from {
                transform: translateX(0);
                opacity: 1;
            }
            to {
                transform: translateX(400px);
                opacity: 0;
            }
        }
    </style>
</head>
<body>
    <div id="controls">
        <button style="background: #9c27b0; color: white;" onclick="app.loadTestChecklist()" title="Load testing tasks for recent features">🧪 Test Checklist</button>
        <button class="secondary" onclick="app.toggleDarkMode()" id="darkModeToggle">🌙 Dark Mode</button>
        <button class="secondary" onclick="app.showSettingsModal()" title="Customize appearance and behavior">⚙️ Settings</button>
        <div class="dropdown">
            <button class="secondary" onclick="app.toggleHomesDropdown(event)" title="Quick navigation to saved homes">🏠 Homes</button>
            <div id="homesDropdown" class="dropdown-content">
                <!-- Populated dynamically by renderHomesDropdown() -->
            </div>
        </div>
        <button class="secondary" onclick="app.exportData()">Export JSON</button>
        <button class="secondary" onclick="app.copyDataToClipboard(event)">Copy JSON</button>
        <button class="secondary" onclick="app.showImportModal()">Import JSON</button>
        <button class="secondary" onclick="app.clearAllData()">Clear All Data</button>
        <div class="info">
            <span>Double-click: edit | Right-click: menu (or on empty space) | Left-click: select | Backspace: delete | Middle-click: cycle | Ctrl+Click: create task | Shift+Drag: subtree | Scroll: zoom | Ctrl+Z: undo | Ctrl+Shift+Z: redo</span>
        </div>
    </div>

    <div id="canvas-container">
        <svg id="canvas">
            <defs>
                <marker id="arrowhead" markerWidth="10" markerHeight="10" refX="9" refY="3" orient="auto">
                    <polygon points="0 0, 10 3, 0 6" class="marker" />
                </marker>
                <marker id="arrowhead-golden" markerWidth="10" markerHeight="10" refX="9" refY="3" orient="auto">
                    <polygon points="0 0, 10 3, 0 6" fill="#f59e0b" />
                </marker>
                <marker id="arrowhead-red" markerWidth="10" markerHeight="10" refX="9" refY="3" orient="auto">
                    <polygon points="0 0, 10 3, 0 6" fill="#f44336" />
                </marker>
                <marker id="arrowhead-green" markerWidth="10" markerHeight="10" refX="9" refY="3" orient="auto">
                    <polygon points="0 0, 10 3, 0 6" fill="#4caf50" />
                </marker>
            </defs>
            <g id="links"></g>
            <g id="nodes"></g>
        </svg>
    </div>

    <div id="import-modal" class="modal">
        <div class="modal-content">
            <h2>Import JSON Data</h2>
            <p>Paste your exported JSON data below:</p>
            <textarea id="import-textarea" placeholder="Paste JSON here..."></textarea>
            <div class="modal-buttons">
                <button onclick="app.importData()">Import</button>
                <button class="secondary" onclick="app.hideImportModal()">Cancel</button>
            </div>
        </div>
    </div>

    <div id="confirm-modal" class="modal">
        <div class="modal-content">
            <h2 id="confirm-title"></h2>
            <p id="confirm-message"></p>
            <div class="modal-buttons">
                <button id="confirm-yes">Yes</button>
                <button class="secondary" id="confirm-no">Cancel</button>
            </div>
        </div>
    </div>

    <div id="alert-modal" class="modal">
        <div class="modal-content">
            <h2 id="alert-title"></h2>
            <p id="alert-message"></p>
            <div class="modal-buttons">
                <button id="alert-ok">OK</button>
            </div>
        </div>
    </div>

    <div id="settings-modal" class="modal">
        <div class="modal-content" style="max-width: 600px; max-height: 80vh; overflow-y: auto;">
            <h2>⚙️ Settings</h2>
            <p style="color: #666; font-size: 13px; margin-bottom: 20px;">Customize appearance and behavior</p>
            <div id="settings-form"></div>

            <!-- History Management Section -->
            <div style="margin-top: 30px; padding-top: 20px; border-top: 2px solid #ddd;">
                <h3 style="margin-bottom: 15px; font-size: 16px;">📜 History Management</h3>
                <div id="history-stats" style="background: #f5f5f5; padding: 12px; border-radius: 4px; margin-bottom: 15px; font-size: 13px;">
                    <div style="margin-bottom: 8px;">
                        <strong>Current History:</strong>
                    </div>
                    <ul style="margin: 0; padding-left: 20px;">
                        <li>Undo steps: <span id="undo-count">0</span> / <span id="undo-limit">50</span></li>
                        <li>Redo steps: <span id="redo-count">0</span></li>
                        <li>Memory estimate: ~<span id="history-size">0</span> KB</li>
                    </ul>
                </div>
                <button
                    onclick="app.clearUndoHistory()"
                    style="background: #f44336; color: white; border: 1px solid #d32f2f; padding: 10px 16px; border-radius: 4px; cursor: pointer; font-size: 14px; width: 100%;"
                    onmouseover="this.style.background='#d32f2f'"
                    onmouseout="this.style.background='#f44336'">
                    🗑️ Clear Undo/Redo History
                </button>
                <p style="font-size: 12px; color: #666; margin-top: 8px; margin-bottom: 0;">
                    Removes all undo/redo history to free up storage space. This action cannot be undone.
                </p>
            </div>

            <div class="modal-buttons">
                <button onclick="app.applySettings()">Apply</button>
                <button class="secondary" onclick="app.exportSettings()">Export Settings</button>
                <button class="secondary" onclick="app.resetSettings()">Reset to Defaults</button>
                <button class="secondary" onclick="app.hideSettingsModal()">Cancel</button>
            </div>
        </div>
    </div>

    <div id="create-home-modal" class="modal">
        <div class="modal-content">
            <h2>Create New Home</h2>
            <p>Enter a name for this home bookmark:</p>
            <input type="text" id="home-name-input" placeholder="Home name..." maxlength="50" />
            <p style="font-size: 12px; color: #666; margin-top: 8px;">
                This will save your current view position and zoom level.
            </p>
            <div class="modal-buttons">
                <button onclick="app.createHomeFromModal()">Create</button>
                <button class="secondary" onclick="app.hideCreateHomeModal()">Cancel</button>
            </div>
        </div>
    </div>

    <div id="manage-homes-modal" class="modal">
        <div class="modal-content" style="max-width: 600px;">
            <h2>🏠 Manage Homes</h2>
            <p style="color: #666; font-size: 13px; margin-bottom: 16px;">
                Manage your saved home bookmarks
            </p>
            <div id="homes-list" style="max-height: 400px; overflow-y: auto; margin-bottom: 20px;">
                <!-- Populated dynamically by renderManageHomesModal() -->
            </div>
            <div class="modal-buttons">
                <button class="secondary" onclick="app.hideManageHomesModal()">Close</button>
            </div>
        </div>
    </div>

    <div id="status-bar">
        <span class="status-label">Working on:</span>
        <span id="status-path"></span>
        <span class="status-detail" id="status-children"></span>
    </div>

    <script>
        const app = {
            tasks: [],
            taskIdCounter: 0,
            viewBox: { x: 0, y: 0, width: window.innerWidth, height: window.innerHeight - 60 },
            zoomLevel: 1,
            minZoom: 0.2,
            maxZoom: 4,
            zoomSpeed: 0.1,
            selectedNode: null,
            selectedTaskIds: new Set(),  // For multi-select (Set of task IDs)
            lastClickedTaskId: null,     // For Shift+Click range selection
            selectedLine: null,    // For line selection {type: 'parent'|'dependency', taskId, parentId/depId}
            // Box selection state
            boxSelectStart: null,  // {x, y} when Shift+Click+Drag starts
            isBoxSelecting: false,
            dragMode: null,
            dragStart: { x: 0, y: 0 },
            dragOriginalPos: { x: 0, y: 0 },
            tempLine: null,
            darkMode: false,
            editingTaskId: null,
            draggedSubtree: [],
            subtreeOriginalPositions: {},
            previewNode: null,
            cursorArrow: null,
            textLengthThreshold: 80,
            // Node sizing & typography configuration
            charWidth: 8.5,    // Pixels per character for width calculation
            nodePadding: 30,   // Left/right padding inside rectangles
            minNodeWidth: 100, // Minimum rectangle width
            fontFamily: "'Fira Code', 'Consolas', 'Monaco', 'Courier New', monospace",  // Font stack for task text
            fontWeight: 700,   // Font weight: 400=normal, 500=medium, 600=semibold, 700=bold
            // Multiline text configuration
            enableMultiline: true,   // Master toggle for multiline text support
            maxNodeWidth: 600,       // Maximum node width in pixels before wrapping
            maxNodeHeight: 0,        // Maximum node height in pixels (0 = unlimited)
            lineHeight: 20,          // Vertical spacing between lines in pixels
            wordWrap: true,          // Wrap on word boundaries (vs character boundaries)
            // Arrow styling
            arrowStyle: 'straight',  // Arrow path style: 'straight' or 'curved'
            arrowCurvature: 0.25,    // Curve intensity for curved arrows (0.1 to 0.5)
            // Homes - named bookmarks for quick navigation
            homes: [],            // Array of {id, name, centerX, centerY, zoomLevel, timestamp, keybind}
            homeIdCounter: 1,     // For unique IDs
            // Undo/Redo system
            undoStack: [],        // Array of {tasks: [], description: string, timestamp: number}
            redoStack: [],        // Array for redo operations
            maxUndoSteps: 50,     // Maximum undo history
            isUndoing: false,     // Flag to prevent saveSnapshot during undo/redo
            lastSnapshotTime: 0,  // For 2-second edit grouping
            lastSnapshotTaskId: null, // For grouping edits to same task
            // Debounced save for performance
            saveDebounceTimer: null,  // Timer for debounced saves (canvas pan, etc.)
            // User preferences
            showDeleteConfirmation: true,  // Show confirmation dialog when deleting tasks
            autoHideCompletedNodes: true,  // Auto-hide nodes when task and parent are done
            // Multi-project working task tracking
            workingTasksByRoot: {},  // { [rootTaskId]: workingTaskId } - one working task per project/root

            init() {
                this.loadFromStorage();
                this.setupEventListeners();
                this.updateStatusBar();
                this.render();
            },

            setupEventListeners() {
                const container = document.getElementById('canvas-container');
                const svg = document.getElementById('canvas');

                svg.addEventListener('mousedown', (e) => this.onCanvasMouseDown(e));
                svg.addEventListener('mousemove', (e) => this.onCanvasMouseMove(e));
                svg.addEventListener('mouseup', (e) => this.onCanvasMouseUp(e));
                
                svg.addEventListener('dblclick', (e) => {
                    if (this.editingTaskId !== null) return; // Already editing

                    // Fallback: try to find task-node by traversing up
                    let element = e.target;
                    while (element && element !== svg) {
                        if (element.dataset && element.dataset.id && element.classList?.contains('task-node')) {
                            const taskId = parseInt(element.dataset.id);

                            if (e.shiftKey) {
                                // Shift+double click: hide/show the node itself within its parent
                                this.toggleHiddenSelf(taskId);
                            } else {
                                // Normal double click: edit task name
                                this.startEditing(taskId);
                            }

                            e.preventDefault();
                            e.stopPropagation();
                            return;
                        }
                        element = element.parentElement;
                    }
                });

                // Middle mouse button to cycle status
                svg.addEventListener('mousedown', (e) => {
                    if (e.button === 1) { // Middle mouse button
                        const node = e.target.closest('.task-node');
                        if (node) {
                            const taskId = parseInt(node.dataset.id);
                            this.cycleStatus(taskId);
                            e.preventDefault();
                            e.stopPropagation();
                        }
                    }
                });

                // Handle clicks on task nodes
                svg.addEventListener('click', (e) => {
                    const node = e.target.closest('.task-node');

                    if (node) {
                        const taskId = parseInt(node.dataset.id);

                        // Ctrl+click: Create new child
                        if ((e.ctrlKey || e.metaKey) && !e.altKey) {
                            this.addChildTask(taskId);
                            e.preventDefault();
                            e.stopPropagation();
                            return;
                        }

                        // Alt+click: Delete node
                        if (e.altKey && !e.ctrlKey && !e.metaKey) {
                            this.deleteTask(taskId);
                            e.preventDefault();
                            e.stopPropagation();
                            return;
                        }

                        // Left-click: Select node (with Shift for multi-select)
                        if (!e.ctrlKey && !e.metaKey && !e.altKey) {
                            if (e.shiftKey) {
                                // Shift+Click: Toggle selection (multi-select mode)
                                if (this.selectedTaskIds.has(taskId)) {
                                    this.selectedTaskIds.delete(taskId);
                                } else {
                                    this.selectedTaskIds.add(taskId);
                                }
                                this.lastClickedTaskId = taskId;
                                // TODO: Support Shift+Click range selection between lastClickedTaskId and current
                            } else {
                                // Plain click: Select only this node (clear others)
                                this.selectedTaskIds.clear();
                                this.selectedTaskIds.add(taskId);
                                this.lastClickedTaskId = taskId;
                            }
                            requestAnimationFrame(() => this.render());
                            return;
                        }
                    }

                    // Click on any line: select it
                    // Check if we clicked directly on a line element with a .link class
                    if (e.target.tagName === 'line' && e.target.classList.contains('link')) {
                        const line = e.target;
                        // Check if this line has the data attributes (and not modifier keys)
                        if (line.dataset.type && !e.ctrlKey && !e.metaKey && !e.altKey) {
                            // Select the line
                            if (line.dataset.type === 'parent') {
                                this.selectedLine = {
                                    type: 'parent',
                                    taskId: parseInt(line.dataset.taskId),
                                    parentId: parseInt(line.dataset.parentId)
                                };
                            } else if (line.dataset.type === 'dependency') {
                                this.selectedLine = {
                                    type: 'dependency',
                                    from: parseInt(line.dataset.from),
                                    to: parseInt(line.dataset.to)
                                };
                            }
                            this.selectedTaskIds.clear(); // Clear node selection
                            this.render();
                            e.preventDefault();
                            e.stopPropagation();
                            return;
                        }
                    }

                });

                // Right-click: Show context menu
                svg.addEventListener('contextmenu', (e) => {
                    e.preventDefault();
                    e.stopPropagation();

                    const node = e.target.closest('.task-node');
                    if (node) {
                        // Right-click on node
                        const taskId = parseInt(node.dataset.id);
                        this.showNodeMenu(e, taskId);
                    } else {
                        // Right-click on empty space
                        this.showEmptySpaceMenu(e);
                    }
                });

                // Close menu when clicking elsewhere
                document.addEventListener('click', (e) => {
                    const menu = document.querySelector('.node-menu');
                    if (menu) {
                        if (!e.target.closest('.node-menu')) {
                            this.closeMenu();
                        }
                    }
                });

                // Backspace to delete selected node(s) or line
                document.addEventListener('keydown', (e) => {
                    if (e.key === 'Backspace' && this.editingTaskId === null) {
                        if (this.selectedTaskIds.size > 0) {
                            e.preventDefault();
                            // Delete all selected tasks
                            const selectedArray = Array.from(this.selectedTaskIds);
                            if (selectedArray.length === 1) {
                                this.deleteTask(selectedArray[0]);
                            } else {
                                this.deleteMultipleTasks(selectedArray);
                            }
                        } else if (this.selectedLine) {
                            e.preventDefault();
                            this.deleteLine(this.selectedLine);
                        }
                    }

                    // Escape to clear selection
                    if (e.key === 'Escape' && this.editingTaskId === null) {
                        if (this.selectedTaskIds.size > 0 || this.selectedLine) {
                            this.selectedTaskIds.clear();
                            this.selectedLine = null;
                            this.render();
                        }
                    }
                });

                window.addEventListener('resize', () => {
                    this.viewBox.width = window.innerWidth;
                    this.viewBox.height = window.innerHeight - 60;
                    this.render();
                });

                // Close modal when clicking outside
                document.getElementById('import-modal').addEventListener('click', (e) => {
                    if (e.target.id === 'import-modal') {
                        this.hideImportModal();
                    }
                });

                document.getElementById('confirm-modal').addEventListener('click', (e) => {
                    if (e.target.id === 'confirm-modal') {
                        this.hideConfirm();
                    }
                });

                document.getElementById('alert-modal').addEventListener('click', (e) => {
                    if (e.target.id === 'alert-modal') {
                        this.hideAlert();
                    }
                });

                document.getElementById('create-home-modal').addEventListener('click', (e) => {
                    if (e.target.id === 'create-home-modal') {
                        this.hideCreateHomeModal();
                    }
                });

                document.getElementById('manage-homes-modal').addEventListener('click', (e) => {
                    if (e.target.id === 'manage-homes-modal') {
                        this.hideManageHomesModal();
                    }
                });

                // Enter key to create home from modal
                document.getElementById('home-name-input').addEventListener('keydown', (e) => {
                    if (e.key === 'Enter') {
                        this.createHomeFromModal();
                    }
                });

                // Zoom with mouse wheel
                svg.addEventListener('wheel', (e) => {
                    e.preventDefault();

                    const scrollDirection = e.deltaY > 0 ? -1 : 1;
                    const zoomFactor = 1 + (this.zoomSpeed * scrollDirection);

                    this.zoomLevel = Math.max(
                        this.minZoom,
                        Math.min(this.maxZoom, this.zoomLevel * zoomFactor)
                    );

                    this.updateZoomDisplay();
                    this.render();
                }, { passive: false });

                // Zoom with keyboard shortcuts
                document.addEventListener('keydown', (e) => {
                    if (this.editingTaskId !== null) return; // Don't zoom while editing text

                    // Ctrl/Cmd + Plus/Equals = zoom in
                    if ((e.ctrlKey || e.metaKey) && (e.key === '+' || e.key === '=')) {
                        e.preventDefault();
                        this.zoomIn();
                    }

                    // Ctrl/Cmd + Minus = zoom out
                    if ((e.ctrlKey || e.metaKey) && e.key === '-') {
                        e.preventDefault();
                        this.zoomOut();
                    }

                    // Ctrl/Cmd + 0 = reset zoom
                    if ((e.ctrlKey || e.metaKey) && e.key === '0') {
                        e.preventDefault();
                        this.resetZoom();
                    }

                    // Ctrl/Cmd + 1 = zoom to fit
                    if ((e.ctrlKey || e.metaKey) && e.key === '1') {
                        e.preventDefault();
                        this.zoomToFit();
                    }

                    // Ctrl/Cmd + Z = undo
                    if ((e.ctrlKey || e.metaKey) && e.key === 'z' && !e.shiftKey) {
                        e.preventDefault();
                        this.undo();
                    }

                    // Ctrl/Cmd + Shift + Z or Ctrl + Y = redo
                    if (((e.ctrlKey || e.metaKey) && e.key.toLowerCase() === 'z' && e.shiftKey) ||
                        (e.ctrlKey && e.key.toLowerCase() === 'y')) {
                        e.preventDefault();
                        this.redo();
                    }

                    // Number keys (0-9) = jump to home with that keybind (only when not modifying with Ctrl/Cmd/Alt)
                    if (!e.ctrlKey && !e.metaKey && !e.altKey && /^[0-9]$/.test(e.key)) {
                        // Find home with this keybind
                        const home = this.homes.find(h => h.keybind === e.key);
                        if (home) {
                            e.preventDefault();
                            this.jumpToHome(home.id);
                        }
                    }
                });
            },

            // Removed: addRootTask() - now use Ctrl+Click on empty space to create tasks

            addChildTask(parentId) {
                this.saveSnapshot(`Created child task 'New Task'`);

                const parent = this.tasks.find(t => t.id === parentId);
                const task = {
                    id: this.taskIdCounter++,
                    title: 'New Task',
                    x: parent.x + Math.random() * 200 - 100,
                    y: parent.y + 150 + Math.random() * 50,
                    vx: 0,
                    vy: 0,
                    mainParent: parentId,
                    otherParents: [],
                    children: [],
                    dependencies: [],
                    status: 'pending',
                    hidden: false,
                    currentlyWorking: false,
                    textExpanded: false,
                    textLocked: false
                };

                parent.children.push(task.id);
                this.tasks.push(task);
                this.saveToStorage();
                this.updateStatusBar();
                this.render();
                
                // Auto-start editing the new task
                setTimeout(() => this.startEditing(task.id), 50);
            },

            createChildAtPosition({ parentId, x, y }) {
                const parent = this.tasks.find(t => t.id === parentId);
                if (!parent) return;

                this.saveSnapshot(`Created child task`);

                const task = {
                    id: this.taskIdCounter++,
                    title: '',  // Empty - user will edit immediately
                    x: x,
                    y: y,
                    vx: 0,
                    vy: 0,
                    mainParent: parentId,
                    otherParents: [],
                    children: [],
                    dependencies: [],
                    status: 'pending',
                    hidden: false,
                    currentlyWorking: false,
                    textExpanded: false,
                    textLocked: false
                };

                parent.children.push(task.id);
                this.tasks.push(task);
                this.saveToStorage();
                this.updateStatusBar();
                this.render();

                // Auto-start editing the new task
                setTimeout(() => this.startEditing(task.id), 50);
                this.showToast('Child task created', 'success', 2000);
            },

            cycleStatus(taskId) {
                const task = this.tasks.find(t => t.id === taskId);
                const truncatedTitle = task.title.length > 30 ? task.title.substring(0, 27) + '...' : task.title;

                if (task.status === 'pending' && !task.currentlyWorking) {
                    // Pending → Working
                    this.saveSnapshot(`Started working on '${truncatedTitle}'`);

                    // Multi-project: Only clear working in SAME root tree
                    const root = this.getRootTask(taskId);
                    const rootId = root ? root.id : null;

                    const previousWorkingId = this.workingTasksByRoot[rootId];
                    if (previousWorkingId) {
                        const prevTask = this.tasks.find(t => t.id === previousWorkingId);
                        if (prevTask) {
                            prevTask.currentlyWorking = false;
                            if (!prevTask.textLocked) {
                                prevTask.textExpanded = false;
                            }
                        }
                    }

                    task.currentlyWorking = true;
                    if (rootId) {
                        this.workingTasksByRoot[rootId] = taskId;
                    }
                } else if (task.currentlyWorking) {
                    // Working → Done
                    this.saveSnapshot(`Marked '${truncatedTitle}' as done`);

                    const root = this.getRootTask(taskId);
                    const rootId = root ? root.id : null;

                    task.currentlyWorking = false;
                    task.status = 'done';

                    // Update working log
                    if (rootId) {
                        delete this.workingTasksByRoot[rootId];
                    }

                    // Collapse text if unlocked
                    if (!task.textLocked) {
                        task.textExpanded = false;
                    }

                    // Flow state: Auto-start working on parent task to maintain momentum
                    if (task.mainParent !== null) {
                        const parent = this.tasks.find(t => t.id === task.mainParent);
                        if (parent && parent.status !== 'done') {
                            parent.currentlyWorking = true;
                            // Update working log for parent
                            if (rootId) {
                                this.workingTasksByRoot[rootId] = parent.id;
                            }
                            const parentTitle = parent.title.length > 30 ? parent.title.substring(0, 27) + '...' : parent.title;
                            this.showToast(`⬆️ Now working on parent: ${parentTitle}`, 'info', 3000);
                        }
                    }
                } else if (task.status === 'done') {
                    // Done → Pending
                    this.saveSnapshot(`Marked '${truncatedTitle}' as pending`);
                    task.status = 'pending';
                }

                this.autoCollapseCompleted(taskId);
                this.updateStatusBar();
                this.saveToStorage();
                this.render();
            },

            toggleDone(taskId) {
                const task = this.tasks.find(t => t.id === taskId);
                const truncatedTitle = task.title.length > 30 ? task.title.substring(0, 27) + '...' : task.title;
                const wasWorking = task.currentlyWorking;

                if (task.status === 'done') {
                    // Done → Pending
                    this.saveSnapshot(`Marked '${truncatedTitle}' as pending`);
                    task.status = 'pending';
                } else {
                    // Pending/Working → Done
                    this.saveSnapshot(`Marked '${truncatedTitle}' as done`);

                    const root = this.getRootTask(taskId);
                    const rootId = root ? root.id : null;

                    task.currentlyWorking = false;  // Stop working when marking done
                    task.status = 'done';

                    // Update working log
                    if (rootId && wasWorking) {
                        delete this.workingTasksByRoot[rootId];
                    }

                    // Flow state: Auto-start working on parent task to maintain momentum
                    if (wasWorking && task.mainParent !== null) {
                        const parent = this.tasks.find(t => t.id === task.mainParent);
                        if (parent && parent.status !== 'done') {
                            parent.currentlyWorking = true;
                            // Update working log for parent
                            if (rootId) {
                                this.workingTasksByRoot[rootId] = parent.id;
                            }
                            const parentTitle = parent.title.length > 30 ? parent.title.substring(0, 27) + '...' : parent.title;
                            this.showToast(`⬆️ Now working on parent: ${parentTitle}`, 'info', 3000);
                        }
                    }
                }

                // Check if parent subtree is all done
                this.autoCollapseCompleted(taskId);
                this.saveToStorage();
                this.updateStatusBar();
                this.render();
            },

            toggleWorking(taskId) {
                const task = this.tasks.find(t => t.id === taskId);
                const root = this.getRootTask(taskId);
                const rootId = root ? root.id : null;

                if (task.currentlyWorking) {
                    // Stop working on this task
                    task.currentlyWorking = false;
                    if (rootId) {
                        delete this.workingTasksByRoot[rootId];
                    }
                    // Collapse text if unlocked
                    if (!task.textLocked) {
                        task.textExpanded = false;
                    }
                } else {
                    // Start working - unwork previous in same root only
                    const previousWorkingId = this.workingTasksByRoot[rootId];
                    if (previousWorkingId) {
                        const prevTask = this.tasks.find(t => t.id === previousWorkingId);
                        if (prevTask) {
                            prevTask.currentlyWorking = false;
                            if (!prevTask.textLocked) {
                                prevTask.textExpanded = false;
                            }
                        }
                    }

                    task.currentlyWorking = true;
                    if (rootId) {
                        this.workingTasksByRoot[rootId] = taskId;
                    }
                }
                this.saveToStorage();
                this.updateStatusBar();
                this.render();
            },

            selectNode(taskId) {
                // Single-node selection (clears others)
                this.selectedTaskIds.clear();
                this.selectedTaskIds.add(taskId);
                this.lastClickedTaskId = taskId;
                // Defer render to next frame to avoid breaking double-click
                requestAnimationFrame(() => this.render());
            },

            updateStatusBar() {
                const workingTask = this.tasks.find(t => t.currentlyWorking);
                const statusBar = document.getElementById('status-bar');
                const container = document.getElementById('canvas-container');

                // Always show the status bar
                statusBar.classList.add('show');
                container.classList.add('has-status-bar');

                if (!workingTask) {
                    // Show default message
                    const pathEl = document.getElementById('status-path');
                    pathEl.innerHTML = '<span class="status-task">No task selected</span>';

                    const childrenEl = document.getElementById('status-children');
                    childrenEl.textContent = '| Middle-click a task to start working on it';
                    return;
                }

                // Get full path
                const path = this.getPathToRoot(workingTask.id);

                // Compress if too long
                let pathDisplay;
                if (path.length > 4) {
                    // Root > ... > Parent > Current
                    pathDisplay = `${path[0]} > ... > ${path[path.length - 2]} > `;
                } else if (path.length > 1) {
                    pathDisplay = path.slice(0, -1).join(' > ') + ' > ';
                } else {
                    pathDisplay = '';
                }

                // Add current task in yellow
                const pathEl = document.getElementById('status-path');
                pathEl.innerHTML = pathDisplay + `<span class="status-task">${workingTask.title}</span>`;

                // Children info with percentage and incomplete list
                const childrenEl = document.getElementById('status-children');
                const childCount = workingTask.children.length;

                if (childCount > 0) {
                    const completeCount = workingTask.children.filter(childId => {
                        const child = this.tasks.find(t => t.id === childId);
                        return child && child.status === 'done';
                    }).length;

                    const percentage = Math.round((completeCount / childCount) * 100);

                    const incompleteChildren = workingTask.children
                        .filter(childId => {
                            const child = this.tasks.find(t => t.id === childId);
                            return child && child.status !== 'done';
                        })
                        .map(childId => {
                            const child = this.tasks.find(t => t.id === childId);
                            return child ? child.title : '';
                        });

                    let childText = `| Children: ${completeCount}/${childCount} (${percentage}%)`;
                    if (incompleteChildren.length > 0) {
                        childText += ` | Incomplete: ${incompleteChildren.join(', ')}`;
                        childrenEl.innerHTML = childText + ' <span class="status-warning">⚠</span>';
                    } else {
                        childrenEl.innerHTML = childText;
                    }
                } else {
                    childrenEl.textContent = '| No children';
                }
            },

            toggleHiddenSelf(taskId) {
                // Hide/show the node itself (not its children)
                const task = this.tasks.find(t => t.id === taskId);
                if (!task || task.mainParent === null) {
                    // Can't hide root tasks - they have no parent
                    return;
                }

                const truncatedTitle = task.title.length > 30 ? task.title.substring(0, 27) + '...' : task.title;
                this.saveSnapshot(task.hidden ? `Showed '${truncatedTitle}'` : `Hid '${truncatedTitle}'`);

                task.hidden = !task.hidden;

                this.saveToStorage();
                this.render();
            },

            toggleHidden(taskId) {
                // Toggle all descendants (children stay hidden as a group)
                const descendants = this.getDescendants(taskId);

                // Check if any are currently hidden
                const anyHidden = descendants.some(id => {
                    const child = this.tasks.find(t => t.id === id);
                    return child && child.hidden;
                });

                // Save snapshot
                const task = this.tasks.find(t => t.id === taskId);
                const truncatedTitle = task.title.length > 30 ? task.title.substring(0, 27) + '...' : task.title;
                this.saveSnapshot(anyHidden ? `Showed children of '${truncatedTitle}'` : `Hid children of '${truncatedTitle}'`);

                // Toggle: if any are hidden, show all; if all shown, hide all
                descendants.forEach(id => {
                    const child = this.tasks.find(t => t.id === id);
                    if (child) {
                        child.hidden = !anyHidden;
                    }
                });

                // If we're showing children again, make sure the parent is visible too
                if (anyHidden) {
                    if (task) {
                        task.hidden = false;
                    }
                }

                this.saveToStorage();
                this.render();
            },

            getHiddenChildrenCount(taskId) {
                const task = this.tasks.find(t => t.id === taskId);
                if (!task) return 0;

                return task.children.filter(childId => {
                    const child = this.tasks.find(t => t.id === childId);
                    return child && child.hidden;
                }).length;
            },

            deleteTask(taskId) {
                const task = this.tasks.find(t => t.id === taskId);
                const taskTitle = task ? task.title : 'task';

                const performDelete = () => {
                    // Save snapshot before deletion
                    const truncatedTitle = taskTitle.length > 30 ? taskTitle.substring(0, 27) + '...' : taskTitle;
                    this.saveSnapshot(`Deleted task '${truncatedTitle}'`);

                    const descendants = this.getDescendants(taskId);
                    const toDelete = [taskId, ...descendants];

                    // Remove from parents' children arrays
                    this.tasks.forEach(task => {
                        task.children = task.children.filter(id => !toDelete.includes(id));
                        task.dependencies = task.dependencies.filter(id => !toDelete.includes(id));
                        task.otherParents = task.otherParents.filter(id => !toDelete.includes(id));
                    });

                    // Remove tasks
                    this.tasks = this.tasks.filter(t => !toDelete.includes(t.id));

                    // Clean up working log if deleted task was working
                    Object.keys(this.workingTasksByRoot).forEach(rootId => {
                        if (toDelete.includes(this.workingTasksByRoot[rootId])) {
                            delete this.workingTasksByRoot[rootId];
                        }
                    });

                    this.saveToStorage();
                    this.updateStatusBar();
                    this.render();
                };

                if (this.showDeleteConfirmation) {
                    this.showConfirm(
                        'Delete Task',
                        'Delete this task and all its children? This can be undone with Ctrl+Z.',
                        performDelete
                    );
                } else {
                    performDelete();
                }
            },

            deleteMultipleTasks(taskIds) {
                // Delete multiple selected tasks with confirmation
                const performDelete = () => {
                    this.saveSnapshot(`Deleted ${taskIds.length} tasks`);

                    // Collect all tasks to delete (including descendants of each selected task)
                    let toDelete = new Set();
                    taskIds.forEach(taskId => {
                        toDelete.add(taskId);
                        this.getDescendants(taskId).forEach(descendantId => {
                            toDelete.add(descendantId);
                        });
                    });
                    const toDeleteArray = Array.from(toDelete);

                    // Remove from parents' children arrays
                    this.tasks.forEach(task => {
                        task.children = task.children.filter(id => !toDeleteArray.includes(id));
                        task.dependencies = task.dependencies.filter(id => !toDeleteArray.includes(id));
                        task.otherParents = task.otherParents.filter(id => !toDeleteArray.includes(id));
                    });

                    // Remove tasks
                    this.tasks = this.tasks.filter(t => !toDeleteArray.includes(t.id));
                    this.selectedTaskIds.clear();

                    this.saveToStorage();
                    this.updateStatusBar();
                    this.render();
                };

                if (this.showDeleteConfirmation) {
                    this.showConfirm(
                        `Delete ${taskIds.length} Tasks`,
                        `Delete ${taskIds.length} selected tasks and all their children? This can be undone with Ctrl+Z.`,
                        performDelete
                    );
                } else {
                    performDelete();
                }
            },

            getDescendants(taskId) {
                const task = this.tasks.find(t => t.id === taskId);
                if (!task) return [];

                let descendants = [];
                task.children.forEach(childId => {
                    descendants.push(childId);
                    descendants = descendants.concat(this.getDescendants(childId));
                });
                return descendants;
            },

            getRootTask(taskId) {
                // Find the root task of the tree containing this task
                let task = this.tasks.find(t => t.id === taskId);
                if (!task) return null;

                // Traverse up the parent chain to find root
                while (task.mainParent !== null) {
                    task = this.tasks.find(t => t.id === task.mainParent);
                    if (!task) return null;
                }
                return task;
            },

            getAncestors(taskId) {
                const task = this.tasks.find(t => t.id === taskId);
                if (!task || task.mainParent === null) return [];
                
                const ancestors = [task.mainParent];
                ancestors.push(...this.getAncestors(task.mainParent));
                return ancestors;
            },

            getPathToRoot(taskId) {
                const path = [];
                let currentId = taskId;
                
                while (currentId !== null) {
                    const task = this.tasks.find(t => t.id === currentId);
                    if (!task) break;
                    path.unshift(task.title);
                    currentId = task.mainParent;
                }
                
                return path;
            },

            autoCollapseCompleted(clickedTaskId) {
                // Skip if auto-hide is disabled
                if (!this.autoHideCompletedNodes) {
                    return;
                }

                // Only process the clicked task and its affected relatives, not all tasks
                const task = clickedTaskId ? this.tasks.find(t => t.id === clickedTaskId) : null;
                if (!task) return;

                // Check if any children are manually hidden via toggleHidden
                const hasManuallyHiddenChildren = task.children.some(childId => {
                    const child = this.tasks.find(t => t.id === childId);
                    return child && child.hidden;
                });

                // If task has manually hidden children, skip auto-hide for this task
                if (hasManuallyHiddenChildren) {
                    return;
                }

                // Part 1: Hide completed children if task is done and all children are done
                if (task.children.length > 0 && task.status === 'done') {
                    const allChildrenDone = task.children.every(childId => {
                        const child = this.tasks.find(t => t.id === childId);
                        return child && child.status === 'done';
                    });

                    // Hide all children if they're all done
                    if (allChildrenDone) {
                        task.children.forEach(childId => {
                            const child = this.tasks.find(t => t.id === childId);
                            if (child) child.hidden = true;
                        });
                    }
                }

                // Part 2: Hide the task itself ONLY if it has a parent AND that parent is done
                // Root tasks (no parent) are NEVER auto-hidden
                // Tasks inside non-completed parents are NEVER auto-hidden
                if (task.status === 'done' && task.mainParent !== null) {
                    const parent = this.tasks.find(t => t.id === task.mainParent);
                    if (parent && parent.status === 'done') {
                        task.hidden = true;
                    }
                }

                // Also process parent if it needs to be collapsed
                if (task.mainParent !== null) {
                    const parent = this.tasks.find(t => t.id === task.mainParent);
                    if (parent) {
                        this.autoCollapseCompleted(parent.id);
                    }
                }
            },

            clearCompleted() {
                this.tasks = this.tasks.filter(t => t.status !== 'done');
                this.saveToStorage();
                this.render();
            },

            toggleDarkMode() {
                this.darkMode = !this.darkMode;
                const btn = document.getElementById('darkModeToggle');
                if (this.darkMode) {
                    document.body.classList.add('dark-mode');
                    btn.textContent = '☀️ Light Mode';
                } else {
                    document.body.classList.remove('dark-mode');
                    btn.textContent = '🌙 Dark Mode';
                }
                this.saveToStorage();
                this.render();
            },

            zoomIn() {
                this.zoomLevel = Math.min(this.zoomLevel + this.zoomSpeed, this.maxZoom);
                this.updateZoomDisplay();
                this.render();
            },

            zoomOut() {
                this.zoomLevel = Math.max(this.zoomLevel - this.zoomSpeed, this.minZoom);
                this.updateZoomDisplay();
                this.render();
            },

            resetZoom() {
                this.zoomLevel = 1;
                this.updateZoomDisplay();
                this.render();
            },

            zoomToFit() {
                if (this.tasks.length === 0) {
                    this.resetZoom();
                    return;
                }

                // Find bounding box of all visible tasks
                let minX = Infinity, maxX = -Infinity;
                let minY = Infinity, maxY = -Infinity;

                this.tasks.forEach(task => {
                    if (!task.hidden) {
                        minX = Math.min(minX, task.x - 50);
                        maxX = Math.max(maxX, task.x + 50);
                        minY = Math.min(minY, task.y - 30);
                        maxY = Math.max(maxY, task.y + 30);
                    }
                });

                if (minX === Infinity) {
                    this.resetZoom();
                    return;
                }

                const padding = 100;
                const width = maxX - minX + padding * 2;
                const height = maxY - minY + padding * 2;

                // Calculate zoom to fit
                const scaleX = this.viewBox.width / width;
                const scaleY = this.viewBox.height / height;
                this.zoomLevel = Math.min(scaleX, scaleY, this.maxZoom);
                this.zoomLevel = Math.max(this.zoomLevel, this.minZoom);

                this.updateZoomDisplay();
                this.render();
            },

            updateZoomDisplay() {
                const percent = Math.round(this.zoomLevel * 100);
                const display = document.getElementById('zoomLevel');
                if (display) {
                    display.textContent = `${percent}%`;
                }
            },

            updateViewBoxOnly() {
                // Update just the SVG viewBox for smooth zoom animation
                // Used during animated transitions to avoid full re-render
                const svg = document.getElementById('canvas');
                const viewBoxWidth = this.viewBox.width / this.zoomLevel;
                const viewBoxHeight = this.viewBox.height / this.zoomLevel;
                svg.setAttribute('viewBox',
                    `${this.viewBox.x - (viewBoxWidth - this.viewBox.width) / 2} ` +
                    `${this.viewBox.y - (viewBoxHeight - this.viewBox.height) / 2} ` +
                    `${viewBoxWidth} ${viewBoxHeight}`
                );
            },

            startEditing(taskId) {
                this.editingTaskId = taskId;
                this.render();
                
                // Focus the input after render
                setTimeout(() => {
                    const input = document.getElementById('edit-input');
                    if (input) {
                        input.focus();
                        input.select();
                    }
                }, 10);
            },

            finishEditing(save = true) {
                if (this.editingTaskId === null) return;

                if (save) {
                    const input = document.getElementById('edit-input');
                    if (input) {
                        const task = this.tasks.find(t => t.id === this.editingTaskId);
                        if (task) {
                            const newTitle = input.value.trim() || 'Untitled';
                            // Save snapshot with 2-second grouping for edits to same task
                            const truncatedTitle = newTitle.length > 30 ? newTitle.substring(0, 27) + '...' : newTitle;
                            this.saveSnapshot(`Edited task '${truncatedTitle}'`, this.editingTaskId);
                            task.title = newTitle;
                        }
                    }
                }

                this.editingTaskId = null;
                this.saveToStorage();
                this.updateStatusBar();
                this.render();
            },

            calculateTextBoxDimensions(text) {
                // Helper method to calculate rectangle dimensions for given text
                // Returns { rectWidth, rectHeight, lines }
                // Used by both render() and resizeEditingBox() for consistent sizing

                const padding = this.nodePadding;
                const charWidth = this.charWidth;
                const minWidth = this.minNodeWidth;

                // Wrap text into lines based on max width
                const lines = this.wrapText(text, this.maxNodeWidth, charWidth, this.wordWrap);

                // Calculate width: minimum of (maxNodeWidth OR longest line width OR minWidth)
                const longestLineWidth = Math.max(...lines.map(line => line.length * charWidth + padding * 2));
                const rectWidth = Math.max(minWidth, Math.min(this.maxNodeWidth, longestLineWidth));

                // Calculate height: lines * lineHeight + vertical padding
                const verticalPadding = 10;
                const calculatedHeight = lines.length * this.lineHeight + verticalPadding * 2;

                // Apply max height constraint if configured
                const rectHeight = this.maxNodeHeight > 0
                    ? Math.min(this.maxNodeHeight, calculatedHeight)
                    : calculatedHeight;

                return { rectWidth, rectHeight, lines };
            },

            resizeEditingBox() {
                // Dynamically resize the editing textarea and its container rectangle
                // Called on every keystroke (oninput event) during editing

                if (this.editingTaskId === null) return;

                const textarea = document.getElementById('edit-input');
                if (!textarea) return;

                // Get current text from textarea
                const currentText = textarea.value || '';

                // Calculate new dimensions based on current text
                const { rectWidth, rectHeight, lines } = this.calculateTextBoxDimensions(currentText);

                // Find the task node and its child elements
                const taskNode = document.querySelector(`.task-node[data-id="${this.editingTaskId}"]`);
                if (!taskNode) return;

                const rect = taskNode.querySelector('rect');
                const foreignObject = taskNode.querySelector('foreignObject');

                if (!rect || !foreignObject) return;

                // Update rectangle dimensions (centered at 0,0)
                rect.setAttribute('x', -rectWidth / 2);
                rect.setAttribute('y', -rectHeight / 2);
                rect.setAttribute('width', rectWidth);
                rect.setAttribute('height', rectHeight);

                // Update foreignObject (container for textarea)
                foreignObject.setAttribute('x', -rectWidth / 2);
                foreignObject.setAttribute('y', -rectHeight / 2 + 5);
                foreignObject.setAttribute('width', rectWidth);
                foreignObject.setAttribute('height', rectHeight - 10);

                // Update textarea rows for better UX
                textarea.rows = Math.max(2, lines.length);
            },

            wrapText(text, maxWidth, charWidth, wordWrap) {
                // Return single line if multiline is disabled
                if (!this.enableMultiline) {
                    return [text];
                }

                // Calculate maximum characters that fit in one line
                const maxChars = Math.floor(maxWidth / charWidth);
                if (maxChars <= 0) return [text]; // Safety check

                // NEW: First split by newlines to preserve user line breaks
                const paragraphs = text.split('\n');
                const allLines = [];

                // Process each paragraph (line break = user intent)
                for (const paragraph of paragraphs) {
                    // Handle empty lines (preserve them as blank lines)
                    if (paragraph === '') {
                        allLines.push('');
                        continue;
                    }

                    if (wordWrap) {
                        // Split on word boundaries within this paragraph
                        const words = paragraph.split(' ');
                        let currentLine = '';

                        for (const word of words) {
                            const testLine = currentLine + (currentLine ? ' ' : '') + word;
                            const testWidth = testLine.length * charWidth;

                            if (testWidth <= maxWidth) {
                                currentLine = testLine;
                            } else {
                                // Line would be too long
                                if (currentLine) {
                                    allLines.push(currentLine);
                                }

                                // Handle single word longer than max width
                                if (word.length * charWidth > maxWidth) {
                                    // Force character break for long words
                                    let remainingWord = word;
                                    while (remainingWord.length > 0) {
                                        allLines.push(remainingWord.substring(0, maxChars));
                                        remainingWord = remainingWord.substring(maxChars);
                                    }
                                    currentLine = '';
                                } else {
                                    currentLine = word;
                                }
                            }
                        }

                        if (currentLine) {
                            allLines.push(currentLine);
                        }
                    } else {
                        // Character wrapping - simple split at max chars for this paragraph
                        for (let i = 0; i < paragraph.length; i += maxChars) {
                            allLines.push(paragraph.substring(i, i + maxChars));
                        }
                    }
                }

                // Return at least one line (even if empty)
                return allLines.length > 0 ? allLines : [''];
            },

            clearAllData() {
                this.showConfirm(
                    'Clear All Data',
                    'Delete ALL tasks and reset everything? This can be undone with Ctrl+Z.',
                    () => {
                        this.saveSnapshot('Cleared all data');
                        localStorage.removeItem('taskTree');
                        this.tasks = [];
                        this.taskIdCounter = 0;
                        this.editingTaskId = null;

                        this.updateStatusBar();
                        this.render();
                    }
                );
            },

            exportData() {
                const json = localStorage.getItem('taskTree') || '{}';
                const blob = new Blob([json], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `task-tree-${new Date().toISOString().slice(0,10)}.json`;
                a.click();
                URL.revokeObjectURL(url);
            },

            copyDataToClipboard(e) {
                const json = localStorage.getItem('taskTree') || '{}';
                navigator.clipboard.writeText(json).then(() => {
                    // Show brief feedback
                    const btn = e.target;
                    const originalText = btn.textContent;
                    btn.textContent = 'Copied!';
                    btn.style.background = '#28a745';
                    setTimeout(() => {
                        btn.textContent = originalText;
                        btn.style.background = '';
                    }, 1500);
                }).catch(err => {
                    this.showAlert('Copy Failed', 'Failed to copy to clipboard: ' + err.message);
                });
            },

            showImportModal() {
                const modal = document.getElementById('import-modal');
                modal.classList.add('show');
                document.getElementById('import-textarea').value = '';
            },

            hideImportModal() {
                const modal = document.getElementById('import-modal');
                modal.classList.remove('show');
            },

            showConfirm(title, message, onConfirm) {
                document.getElementById('confirm-title').textContent = title;
                document.getElementById('confirm-message').textContent = message;
                const modal = document.getElementById('confirm-modal');
                modal.classList.add('show');
                
                const yesBtn = document.getElementById('confirm-yes');
                const noBtn = document.getElementById('confirm-no');
                
                // Remove old listeners by cloning
                const newYesBtn = yesBtn.cloneNode(true);
                const newNoBtn = noBtn.cloneNode(true);
                yesBtn.replaceWith(newYesBtn);
                noBtn.replaceWith(newNoBtn);
                
                newYesBtn.onclick = () => {
                    this.hideConfirm();
                    onConfirm();
                };
                newNoBtn.onclick = () => this.hideConfirm();
            },

            hideConfirm() {
                const modal = document.getElementById('confirm-modal');
                modal.classList.remove('show');
            },

            showAlert(title, message) {
                document.getElementById('alert-title').textContent = title;
                document.getElementById('alert-message').textContent = message;
                const modal = document.getElementById('alert-modal');
                modal.classList.add('show');
                
                const okBtn = document.getElementById('alert-ok');
                const newOkBtn = okBtn.cloneNode(true);
                okBtn.replaceWith(newOkBtn);
                
                newOkBtn.onclick = () => this.hideAlert();
            },

            hideAlert() {
                const modal = document.getElementById('alert-modal');
                modal.classList.remove('show');
            },

            showSettingsModal() {
                // Configuration metadata - defines which app properties are user-customizable
                const configDefs = {
                    textLengthThreshold: {
                        label: 'Text Truncation Length',
                        type: 'number',
                        default: 80,
                        min: 20,
                        max: 200,
                        description: 'Characters before text is truncated'
                    },
                    charWidth: {
                        label: 'Character Width (px)',
                        type: 'number',
                        default: 8.5,
                        min: 4,
                        max: 15,
                        step: 0.5,
                        description: 'Pixels per character for node width calculation'
                    },
                    nodePadding: {
                        label: 'Node Padding (px)',
                        type: 'number',
                        default: 30,
                        min: 0,
                        max: 50,
                        description: 'Left/right padding inside rectangles'
                    },
                    minNodeWidth: {
                        label: 'Minimum Node Width (px)',
                        type: 'number',
                        default: 100,
                        min: 40,
                        max: 200,
                        description: 'Minimum rectangle width'
                    },
                    fontFamily: {
                        label: 'Font Family',
                        type: 'text',
                        default: "'Fira Code', 'Consolas', 'Monaco', 'Courier New', monospace",
                        description: 'CSS font stack for task text'
                    },
                    fontWeight: {
                        label: 'Font Weight',
                        type: 'select',
                        default: 700,
                        options: [
                            { value: 300, label: 'Light (300)' },
                            { value: 400, label: 'Normal (400)' },
                            { value: 500, label: 'Medium (500)' },
                            { value: 600, label: 'Semibold (600)' },
                            { value: 700, label: 'Bold (700)' }
                        ],
                        description: 'Font weight for task text'
                    },
                    showDeleteConfirmation: {
                        label: 'Show Delete Confirmation',
                        type: 'checkbox',
                        default: true,
                        description: 'Show confirmation dialog when deleting tasks (can still undo with Ctrl+Z)'
                    },
                    autoHideCompletedNodes: {
                        label: 'Auto-Hide Completed Nodes',
                        type: 'checkbox',
                        default: true,
                        description: 'Automatically hide child nodes when they and their parent are marked done'
                    },
                    enableMultiline: {
                        label: 'Enable Multiline Text',
                        type: 'checkbox',
                        default: true,
                        description: 'Allow task text to wrap to multiple lines when it exceeds max width'
                    },
                    maxNodeWidth: {
                        label: 'Max Node Width (px)',
                        type: 'number',
                        default: 600,
                        min: 100,
                        max: 2000,
                        description: 'Maximum node width in pixels before text wraps to next line'
                    },
                    maxNodeHeight: {
                        label: 'Max Node Height (px)',
                        type: 'number',
                        default: 0,
                        min: 0,
                        max: 1000,
                        description: 'Maximum node height in pixels (0 = unlimited)'
                    },
                    lineHeight: {
                        label: 'Line Height (px)',
                        type: 'number',
                        default: 20,
                        min: 12,
                        max: 40,
                        description: 'Vertical spacing between lines of text'
                    },
                    wordWrap: {
                        label: 'Word Wrap',
                        type: 'checkbox',
                        default: true,
                        description: 'Wrap text on word boundaries (more readable) vs character boundaries'
                    },
                    arrowStyle: {
                        label: 'Arrow Style',
                        type: 'select',
                        default: 'straight',
                        options: [
                            { value: 'straight', label: 'Straight' },
                            { value: 'curved', label: 'Curved' }
                        ],
                        description: 'Visual style for arrows connecting tasks'
                    },
                    arrowCurvature: {
                        label: 'Arrow Curvature',
                        type: 'number',
                        default: 0.25,
                        min: 0.05,
                        max: 0.5,
                        step: 0.05,
                        description: 'Intensity of curve for curved arrows (0.05 = subtle, 0.5 = dramatic)'
                    },
                    maxUndoSteps: {
                        label: 'Max Undo History',
                        type: 'number',
                        default: 50,
                        min: 5,
                        max: 200,
                        step: 5,
                        description: 'Maximum number of undo steps to keep in history (5-200). Higher values use more memory.'
                    }
                };

                // Generate form HTML
                const formContainer = document.getElementById('settings-form');
                let html = '<div style="display: flex; flex-direction: column; gap: 20px;">';

                for (const [key, def] of Object.entries(configDefs)) {
                    const currentValue = this[key];
                    html += `
                        <div class="settings-field">
                            <label style="display: block; font-weight: 600; margin-bottom: 5px;">
                                ${def.label}
                            </label>
                            <div style="font-size: 12px; color: #666; margin-bottom: 8px;">
                                ${def.description}
                            </div>`;

                    if (def.type === 'number') {
                        html += `
                            <input
                                type="number"
                                id="setting-${key}"
                                value="${currentValue}"
                                min="${def.min || ''}"
                                max="${def.max || ''}"
                                step="${def.step || 1}"
                                style="width: 100%; padding: 8px; font-size: 14px; border: 1px solid #ccc; border-radius: 4px;"
                            />`;
                    } else if (def.type === 'text') {
                        html += `
                            <input
                                type="text"
                                id="setting-${key}"
                                value="${currentValue}"
                                style="width: 100%; padding: 8px; font-size: 14px; border: 1px solid #ccc; border-radius: 4px;"
                            />`;
                    } else if (def.type === 'select') {
                        html += `<select id="setting-${key}" style="width: 100%; padding: 8px; font-size: 14px; border: 1px solid #ccc; border-radius: 4px;">`;
                        for (const opt of def.options) {
                            const selected = currentValue == opt.value ? 'selected' : '';
                            html += `<option value="${opt.value}" ${selected}>${opt.label}</option>`;
                        }
                        html += `</select>`;
                    } else if (def.type === 'checkbox') {
                        const checked = currentValue ? 'checked' : '';
                        html += `
                            <label style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
                                <input
                                    type="checkbox"
                                    id="setting-${key}"
                                    ${checked}
                                    style="width: 18px; height: 18px; cursor: pointer;"
                                />
                                <span style="font-size: 14px;">Enable this option</span>
                            </label>`;
                    }

                    html += `</div>`;
                }

                html += '</div>';
                formContainer.innerHTML = html;

                // Store config defs for later use
                this._configDefs = configDefs;

                // Add ESC key handler
                this._settingsEscHandler = (e) => {
                    if (e.key === 'Escape') {
                        this.hideSettingsModal();
                    }
                };
                document.addEventListener('keydown', this._settingsEscHandler);

                // Add click-outside handler
                this._settingsClickHandler = (e) => {
                    const modal = document.getElementById('settings-modal');
                    if (e.target === modal) {
                        this.hideSettingsModal();
                    }
                };
                const modal = document.getElementById('settings-modal');
                modal.addEventListener('click', this._settingsClickHandler);

                // Update history stats
                document.getElementById('undo-count').textContent = this.undoStack.length;
                document.getElementById('undo-limit').textContent = this.maxUndoSteps;
                document.getElementById('redo-count').textContent = this.redoStack.length;

                // Estimate memory usage
                const historyJSON = JSON.stringify({
                    undoStack: this.undoStack,
                    redoStack: this.redoStack
                });
                const sizeKB = Math.round(historyJSON.length / 1024);
                document.getElementById('history-size').textContent = sizeKB;

                // Show modal
                modal.classList.add('show');
            },

            hideSettingsModal() {
                const modal = document.getElementById('settings-modal');
                modal.classList.remove('show');

                // Remove event listeners
                if (this._settingsEscHandler) {
                    document.removeEventListener('keydown', this._settingsEscHandler);
                    this._settingsEscHandler = null;
                }
                if (this._settingsClickHandler) {
                    modal.removeEventListener('click', this._settingsClickHandler);
                    this._settingsClickHandler = null;
                }
            },

            applySettings() {
                // Read values from form and update app state
                for (const key of Object.keys(this._configDefs)) {
                    const input = document.getElementById(`setting-${key}`);
                    const def = this._configDefs[key];

                    if (def.type === 'number') {
                        this[key] = parseFloat(input.value);
                    } else if (def.type === 'select') {
                        // Check if select values are numeric or string
                        // If first option value is a number, parse as int, otherwise keep as string
                        const firstOptionValue = def.options[0].value;
                        if (typeof firstOptionValue === 'number' || !isNaN(parseInt(firstOptionValue))) {
                            this[key] = parseInt(input.value);
                        } else {
                            this[key] = input.value; // Keep as string for non-numeric selects
                        }
                    } else if (def.type === 'checkbox') {
                        this[key] = input.checked;
                    } else {
                        this[key] = input.value;
                    }
                }

                // Enforce undo limit if maxUndoSteps was changed
                this.enforceUndoLimit();

                // Re-render to apply visual changes
                this.render();

                // Save to localStorage
                this.saveToStorage();

                // Hide modal
                this.hideSettingsModal();

                // Show success feedback
                this.showToast('Settings applied successfully', 'success');
            },

            resetSettings() {
                // Confirm before resetting
                this.showConfirm(
                    'Reset Settings',
                    'Are you sure you want to reset all settings to their default values?',
                    () => {
                        // Reset all config values to defaults
                        for (const [key, def] of Object.entries(this._configDefs)) {
                            this[key] = def.default;
                        }

                        // Re-render and save
                        this.render();
                        this.saveToStorage();

                        // Re-populate form with new values
                        this.hideSettingsModal();
                        this.showSettingsModal();

                        // Show success feedback
                        this.showToast('Settings reset to defaults', 'success');
                    }
                );
            },

            exportSettings() {
                // Extract configuration parameters
                const settings = {
                    textLengthThreshold: this.textLengthThreshold,
                    charWidth: this.charWidth,
                    nodePadding: this.nodePadding,
                    minNodeWidth: this.minNodeWidth,
                    fontFamily: this.fontFamily,
                    fontWeight: this.fontWeight
                };

                // Format as pretty JSON
                const json = JSON.stringify(settings, null, 2);

                // Copy to clipboard
                navigator.clipboard.writeText(json).then(() => {
                    this.showToast('Settings copied to clipboard!', 'success');
                }).catch(err => {
                    this.showAlert('Export Failed', 'Failed to copy to clipboard: ' + err.message);
                });
            },

            showToast(message, type = 'success', duration = 4000) {
                // Create container if it doesn't exist
                let container = document.querySelector('.toast-container');
                if (!container) {
                    container = document.createElement('div');
                    container.className = 'toast-container';
                    document.body.appendChild(container);
                }

                // Create toast element
                const toast = document.createElement('div');
                toast.className = `toast ${type}`;
                toast.textContent = message;

                // Add to container
                container.appendChild(toast);

                // Auto-remove after duration
                setTimeout(() => {
                    toast.remove();
                }, duration);

                // Allow clicking to dismiss early
                toast.onclick = () => toast.remove();
            },

            loadTestChecklist() {
                // Create root test node
                const testRoot = {
                    id: this.taskIdCounter++,
                    title: '🧪 Test Recent Changes',
                    x: 200,
                    y: 200,
                    vx: 0,
                    vy: 0,
                    mainParent: null,
                    otherParents: [],
                    children: [],
                    dependencies: [],
                    status: 'pending',
                    hidden: false,
                    currentlyWorking: false
                };
                this.tasks.push(testRoot);

                // Test items for recent features
                const tests = [
                    {
                        title: 'Middle-Click Status Cycling',
                        children: [
                            'Middle-click pending task → becomes Working (yellow)',
                            'Middle-click again → becomes Done (green)',
                            'Middle-click again → becomes Pending (white)',
                            'Verify status bar updates when task is Working',
                            'Verify only one task can be Working at a time'
                        ]
                    },
                    {
                        title: 'Shift+Drag Subtree Movement',
                        children: [
                            'Create task with children',
                            'Shift+drag parent task',
                            'Verify entire subtree moves together',
                            'Verify relative positions preserved',
                            'Verify distances between nodes unchanged'
                        ]
                    },
                    {
                        title: 'Incomplete Children Highlighting',
                        children: [
                            'Create task with children',
                            'Mark task as "Working"',
                            'Verify incomplete children have red border',
                            'Mark a child done - red border should disappear'
                        ]
                    },
                    {
                        title: 'Custom Modals Work',
                        children: [
                            'Click Delete on a task - modal should appear',
                            'Click Cancel - modal closes, task remains',
                            'Click Delete again > Yes - task deletes',
                            'Test Clear All Data modal works'
                        ]
                    },
                    {
                        title: 'Enhanced Status Bar',
                        children: [
                            'Mark nested task as Working',
                            'Verify full path shows (Root > ... > Current)',
                            'Check completion percentage displays',
                            'Verify incomplete children listed by name',
                            'Path compresses correctly if >4 levels deep'
                        ]
                    },
                    {
                        title: 'Dependency Cleanup on Reparent',
                        children: [
                            'Create dependency A→B with Ctrl+drag',
                            'Alt+drag A to B (reparent)',
                            'Verify dependency arrow disappears',
                            'Verify A is now child of B'
                        ]
                    },
                    {
                        title: 'Visual Alt+Drag Distinction',
                        children: [
                            'Ctrl+drag - verify dashed blue line',
                            'Alt+drag - verify solid green line',
                            'Complete both operations successfully'
                        ]
                    }
                ];

                let yOffset = 0;
                tests.forEach((category, idx) => {
                    const categoryTask = {
                        id: this.taskIdCounter++,
                        title: category.title,
                        x: 400,
                        y: 200 + yOffset,
                        vx: 0,
                        vy: 0,
                        mainParent: testRoot.id,
                        otherParents: [],
                        children: [],
                        dependencies: [],
                        status: 'pending',
                        hidden: false,
                        currentlyWorking: false
                    };
                    this.tasks.push(categoryTask);
                    testRoot.children.push(categoryTask.id);

                    category.children.forEach((testName, childIdx) => {
                        const testTask = {
                            id: this.taskIdCounter++,
                            title: testName,
                            x: 600,
                            y: 200 + yOffset + (childIdx * 60),
                            vx: 0,
                            vy: 0,
                            mainParent: categoryTask.id,
                            otherParents: [],
                            children: [],
                            dependencies: [],
                            status: 'pending',
                            hidden: false,
                            currentlyWorking: false
                        };
                        this.tasks.push(testTask);
                        categoryTask.children.push(testTask.id);
                    });

                    yOffset += category.children.length * 60 + 80;
                });

                this.saveToStorage();
                this.render();
                
                this.showAlert('Test Checklist Loaded', 'Testing tasks have been added to your graph. Check them off as you test!');
            },

            importData() {
                const textarea = document.getElementById('import-textarea');
                const json = textarea.value.trim();

                if (!json) {
                    this.showAlert('Import Error', 'Please paste JSON data first.');
                    return;
                }

                try {
                    // Validate JSON
                    const parsed = JSON.parse(json);
                    if (!parsed.tasks || !Array.isArray(parsed.tasks)) {
                        throw new Error('Invalid task tree format');
                    }

                    // Save snapshot before importing
                    const taskCount = parsed.tasks ? parsed.tasks.length : 0;
                    this.saveSnapshot(`Imported ${taskCount} task${taskCount !== 1 ? 's' : ''} from JSON`);

                    // Save and load
                    localStorage.setItem('taskTree', json);
                    this.loadFromStorage();
                    this.updateStatusBar();
                    this.render();
                    this.hideImportModal();

                    this.showAlert('Success', 'Data imported successfully!');
                } catch (err) {
                    this.showAlert('Import Error', 'Invalid JSON data: ' + err.message);
                }
            },

            onCanvasMouseDown(e) {
                // Don't start drag if we're editing
                if (this.editingTaskId !== null) return;

                // Don't interfere with line clicks - let the click handler deal with them
                if (e.target.tagName === 'line' && e.target.classList.contains('link')) {
                    return; // Exit early, allow click event to fire
                }

                if (e.target.closest('.task-node')) {
                    const node = e.target.closest('.task-node');
                    const taskId = parseInt(node.dataset.id);

                    if (e.button === 0) { // Left click
                        if (e.ctrlKey || e.metaKey) {
                            // Start create-child drag (Ctrl+drag to empty space or reparent to node)
                            this.dragMode = 'create-child';
                            this.selectedNode = taskId;
                            this.dragChildSourceNode = taskId;
                            const pt = this.getSVGPoint(e);
                            this.dragStart = { x: pt.x, y: pt.y };
                            // Create custom cursor arrow
                            this.cursorArrow = this.createCursorArrow();
                        } else if (e.altKey) {
                            // Start dependency drag
                            this.dragMode = 'dependency';
                            this.selectedNode = taskId;
                            this.createTempLine(e);
                            // Create custom cursor arrow
                            this.cursorArrow = this.createCursorArrow();
                            // For dependency: reverse the line so it shows (cursor → source)
                            // This matches the final arrow direction: prerequisite → dependent
                            const task = this.tasks.find(t => t.id === taskId);
                            if (task && this.tempLine) {
                                const pt = this.getSVGPoint(e);
                                this.tempLine.setAttribute('x1', pt.x);
                                this.tempLine.setAttribute('y1', pt.y);
                                this.tempLine.setAttribute('x2', task.x);
                                this.tempLine.setAttribute('y2', task.y);
                            }
                        } else if (e.shiftKey) {
                            // Start subtree drag
                            this.dragMode = 'subtree';
                            this.selectedNode = taskId;

                            // Get all descendants
                            this.draggedSubtree = [taskId, ...this.getDescendants(taskId)];

                            // Store original positions
                            this.subtreeOriginalPositions = {};
                            this.draggedSubtree.forEach(id => {
                                const t = this.tasks.find(t => t.id === id);
                                this.subtreeOriginalPositions[id] = { x: t.x, y: t.y };
                            });

                            const task = this.tasks.find(t => t.id === taskId);
                            const pt = this.getSVGPoint(e);
                            this.dragStart = { x: pt.x - task.x, y: pt.y - task.y };
                            this.dragOriginalPos = { x: task.x, y: task.y };
                        } else {
                            // Start node drag
                            this.dragMode = 'node';
                            this.selectedNode = taskId;
                            const task = this.tasks.find(t => t.id === taskId);
                            const pt = this.getSVGPoint(e);
                            this.dragStart = { x: pt.x - task.x, y: pt.y - task.y };
                            this.dragOriginalPos = { x: task.x, y: task.y };
                        }
                    }
                    e.preventDefault();
                    e.stopPropagation();
                } else {
                    // Clicked on empty space
                    if (e.button === 0 && (e.ctrlKey || e.metaKey)) {
                        // Ctrl+Click on empty space: create new task at cursor
                        this.saveSnapshot(`Created task`);

                        const pt = this.getSVGPoint(e);
                        const newTask = {
                            id: this.taskIdCounter++,
                            title: '',
                            x: pt.x,
                            y: pt.y,
                            mainParent: null,
                            otherParents: [],
                            children: [],
                            dependencies: [],
                            status: 'pending',
                            currentlyWorking: false,
                            hidden: false,
                            textExpanded: false,
                            textLocked: false
                        };
                        this.tasks.push(newTask);
                        this.startEditing(newTask.id);
                        this.saveToStorage();
                        this.render();
                        e.preventDefault();
                    } else if (e.button === 0 && e.shiftKey) {
                        // Shift+Drag on empty space: prepare for box selection
                        const pt = this.getSVGPoint(e);
                        this.dragMode = 'box-select';
                        this.boxSelectStart = { x: pt.x, y: pt.y };
                        this.isBoxSelecting = true;
                        e.preventDefault();
                    } else {
                        // Pan canvas
                        this.dragMode = 'canvas';
                        const pt = this.getSVGPoint(e);
                        this.dragStart = { x: pt.x, y: pt.y };
                        this.dragStartOriginal = { x: pt.x, y: pt.y }; // Track original for click detection
                        document.getElementById('canvas-container').classList.add('dragging');
                        e.preventDefault();
                    }
                }
            },

            onCanvasMouseMove(e) {
                if (!this.dragMode) return;

                e.preventDefault();
                const pt = this.getSVGPoint(e);

                if (this.dragMode === 'box-select' && this.boxSelectStart) {
                    // Draw visual feedback for box selection
                    const minX = Math.min(this.boxSelectStart.x, pt.x);
                    const minY = Math.min(this.boxSelectStart.y, pt.y);
                    const maxX = Math.max(this.boxSelectStart.x, pt.x);
                    const maxY = Math.max(this.boxSelectStart.y, pt.y);

                    // Remove existing selection box
                    const existingBox = document.querySelector('#box-selection-rect');
                    if (existingBox) existingBox.remove();

                    // Create new selection box
                    const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                    rect.id = 'box-selection-rect';
                    rect.setAttribute('x', minX);
                    rect.setAttribute('y', minY);
                    rect.setAttribute('width', maxX - minX);
                    rect.setAttribute('height', maxY - minY);
                    rect.setAttribute('fill', 'rgba(33, 150, 243, 0.1)');
                    rect.setAttribute('stroke', '#2196f3');
                    rect.setAttribute('stroke-width', '2');
                    rect.setAttribute('stroke-dasharray', '5,5');
                    rect.setAttribute('pointer-events', 'none');
                    document.getElementById('canvas').appendChild(rect);

                    return;
                } else if (this.dragMode === 'node' && this.selectedNode !== null) {
                    const task = this.tasks.find(t => t.id === this.selectedNode);
                    if (task) {
                        const newX = pt.x - this.dragStart.x;
                        const newY = pt.y - this.dragStart.y;

                        // Check if we're dragging a selected node
                        if (this.selectedTaskIds.has(this.selectedNode)) {
                            // Move all selected nodes together, maintaining relative positions
                            const dx = newX - task.x;
                            const dy = newY - task.y;

                            this.selectedTaskIds.forEach(selectedId => {
                                const selectedTask = this.tasks.find(t => t.id === selectedId);
                                if (selectedTask) {
                                    selectedTask.x += dx;
                                    selectedTask.y += dy;
                                    selectedTask.vx = 0;
                                    selectedTask.vy = 0;
                                }
                            });
                        } else {
                            // Dragging an unselected node - move just this one
                            task.x = newX;
                            task.y = newY;
                            task.vx = 0;
                            task.vy = 0;
                        }
                        this.render();
                    }
                } else if (this.dragMode === 'subtree' && this.selectedNode !== null) {
                    // Calculate offset from original root position
                    const newX = pt.x - this.dragStart.x;
                    const newY = pt.y - this.dragStart.y;

                    const dx = newX - this.dragOriginalPos.x;
                    const dy = newY - this.dragOriginalPos.y;

                    // Move entire subtree by same offset
                    this.draggedSubtree.forEach(id => {
                        const task = this.tasks.find(t => t.id === id);
                        if (task) {
                            task.x = this.subtreeOriginalPositions[id].x + dx;
                            task.y = this.subtreeOriginalPositions[id].y + dy;
                            task.vx = 0;
                            task.vy = 0;
                        }
                    });

                    this.render();
                } else if (this.dragMode === 'create-child') {
                    // Use elementFromPoint to find what's actually under the cursor
                    // (e.target continues to be the source node during drag)
                    const elementUnderCursor = document.elementFromPoint(e.clientX, e.clientY);
                    const targetNode = elementUnderCursor ? elementUnderCursor.closest('.task-node') : null;

                    const svg = document.getElementById('canvas');
                    const linksGroup = document.getElementById('links');
                    const nodesGroup = document.getElementById('nodes');

                    // Get source task for positioning
                    const sourceTask = this.tasks.find(t => t.id === this.selectedNode);

                    // Update custom cursor arrow
                    if (sourceTask) {
                        this.updateCursorArrow(e.clientX, e.clientY, sourceTask);
                    }

                    // Check what we're hovering over
                    const isOverDifferentNode = targetNode && parseInt(targetNode.dataset.id) !== this.selectedNode;
                    const isOverSourceNode = targetNode && parseInt(targetNode.dataset.id) === this.selectedNode;

                    // ALWAYS show a line from source to cursor
                    if (!this.tempLine) {
                        this.tempLine = this.createLine(0, 0, 0, 0, 'link temp');
                        this.tempLine.setAttribute('stroke-width', '2');
                        linksGroup.appendChild(this.tempLine);
                    }

                    if (sourceTask) {
                        // BOTH cases: show source → cursor (drag direction matches final arrow direction)
                        this.tempLine.setAttribute('x1', sourceTask.x);
                        this.tempLine.setAttribute('y1', sourceTask.y);
                        this.tempLine.setAttribute('x2', pt.x);
                        this.tempLine.setAttribute('y2', pt.y);

                        // Change color based on mode
                        if (isOverDifferentNode) {
                            this.tempLine.setAttribute('stroke', '#4caf50'); // Green for reparent
                        } else {
                            this.tempLine.setAttribute('stroke', '#2196f3'); // Blue for new child
                        }
                    }

                    // Calculate preview box dimensions (needed for offset calculation)
                    const textPadding = 20;
                    const charWidth = 8;
                    const minWidth = 80;
                    const rectWidth = Math.max(minWidth, '+ New Task'.length * charWidth + textPadding * 2);
                    const rectHeight = 40;

                    // Calculate ellipse-based offset (smooth, rectangle-aware)
                    let offsetX = 40;
                    let offsetY = 40;

                    if (!isOverDifferentNode && !isOverSourceNode && sourceTask) {
                        const dx = pt.x - sourceTask.x;
                        const dy = pt.y - sourceTask.y;
                        const distance = Math.sqrt(dx * dx + dy * dy);

                        if (distance > 0) {
                            // Calculate angle from source to cursor
                            const angle = Math.atan2(dy, dx);

                            // Find point on ellipse with semi-axes = rect dimensions / 2
                            const ellipseX = (rectWidth / 2) * Math.cos(angle);
                            const ellipseY = (rectHeight / 2) * Math.sin(angle);

                            // Add padding beyond the ellipse edge
                            const extraPadding = 3;
                            offsetX = ellipseX + extraPadding * Math.cos(angle);
                            offsetY = ellipseY + extraPadding * Math.sin(angle);
                        }
                    }

                    if (isOverDifferentNode || isOverSourceNode) {
                        // Over any node (source or different) - remove preview node
                        const previewElement = document.querySelector('.preview-node');
                        if (previewElement) {
                            previewElement.remove();
                        }
                        this.previewNode = null;
                    } else {
                        // Over empty space - show blue line + preview node

                        // Remove existing preview node if exists
                        const previewElement = document.querySelector('.preview-node');
                        if (previewElement) {
                            previewElement.remove();
                        }

                        const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');
                        g.classList.add('preview-node');
                        g.style.pointerEvents = 'none'; // Don't interfere with hit detection

                        const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                        rect.setAttribute('x', pt.x + offsetX - rectWidth / 2);
                        rect.setAttribute('y', pt.y + offsetY - rectHeight / 2);
                        rect.setAttribute('width', rectWidth);
                        rect.setAttribute('height', rectHeight);
                        rect.setAttribute('rx', 8);
                        rect.setAttribute('ry', 8);
                        g.appendChild(rect);

                        const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                        text.setAttribute('x', pt.x + offsetX);
                        text.setAttribute('y', pt.y + offsetY + 5);
                        text.setAttribute('text-anchor', 'middle');
                        text.textContent = '+ New Task';
                        g.appendChild(text);

                        nodesGroup.appendChild(g);

                        this.previewNode = {
                            x: pt.x,
                            y: pt.y,
                            title: '+ New Task'
                        };
                    }
                } else if ((this.dragMode === 'dependency') && this.tempLine) {
                    // Get source task for cursor arrow rotation
                    const sourceTask = this.tasks.find(t => t.id === this.selectedNode);
                    if (sourceTask) {
                        this.updateCursorArrow(e.clientX, e.clientY, sourceTask);
                    }

                    // For dependency: update START point (cursor) not end point (source)
                    // This shows the reversed direction: cursor (prereq) → source (dependent)
                    this.tempLine.setAttribute('x1', pt.x);
                    this.tempLine.setAttribute('y1', pt.y);
                } else if (this.dragMode === 'canvas') {
                    const dx = pt.x - this.dragStart.x;
                    const dy = pt.y - this.dragStart.y;
                    this.tasks.forEach(task => {
                        task.x += dx;
                        task.y += dy;
                    });
                    this.dragStart = { x: pt.x, y: pt.y };
                    this.render();
                }
            },

            onCanvasMouseUp(e) {
                if (this.dragMode === 'create-child') {
                    // Use elementFromPoint to find what's actually under the cursor
                    const elementUnderCursor = document.elementFromPoint(e.clientX, e.clientY);
                    const targetNode = elementUnderCursor ? elementUnderCursor.closest('.task-node') : null;
                    const pt = this.getSVGPoint(e);

                    if (targetNode) {
                        // Dropped on a node - make target a child of source (drag direction = arrow direction)
                        const targetId = parseInt(targetNode.dataset.id);

                        // Check if dropping ON a selected node (multi-target reparenting)
                        if (this.selectedTaskIds.has(targetId)) {
                            // Dropping ON a selected node: make source the parent of ALL selected
                            this.selectedTaskIds.forEach(taskId => {
                                if (taskId !== this.selectedNode) {
                                    this.reparentTask({ taskId: taskId, newParentId: this.selectedNode });
                                }
                            });
                        } else {
                            // Normal case: make target a child of source
                            if (targetId !== this.selectedNode) {
                                this.reparentTask({ taskId: targetId, newParentId: this.selectedNode });
                            }
                        }
                    } else {
                        // Dropped on empty space - create new child at that position
                        this.createChildAtPosition({ parentId: this.selectedNode, x: pt.x, y: pt.y });
                    }

                    this.removeTempLine();
                    this.previewNode = null;
                    this.render();
                } else if (this.dragMode === 'dependency') {
                    // Use elementFromPoint to find what's actually under cursor (not e.target)
                    const elementUnderCursor = document.elementFromPoint(e.clientX, e.clientY);
                    const targetNode = elementUnderCursor ? elementUnderCursor.closest('.task-node') : null;
                    if (targetNode && this.tempLine) {
                        const targetId = parseInt(targetNode.dataset.id);

                        // Check if dragging FROM a selected node (multi-source mode)
                        if (this.selectedTaskIds.has(this.selectedNode)) {
                            // Source is selected (with others): all selected → target
                            // target depends on each selected node
                            this.selectedTaskIds.forEach(sourceId => {
                                if (sourceId !== targetId) {
                                    this.addDependency({ dependentId: targetId, prerequisiteId: sourceId });
                                }
                            });
                        } else if (this.selectedTaskIds.has(targetId)) {
                            // Target is selected (with others): source → all selected
                            // each selected depends on source
                            this.selectedTaskIds.forEach(depId => {
                                if (depId !== this.selectedNode) {
                                    this.addDependency({ dependentId: depId, prerequisiteId: this.selectedNode });
                                }
                            });
                        } else {
                            // Single source/target mode: source → target
                            if (targetId !== this.selectedNode) {
                                this.addDependency({ dependentId: targetId, prerequisiteId: this.selectedNode });
                            }
                        }
                    }
                    this.removeTempLine();
                } else if (this.dragMode === 'subtree' && this.selectedNode !== null) {
                    const task = this.tasks.find(t => t.id === this.selectedNode);
                    if (task) {
                        const movedDistance = Math.sqrt(
                            Math.pow(task.x - this.dragOriginalPos.x, 2) +
                            Math.pow(task.y - this.dragOriginalPos.y, 2)
                        );

                        // Save if we actually moved
                        if (movedDistance >= 5) {
                            const truncatedTitle = task.title.length > 30 ? task.title.substring(0, 27) + '...' : task.title;
                            this.saveSnapshot(`Moved subtree '${truncatedTitle}'`);
                            this.saveToStorage();
                        }
                    }

                    // Clean up subtree drag state
                    this.draggedSubtree = [];
                    this.subtreeOriginalPositions = {};
                } else if (this.dragMode === 'node' && this.selectedNode !== null) {
                    const task = this.tasks.find(t => t.id === this.selectedNode);
                    if (task) {
                        const movedDistance = Math.sqrt(
                            Math.pow(task.x - this.dragOriginalPos.x, 2) +
                            Math.pow(task.y - this.dragOriginalPos.y, 2)
                        );

                        // Save if we actually moved
                        if (movedDistance >= 5) {
                            if (this.selectedTaskIds.size > 1) {
                                this.saveSnapshot(`Moved ${this.selectedTaskIds.size} tasks`);
                            } else {
                                const truncatedTitle = task.title.length > 30 ? task.title.substring(0, 27) + '...' : task.title;
                                this.saveSnapshot(`Moved task '${truncatedTitle}'`);
                            }
                            this.saveToStorage();
                        }
                    }
                } else if (this.dragMode === 'canvas') {
                    // Don't create undo snapshot for canvas panning - it's a viewport navigation
                    // action, not a content modification. Creating a snapshot would clear the
                    // redo stack, preventing users from redoing after panning to look around.
                    // Use debounced save to prevent performance issues from frequent localStorage writes
                    this.debouncedSaveToStorage(500);
                } else if (this.dragMode === 'box-select' && this.boxSelectStart) {
                    // Complete box selection
                    const pt = this.getSVGPoint(e);
                    const minX = Math.min(this.boxSelectStart.x, pt.x);
                    const minY = Math.min(this.boxSelectStart.y, pt.y);
                    const maxX = Math.max(this.boxSelectStart.x, pt.x);
                    const maxY = Math.max(this.boxSelectStart.y, pt.y);

                    // Find all nodes whose centers fall within the box
                    const selectedInBox = this.tasks.filter(task => {
                        return !task.hidden && task.x >= minX && task.x <= maxX && task.y >= minY && task.y <= maxY;
                    });

                    // Add to selection (additive - Shift+drag means add to existing selection)
                    selectedInBox.forEach(task => {
                        this.selectedTaskIds.add(task.id);
                    });

                    // Remove the selection box visual
                    const boxElement = document.querySelector('#box-selection-rect');
                    if (boxElement) boxElement.remove();

                    // Render to show highlights on selected nodes
                    this.render();
                }

                // Clear selection when clicking canvas (not when panning)
                const wasCanvasDrag = this.dragMode === 'canvas';

                // Remove custom cursor arrow if it exists
                this.removeCursorArrow();

                this.dragMode = null;
                this.selectedNode = null;
                this.isBoxSelecting = false;
                this.boxSelectStart = null;

                if (wasCanvasDrag) {
                    // Only clear selection if we didn't actually pan (click without movement)
                    const pt = this.getSVGPoint(e);
                    const panDistance = Math.sqrt(
                        Math.pow(pt.x - this.dragStartOriginal.x, 2) +
                        Math.pow(pt.y - this.dragStartOriginal.y, 2)
                    );

                    // If pan distance < 5px, treat as a click on canvas and clear selection
                    if (panDistance < 5) {
                        this.selectedTaskIds.clear();
                        this.selectedLine = null;
                        this.render();
                    }
                }
                document.getElementById('canvas-container').classList.remove('dragging');
            },

            reparentTask({ taskId, newParentId }) {
                const task = this.tasks.find(t => t.id === taskId);
                const newParent = this.tasks.find(t => t.id === newParentId);

                if (!task || !newParent) return;

                // Can't reparent to self or to own descendant
                if (taskId === newParentId || this.getDescendants(taskId).includes(newParentId)) {
                    this.showAlert('Cannot Reparent', 'Cannot reparent to self or descendant!');
                    return;
                }

                // Handle working task log if task is currently working
                if (task.currentlyWorking) {
                    const oldRoot = this.getRootTask(taskId);

                    // Will get new root after reparenting below, so we just remove from old root now
                    if (oldRoot) {
                        delete this.workingTasksByRoot[oldRoot.id];
                    }
                }

                // Remove from old parent's children
                if (task.mainParent !== null) {
                    const oldParent = this.tasks.find(t => t.id === task.mainParent);
                    if (oldParent) {
                        oldParent.children = oldParent.children.filter(id => id !== taskId);
                    }
                }

                // Set new parent
                task.mainParent = newParentId;
                newParent.children.push(taskId);

                // Update working log if task is still working (after reparenting)
                if (task.currentlyWorking) {
                    const newRoot = this.getRootTask(taskId);
                    if (newRoot) {
                        this.workingTasksByRoot[newRoot.id] = taskId;
                    }
                }

                // Clean up redundant dependencies
                // Remove newParent from task's dependencies (task depending on its parent is redundant)
                task.dependencies = task.dependencies.filter(id => id !== newParentId);

                // Remove task from newParent's dependencies (parent depending on child would be circular)
                newParent.dependencies = newParent.dependencies.filter(id => id !== taskId);

                this.saveToStorage();
                this.updateStatusBar();
                this.render();
            },

            createTempLine(e) {
                const task = this.tasks.find(t => t.id === this.selectedNode);
                const svg = document.getElementById('canvas');
                this.tempLine = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                this.tempLine.classList.add('temp-line');
                
                // Style based on drag mode
                if (this.dragMode === 'reparent') {
                    // Solid green line for reparenting
                    this.tempLine.style.strokeDasharray = 'none';
                    this.tempLine.style.stroke = '#28a745';
                } else {
                    // Dashed blue line for dependency
                    this.tempLine.style.strokeDasharray = '5,5';
                    this.tempLine.style.stroke = '#007bff';
                }
                
                this.tempLine.setAttribute('x1', task.x);
                this.tempLine.setAttribute('y1', task.y);
                this.tempLine.setAttribute('x2', task.x);
                this.tempLine.setAttribute('y2', task.y);
                svg.appendChild(this.tempLine);
            },

            removeTempLine() {
                if (this.tempLine) {
                    this.tempLine.remove();
                    this.tempLine = null;
                }
            },

            addDependency({ dependentId, prerequisiteId }) {
                const dependent = this.tasks.find(t => t.id === dependentId);
                if (!dependent) return;

                // Check if dependency already exists (toggle behavior)
                const existingIndex = dependent.dependencies.indexOf(prerequisiteId);
                if (existingIndex !== -1) {
                    // Dependency exists, remove it
                    const prerequisite = this.tasks.find(t => t.id === prerequisiteId);
                    const depTitle = dependent.title.length > 20 ? dependent.title.substring(0, 17) + '...' : dependent.title;
                    const preTitle = prerequisite.title.length > 20 ? prerequisite.title.substring(0, 17) + '...' : prerequisite.title;
                    this.saveSnapshot(`Removed dependency: '${depTitle}' no longer depends on '${preTitle}'`);
                    dependent.dependencies.splice(existingIndex, 1);
                    this.saveToStorage();
                    this.render();
                    return;
                }

                // Prevent circular dependencies
                if (this.wouldCreateCycle(dependentId, prerequisiteId)) {
                    this.showAlert('Cannot Create Dependency', 'Cannot create circular dependency!');
                    return;
                }

                // Add new dependency
                const prerequisite = this.tasks.find(t => t.id === prerequisiteId);
                const depTitle = dependent.title.length > 20 ? dependent.title.substring(0, 17) + '...' : dependent.title;
                const preTitle = prerequisite.title.length > 20 ? prerequisite.title.substring(0, 17) + '...' : prerequisite.title;
                this.saveSnapshot(`Added dependency: '${depTitle}' depends on '${preTitle}'`);
                dependent.dependencies.push(prerequisiteId);
                this.saveToStorage();
                this.render();
            },

            removeDependency(fromId, toId) {
                const from = this.tasks.find(t => t.id === fromId);
                if (from) {
                    const to = this.tasks.find(t => t.id === toId);
                    const fromTitle = from.title.length > 20 ? from.title.substring(0, 17) + '...' : from.title;
                    const toTitle = to.title.length > 20 ? to.title.substring(0, 17) + '...' : to.title;
                    this.saveSnapshot(`Removed dependency: '${fromTitle}' no longer depends on '${toTitle}'`);
                    from.dependencies = from.dependencies.filter(id => id !== toId);
                    this.saveToStorage();
                    this.render();
                }
            },

            deleteLine(lineData) {
                if (lineData.type === 'parent') {
                    // Remove parent-child relationship
                    const task = this.tasks.find(t => t.id === lineData.taskId);
                    if (task) {
                        if (task.mainParent === lineData.parentId) {
                            // Remove main parent - child becomes root
                            task.mainParent = null;
                        }
                        // Also try to remove from otherParents
                        task.otherParents = task.otherParents.filter(id => id !== lineData.parentId);

                        // Remove from parent's children list
                        const parent = this.tasks.find(t => t.id === lineData.parentId);
                        if (parent) {
                            parent.children = parent.children.filter(id => id !== lineData.taskId);
                        }

                        this.saveToStorage();
                        this.selectedLine = null;
                        this.render();
                    }
                } else if (lineData.type === 'dependency') {
                    // Remove dependency
                    this.removeDependency(lineData.from, lineData.to);
                    this.selectedLine = null;
                }
            },

            wouldCreateCycle(fromId, toId) {
                // Check if adding dependency from->to would create a cycle
                const visited = new Set();
                const queue = [toId];
                
                while (queue.length > 0) {
                    const current = queue.shift();
                    if (current === fromId) return true;
                    if (visited.has(current)) continue;
                    
                    visited.add(current);
                    const task = this.tasks.find(t => t.id === current);
                    if (task) {
                        queue.push(...task.dependencies);
                    }
                }
                
                return false;
            },

            showNodeMenu(e, taskId) {
                this.closeMenu();

                const task = this.tasks.find(t => t.id === taskId);
                if (!task) {
                    console.error('Task not found:', taskId);
                    return;
                }

                // If right-clicking on a task that's not in selection, select just it
                // If it's in the selection, operate on the entire selection
                const isInSelection = this.selectedTaskIds.has(taskId);
                const isMultiSelect = this.selectedTaskIds.size > 1;

                if (!isInSelection) {
                    this.selectedTaskIds.clear();
                    this.selectedTaskIds.add(taskId);
                }

                const menu = document.createElement('div');
                menu.className = 'node-menu';
                menu.style.left = e.pageX + 'px';
                menu.style.top = e.pageY + 'px';

                // Show dependencies if any
                if (task.dependencies.length > 0) {
                    const depSection = document.createElement('div');
                    depSection.className = 'dependency-section';
                    
                    const header = document.createElement('h4');
                    header.textContent = 'Dependencies';
                    depSection.appendChild(header);
                    
                    task.dependencies.forEach(depId => {
                        const depTask = this.tasks.find(t => t.id === depId);
                        if (depTask) {
                            const depItem = document.createElement('div');
                            depItem.className = 'dependency-item';
                            
                            const span = document.createElement('span');
                            span.textContent = `→ ${depTask.title}`;
                            
                            const removeBtn = document.createElement('button');
                            removeBtn.className = 'remove-btn';
                            removeBtn.textContent = 'X';
                            removeBtn.onclick = (evt) => {
                                evt.stopPropagation();
                                this.removeDependency(taskId, depId);
                                this.closeMenu();
                            };
                            
                            depItem.appendChild(span);
                            depItem.appendChild(removeBtn);
                            depSection.appendChild(depItem);
                        }
                    });
                    
                    menu.appendChild(depSection);
                }

                const hasHiddenChildren = this.getHiddenChildrenCount(taskId) > 0;
                const hideButtonLabel = task.children.length > 0
                    ? (hasHiddenChildren ? 'Show Children' : 'Hide Children')
                    : null;

                const buttons = [];

                // Multi-select specific options
                if (isMultiSelect) {
                    buttons.push({
                        label: `✅ Mark Done (${this.selectedTaskIds.size})`,
                        action: () => {
                            const selectedArray = Array.from(this.selectedTaskIds);
                            selectedArray.forEach(id => this.toggleDone(id));
                        }
                    });
                    buttons.push({
                        label: `⏸️ Mark Pending (${this.selectedTaskIds.size})`,
                        action: () => {
                            const selectedArray = Array.from(this.selectedTaskIds);
                            selectedArray.forEach(id => {
                                const t = this.tasks.find(t => t.id === id);
                                if (t && t.status !== 'pending') this.toggleDone(id);
                            });
                        }
                    });
                    buttons.push({
                        label: `🙈 Hide Child (${this.selectedTaskIds.size})`,
                        action: () => {
                            const selectedArray = Array.from(this.selectedTaskIds);
                            selectedArray.forEach(id => this.toggleHiddenSelf(id));
                        }
                    });
                    buttons.push({
                        label: `🗑️ Delete (${this.selectedTaskIds.size})`,
                        action: () => {
                            const selectedArray = Array.from(this.selectedTaskIds);
                            this.deleteMultipleTasks(selectedArray);
                        }
                    });
                } else {
                    // Single select options
                    buttons.push({ label: '➕ Add Child', action: () => this.addChildTask(taskId) });
                    buttons.push({ label: task.status === 'done' ? '⏸️ Mark Pending' : '✅ Mark Done', action: () => this.toggleDone(taskId) });
                    buttons.push({ label: task.currentlyWorking ? '⏹️ Stop Working' : '▶️ Start Working', action: () => this.toggleWorking(taskId) });

                    // Add hide option if task has a parent (not a root task)
                    if (task.mainParent !== null) {
                        buttons.push({ label: task.hidden ? '👁️ Show' : '🙈 Hide', action: () => this.toggleHiddenSelf(taskId) });
                    }

                    // Only add hide/show children button if task has children
                    if (hideButtonLabel) {
                        const hideEmoji = hideButtonLabel.includes('Show') ? '📂' : '📦';
                        buttons.push({ label: `${hideEmoji} ${hideButtonLabel}`, action: () => this.toggleHidden(taskId) });
                    }

                    buttons.push({ label: '📋 Copy Text', action: () => this.copyTaskText(task.title) });
                    buttons.push({ label: '🗑️ Delete', action: () => this.deleteTask(taskId) });
                }

                buttons.forEach(({ label, action }) => {
                    const btn = document.createElement('button');
                    btn.textContent = label;
                    btn.onclick = (evt) => {
                        evt.stopPropagation();
                        this.closeMenu();
                        action();
                    };
                    menu.appendChild(btn);
                });

                document.body.appendChild(menu);
            },

            showEmptySpaceMenu(e) {
                this.closeMenu();

                const menu = document.createElement('div');
                menu.className = 'node-menu';
                menu.style.left = e.pageX + 'px';
                menu.style.top = e.pageY + 'px';

                const buttons = [
                    {
                        label: '➕ Create New Task',
                        action: () => {
                            this.saveSnapshot(`Created task`);

                            const pt = this.getSVGPoint(e);
                            const newTask = {
                                id: this.taskIdCounter++,
                                title: '',
                                x: pt.x,
                                y: pt.y,
                                mainParent: null,
                                otherParents: [],
                                children: [],
                                dependencies: [],
                                status: 'pending',
                                currentlyWorking: false,
                                hidden: false,
                                textExpanded: false,
                                textLocked: false
                            };
                            this.tasks.push(newTask);
                            this.startEditing(newTask.id);
                            this.saveToStorage();
                            this.render();
                        }
                    },
                    { label: '🔍 Zoom to Fit', action: () => this.zoomToFit() },
                    { label: '🎯 Mark Origin', action: () => this.markOrigin() }
                ];

                buttons.forEach(({ label, action }) => {
                    const btn = document.createElement('button');
                    btn.textContent = label;
                    btn.onclick = (evt) => {
                        evt.stopPropagation();
                        this.closeMenu();
                        action();
                    };
                    menu.appendChild(btn);
                });

                // Add Homes submenu
                const homesBtn = document.createElement('button');
                homesBtn.className = 'menu-item-with-submenu';
                homesBtn.textContent = '🏠 Homes';

                const submenu = document.createElement('div');
                submenu.className = 'submenu';

                if (this.homes.length === 0) {
                    submenu.innerHTML = '<div class="submenu-empty">No homes yet</div>';
                } else {
                    // Sort homes: "Origin Home" first, then alphabetically
                    const sortedHomes = [...this.homes].sort((a, b) => {
                        if (a.name === "Origin Home") return -1;
                        if (b.name === "Origin Home") return 1;
                        return a.name.localeCompare(b.name);
                    });

                    sortedHomes.forEach(home => {
                        const item = document.createElement('div');
                        item.className = 'submenu-item menu-item-with-submenu';
                        if (home.name === "Origin Home") {
                            item.classList.add('special');
                        }

                        // Display home name with keybind if it exists
                        const nameText = home.keybind ? `${home.name} [${home.keybind}]` : home.name;

                        // Don't use textContent - it can interfere with appendChild
                        // Instead, create a span for the text
                        const textSpan = document.createElement('span');
                        textSpan.textContent = nameText;
                        item.appendChild(textSpan);

                        // Click on home name navigates to that home
                        item.onclick = (evt) => {
                            // Only navigate if clicking the item itself, not the nested submenu
                            if (evt.target === item || evt.target === textSpan) {
                                evt.stopPropagation();
                                this.closeMenu();
                                this.jumpToHome(home.id);
                            }
                        };

                        // Create nested submenu for each home (uses fixed positioning)
                        const homeSubmenu = document.createElement('div');
                        homeSubmenu.className = 'submenu-nested';
                        homeSubmenu.style.display = 'none'; // Start hidden

                        // Show/hide nested submenu with JavaScript (CSS hover unreliable with fixed positioning)
                        let hideTimeout = null;

                        item.addEventListener('mouseenter', () => {
                            if (hideTimeout) {
                                clearTimeout(hideTimeout);
                                hideTimeout = null;
                            }
                            const rect = item.getBoundingClientRect();
                            homeSubmenu.style.left = `${rect.right}px`;
                            homeSubmenu.style.top = `${rect.top}px`;
                            homeSubmenu.style.display = 'block';

                            // Keep parent submenu visible while nested submenu is open
                            submenu.style.display = 'block';
                        });

                        item.addEventListener('mouseleave', (evt) => {
                            // Don't hide if mouse moved to the submenu
                            hideTimeout = setTimeout(() => {
                                const hoveredElement = document.elementFromPoint(evt.clientX, evt.clientY);
                                if (!homeSubmenu.contains(hoveredElement)) {
                                    homeSubmenu.style.display = 'none';
                                    // Allow parent submenu to use CSS hover again
                                    submenu.style.display = '';
                                }
                            }, 100);
                        });

                        // Keep both submenus visible when hovering nested submenu
                        homeSubmenu.addEventListener('mouseenter', () => {
                            if (hideTimeout) {
                                clearTimeout(hideTimeout);
                                hideTimeout = null;
                            }
                            // Force parent submenu to stay visible
                            submenu.style.display = 'block';
                        });

                        homeSubmenu.addEventListener('mouseleave', () => {
                            homeSubmenu.style.display = 'none';
                            // Allow parent submenu to use CSS hover again
                            submenu.style.display = '';
                        });

                        // Jump to Home option
                        const jumpOption = document.createElement('div');
                        jumpOption.className = 'submenu-item';
                        jumpOption.textContent = '🚀 Jump to Home';
                        jumpOption.onclick = (evt) => {
                            evt.stopPropagation();
                            this.closeMenu();
                            this.jumpToHome(home.id);
                        };
                        homeSubmenu.appendChild(jumpOption);

                        // Update Home Position option
                        const updateOption = document.createElement('div');
                        updateOption.className = 'submenu-item';
                        updateOption.textContent = '📍 Update Home Position';
                        updateOption.onclick = (evt) => {
                            evt.stopPropagation();
                            this.closeMenu();
                            this.updateHome(home.id);
                        };
                        homeSubmenu.appendChild(updateOption);

                        // Append nested submenu to body (not to item) since it uses fixed positioning
                        // This avoids parent overflow issues
                        document.body.appendChild(homeSubmenu);

                        submenu.appendChild(item);
                    });

                    // Add divider
                    const divider = document.createElement('div');
                    divider.className = 'submenu-divider';
                    submenu.appendChild(divider);
                }

                // Add "Create New Home" option
                const createItem = document.createElement('div');
                createItem.className = 'submenu-item special';
                createItem.textContent = '➕ Create New Home';
                createItem.onclick = (evt) => {
                    evt.stopPropagation();
                    this.closeMenu();
                    this.showCreateHomeModal();
                };
                submenu.appendChild(createItem);

                // Add "Manage Homes" option
                const manageItem = document.createElement('div');
                manageItem.className = 'submenu-item';
                manageItem.textContent = '⚙️ Manage Homes';
                manageItem.onclick = (evt) => {
                    evt.stopPropagation();
                    this.closeMenu();
                    this.showManageHomesModal();
                };
                submenu.appendChild(manageItem);

                homesBtn.appendChild(submenu);
                menu.appendChild(homesBtn);

                document.body.appendChild(menu);
            },

            closeMenu() {
                const menu = document.querySelector('.node-menu');
                if (menu) menu.remove();

                // Also remove any nested submenus that were appended to body
                const nestedMenus = document.querySelectorAll('.submenu-nested');
                nestedMenus.forEach(m => m.remove());
            },

            copyTaskText(text) {
                navigator.clipboard.writeText(text).then(() => {
                    // Show toast notification (auto-dismisses after 4 seconds)
                    this.showToast(`✓ Copied: "${text}"`, 'success', 4000);
                }).catch(err => {
                    // Show error toast
                    this.showToast('Failed to copy to clipboard', 'error', 4000);
                });
            },

            getSVGPoint(e) {
                const svg = document.getElementById('canvas');
                const pt = svg.createSVGPoint();

                // Use raw screen coordinates - getScreenCTM handles all transformations
                pt.x = e.clientX;
                pt.y = e.clientY;

                // Transform from screen space to SVG user space
                const screenCTM = svg.getScreenCTM();
                if (screenCTM) {
                    return pt.matrixTransform(screenCTM.inverse());
                }
                return pt;
            },

            getWorkingTaskPath() {
                // Returns ancestor and descendant paths for the currently working task
                // Used for golden path visualization
                const workingTask = this.tasks.find(t => t.currentlyWorking);
                if (!workingTask) {
                    return { workingTaskId: null, ancestorPath: new Set(), directChildren: [] };
                }

                // Build full ancestor path (working task → root)
                // This includes the working task itself AND all ancestors
                const ancestorPath = new Set();
                ancestorPath.add(workingTask.id);  // Include working task itself
                let current = workingTask.mainParent;
                while (current !== null) {
                    ancestorPath.add(current);
                    const parent = this.tasks.find(t => t.id === current);
                    current = parent ? parent.mainParent : null;
                }

                // Get direct children with their completion status
                const directChildren = workingTask.children.map(childId => {
                    const child = this.tasks.find(t => t.id === childId);
                    return {
                        id: childId,
                        isDone: child ? child.status === 'done' : false
                    };
                });

                return {
                    workingTaskId: workingTask.id,
                    ancestorPath,
                    directChildren
                };
            },

            render() {
                const svg = document.getElementById('canvas');
                const linksGroup = document.getElementById('links');
                const nodesGroup = document.getElementById('nodes');

                linksGroup.innerHTML = '';
                nodesGroup.innerHTML = '';

                // Apply zoom via viewBox
                const viewBoxWidth = this.viewBox.width / this.zoomLevel;
                const viewBoxHeight = this.viewBox.height / this.zoomLevel;
                svg.setAttribute('viewBox',
                    `${this.viewBox.x - (viewBoxWidth - this.viewBox.width) / 2} ` +
                    `${this.viewBox.y - (viewBoxHeight - this.viewBox.height) / 2} ` +
                    `${viewBoxWidth} ${viewBoxHeight}`
                );

                // Find ALL working tasks (one per root graph) using the log for O(1) lookup
                const workingTasks = [];
                Object.values(this.workingTasksByRoot).forEach(taskId => {
                    const task = this.tasks.find(t => t.id === taskId);
                    if (task) {
                        workingTasks.push(task);
                    }
                });
                const workingTask = workingTasks[0]; // For status bar display, use first working task

                // Build combined lists for all working tasks
                const workingAncestors = [];
                const incompleteChildren = [];

                workingTasks.forEach(wt => {
                    // Add ancestors of this working task
                    const ancestors = this.getAncestors(wt.id);
                    ancestors.forEach(id => {
                        if (!workingAncestors.includes(id)) {
                            workingAncestors.push(id);
                        }
                    });

                    // Add incomplete children of this working task
                    wt.children.forEach(childId => {
                        const child = this.tasks.find(t => t.id === childId);
                        if (child && child.status !== 'done' && !incompleteChildren.includes(childId)) {
                            incompleteChildren.push(childId);
                        }
                    });
                });

                // Get golden paths for ALL working tasks (multi-project support)
                const allAncestorPaths = new Set();
                const allDirectChildren = [];
                const workingTaskIds = new Set();

                workingTasks.forEach(wt => {
                    workingTaskIds.add(wt.id);

                    // Build ancestor path for this working task
                    allAncestorPaths.add(wt.id);  // Include working task itself
                    let current = wt.mainParent;
                    while (current !== null) {
                        allAncestorPaths.add(current);
                        const parent = this.tasks.find(t => t.id === current);
                        current = parent ? parent.mainParent : null;
                    }

                    // Collect direct children with completion status
                    wt.children.forEach(childId => {
                        const child = this.tasks.find(t => t.id === childId);
                        allDirectChildren.push({
                            id: childId,
                            isDone: child ? child.status === 'done' : false,
                            parentWorkingId: wt.id
                        });
                    });
                });

                const goldenPath = {
                    workingTaskIds,
                    ancestorPath: allAncestorPaths,
                    directChildren: allDirectChildren
                };

                // Render links
                this.tasks.forEach(task => {
                    if (task.hidden) return;

                    // Main parent link with hit detection
                    if (task.mainParent !== null) {
                        const parent = this.tasks.find(t => t.id === task.mainParent);
                        if (parent && !parent.hidden) {
                            // Create wider invisible line for easier clicking
                            const hitLine = this.createLine(parent.x, parent.y, task.x, task.y, 'link parent-hit');
                            hitLine.dataset.type = 'parent';
                            hitLine.dataset.taskId = task.id;
                            hitLine.dataset.parentId = task.mainParent;
                            hitLine.style.pointerEvents = 'stroke';
                            hitLine.style.cursor = 'pointer';
                            if (this.selectedLine && this.selectedLine.type === 'parent' &&
                                this.selectedLine.taskId === task.id && this.selectedLine.parentId === task.mainParent) {
                                hitLine.classList.add('selected');
                            }
                            linksGroup.appendChild(hitLine);

                            // Create visible line (non-interactive) with arrow at edge
                            // Calculate arrow endpoint at rectangle edge for pixel-perfect positioning
                            // Use dynamic dimensions to account for multiline nodes
                            const { rectWidth, rectHeight } = this.calculateTaskDimensions(task);
                            const arrowEnd = this.getLineEndAtRectEdge(parent.x, parent.y, task.x, task.y, rectWidth, rectHeight);

                            const line = this.createLine(parent.x, parent.y, arrowEnd.x, arrowEnd.y, 'link parent-visible');
                            line.style.pointerEvents = 'none';
                            // ⭐ NEW: Add data attributes so we can update during animation
                            line.dataset.type = 'parent';
                            line.dataset.taskId = task.id;
                            line.dataset.parentId = task.mainParent;

                            // Check if this link is part of the golden ancestor path
                            // Link should be golden if task is on the path (working task or any ancestor)
                            const isAncestorPath =
                                goldenPath.ancestorPath.has(task.id) &&
                                goldenPath.ancestorPath.has(task.mainParent);

                            // Check if this is a link to a direct child of ANY working task
                            const childInfo = goldenPath.directChildren.find(c => c.id === task.id);
                            const isDirectChild = childInfo && goldenPath.workingTaskIds.has(task.mainParent);

                            // Apply path styling
                            if (isAncestorPath) {
                                line.classList.add('golden-path-ancestor');
                                line.setAttribute('marker-end', 'url(#arrowhead-golden)');
                                line.style.stroke = '#f59e0b';  // Golden amber
                                line.style.strokeWidth = '3';
                                line.style.filter = 'drop-shadow(0 0 4px rgba(245, 158, 11, 0.6))';
                            } else if (isDirectChild) {
                                // Color based on completion status
                                if (childInfo.isDone) {
                                    line.classList.add('golden-path-child-done');
                                    line.setAttribute('marker-end', 'url(#arrowhead-green)');
                                    line.style.stroke = '#4caf50';  // Green (same as done tasks)
                                    line.style.strokeWidth = '2.5';
                                } else {
                                    line.classList.add('golden-path-child-incomplete');
                                    line.setAttribute('marker-end', 'url(#arrowhead-red)');
                                    line.style.stroke = '#f44336';  // Red (same as incomplete children indicator)
                                    line.style.strokeWidth = '2.5';
                                }
                            } else {
                                line.setAttribute('marker-end', 'url(#arrowhead)'); // Normal arrow
                            }

                            if (this.selectedLine && this.selectedLine.type === 'parent' &&
                                this.selectedLine.taskId === task.id && this.selectedLine.parentId === task.mainParent) {
                                line.classList.add('selected');
                            }
                            linksGroup.appendChild(line);
                        }
                    }

                    // Other parent links with hit detection
                    task.otherParents.forEach(parentId => {
                        const parent = this.tasks.find(t => t.id === parentId);
                        if (parent && !parent.hidden) {
                            // Create wider invisible line for easier clicking
                            const hitLine = this.createLine(parent.x, parent.y, task.x, task.y, 'link other-parent-hit');
                            hitLine.dataset.type = 'parent';
                            hitLine.dataset.taskId = task.id;
                            hitLine.dataset.parentId = parentId;
                            hitLine.style.pointerEvents = 'stroke';
                            hitLine.style.cursor = 'pointer';
                            if (this.selectedLine && this.selectedLine.type === 'parent' &&
                                this.selectedLine.taskId === task.id && this.selectedLine.parentId === parentId) {
                                hitLine.classList.add('selected');
                            }
                            linksGroup.appendChild(hitLine);

                            // Create visible line (non-interactive) with arrow at edge
                            // Calculate arrow endpoint at rectangle edge for pixel-perfect positioning
                            // Use dynamic dimensions to account for multiline nodes
                            const { rectWidth, rectHeight } = this.calculateTaskDimensions(task);
                            const arrowEnd = this.getLineEndAtRectEdge(parent.x, parent.y, task.x, task.y, rectWidth, rectHeight);

                            const line = this.createLine(parent.x, parent.y, arrowEnd.x, arrowEnd.y, 'link other-parent');
                            line.setAttribute('marker-end', 'url(#arrowhead)'); // Arrow pointing to child
                            line.style.pointerEvents = 'none';
                            // ⭐ NEW: Add data attributes so we can update during animation
                            line.dataset.type = 'parent';
                            line.dataset.taskId = task.id;
                            line.dataset.parentId = parentId;
                            if (this.selectedLine && this.selectedLine.type === 'parent' &&
                                this.selectedLine.taskId === task.id && this.selectedLine.parentId === parentId) {
                                line.classList.add('selected');
                            }
                            linksGroup.appendChild(line);
                        }
                    });

                    // Dependency links with better hit detection
                    task.dependencies.forEach(depId => {
                        const dep = this.tasks.find(t => t.id === depId);
                        if (dep && !dep.hidden) {
                            // Create wider invisible line for easier clicking
                            const hitLine = this.createLine(dep.x, dep.y, task.x, task.y, 'link dependency-hit');
                            hitLine.dataset.type = 'dependency';
                            hitLine.dataset.from = task.id;
                            hitLine.dataset.to = depId;
                            hitLine.style.pointerEvents = 'stroke';
                            // Check if selected
                            if (this.selectedLine && this.selectedLine.type === 'dependency' &&
                                this.selectedLine.from === task.id && this.selectedLine.to === depId) {
                                hitLine.classList.add('selected');
                            }
                            linksGroup.appendChild(hitLine);

                            // Create visible line (non-interactive) with arrow at edge
                            // Calculate arrow endpoint at rectangle edge for pixel-perfect positioning
                            // Use dynamic dimensions to account for multiline nodes
                            const { rectWidth, rectHeight } = this.calculateTaskDimensions(task);
                            const arrowEnd = this.getLineEndAtRectEdge(dep.x, dep.y, task.x, task.y, rectWidth, rectHeight);

                            const line = this.createLine(dep.x, dep.y, arrowEnd.x, arrowEnd.y, 'link dependency');
                            line.setAttribute('marker-end', 'url(#arrowhead)');
                            // Make visible line NOT clickable - all interaction through hitLine
                            line.style.pointerEvents = 'none';
                            // ⭐ NEW: Add data attributes (using visual direction: dep → task)
                            line.dataset.type = 'dependency';
                            line.dataset.from = depId;  // Source (prerequisite)
                            line.dataset.to = task.id;  // Target (dependent)
                            // Check if selected
                            if (this.selectedLine && this.selectedLine.type === 'dependency' &&
                                this.selectedLine.from === task.id && this.selectedLine.to === depId) {
                                line.classList.add('selected');
                            }
                            linksGroup.appendChild(line);
                        }
                    });
                });

                // Render nodes
                this.tasks.forEach(task => {
                    const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');
                    g.classList.add('task-node');
                    g.dataset.id = task.id;

                    // ⭐ NEW: Position group with transform (GPU-accelerated, animatable!)
                    g.setAttribute('transform', `translate(${task.x}, ${task.y})`);

                    if (task.status === 'done') g.classList.add('done');
                    if (task.currentlyWorking) g.classList.add('working');
                    if (workingAncestors.includes(task.id)) g.classList.add('parent-of-working');
                    if (incompleteChildren.includes(task.id)) g.classList.add('incomplete-child-of-working');
                    if (task.hidden) g.classList.add('hidden');
                    if (this.selectedTaskIds.has(task.id)) g.classList.add('selected');

                    // Determine display text (truncated or full)
                    const isLongText = task.title.length > this.textLengthThreshold;
                    const charsOverLimit = task.title.length - this.textLengthThreshold;
                    // Only truncate if significantly over limit (5+ chars) and not expanded
                    const shouldTruncate = charsOverLimit > 5;
                    const shouldExpand = task.currentlyWorking || task.textLocked || (task.textExpanded && this.selectedTaskIds.has(task.id));
                    let displayTitle = task.title;
                    let isTruncated = false;

                    if (shouldTruncate && !shouldExpand) {
                        // Normal truncation
                        displayTitle = task.title.substring(0, this.textLengthThreshold) + '...';
                        isTruncated = true;
                    }

                    // Calculate rect dimensions with multiline support
                    const padding = this.nodePadding;
                    const charWidth = this.charWidth;
                    const minWidth = this.minNodeWidth;
                    // When multiline is enabled, always use full text for wrapping (maxNodeHeight handles limiting)
                    // When multiline is disabled, use truncated displayTitle
                    // When editing, always use full text
                    const textForSizing = this.editingTaskId === task.id || this.enableMultiline ? task.title : displayTitle;

                    // Wrap text into lines based on max width
                    const lines = this.wrapText(textForSizing, this.maxNodeWidth, charWidth, this.wordWrap);

                    // Calculate width: minimum of (maxNodeWidth OR longest line width OR minWidth)
                    const longestLineWidth = Math.max(...lines.map(line => line.length * charWidth + padding * 2));
                    const rectWidth = Math.max(minWidth, Math.min(this.maxNodeWidth, longestLineWidth));

                    // Calculate height: lines * lineHeight + vertical padding
                    // Use fixed vertical padding (not nodePadding which is for horizontal)
                    const verticalPadding = 10;
                    const calculatedHeight = lines.length * this.lineHeight + verticalPadding * 2;

                    // Determine if we should bypass maxNodeHeight and show full text
                    // - When editing: show all lines for easier editing
                    // - When selected: show all lines so user can see full text and use lock button
                    // - When already expanded (currentlyWorking, textLocked, etc.): show all lines
                    const shouldFullyExpand = this.editingTaskId === task.id || this.selectedTaskIds.has(task.id) || shouldExpand;

                    // Check if text overflows BEFORE calculating rectHeight
                    const isOverflowing = this.maxNodeHeight > 0 && !shouldFullyExpand && calculatedHeight > this.maxNodeHeight;

                    // Calculate how many lines will actually be rendered when overflowing
                    let actualRenderedLines = lines.length;
                    if (isOverflowing) {
                        const availableHeightForOverflow = this.maxNodeHeight - verticalPadding * 2;
                        actualRenderedLines = Math.floor(availableHeightForOverflow / this.lineHeight);
                    }

                    // Size rectangle based on actual rendered content (not blindly using maxNodeHeight)
                    const rectHeight = (this.maxNodeHeight > 0 && !shouldFullyExpand)
                        ? actualRenderedLines * this.lineHeight + verticalPadding * 2
                        : calculatedHeight;

                    // ⭐ NEW: Rect positioned RELATIVE to group (centered at 0,0)
                    const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                    rect.setAttribute('x', -rectWidth / 2);
                    rect.setAttribute('y', -rectHeight / 2);
                    rect.setAttribute('width', rectWidth);
                    rect.setAttribute('height', rectHeight);
                    rect.setAttribute('fill', '#fff');
                    g.appendChild(rect);

                    // Show input if editing, otherwise show text
                    if (this.editingTaskId === task.id) {
                        const foreignObject = document.createElementNS('http://www.w3.org/2000/svg', 'foreignObject');
                        // Cover full rectangle width for better editing experience
                        foreignObject.setAttribute('x', -rectWidth / 2);
                        foreignObject.setAttribute('y', -rectHeight / 2 + 5);
                        foreignObject.setAttribute('width', rectWidth);
                        foreignObject.setAttribute('height', rectHeight - 10);
                        // Prevent clicks on editing container from bubbling
                        foreignObject.onmousedown = (e) => e.stopPropagation();
                        foreignObject.onclick = (e) => e.stopPropagation();

                        const textarea = document.createElement('textarea');
                        textarea.id = 'edit-input';
                        textarea.value = task.title;
                        textarea.rows = Math.max(2, lines.length); // Dynamic rows based on content
                        textarea.style.cssText = `width: 100%; max-width: none; height: 100%; border: 2px solid #007bff; border-radius: 4px; padding: 4px 8px; font-size: 14px; font-family: ${this.fontFamily}; text-align: left; box-sizing: border-box; resize: none; overflow: auto;`;
                        textarea.onkeydown = (e) => {
                            if (e.key === 'Enter' && !e.shiftKey) {
                                // Plain Enter = save and finish editing
                                this.finishEditing(true);
                                e.preventDefault();
                            } else if (e.key === 'Escape') {
                                // Escape = cancel editing
                                this.finishEditing(false);
                                e.preventDefault();
                            }
                            // Shift+Enter creates newline (default textarea behavior when we don't preventDefault)
                            e.stopPropagation();
                        };
                        // Prevent clicks on textarea from bubbling to canvas handlers
                        textarea.onmousedown = (e) => e.stopPropagation();
                        textarea.onclick = (e) => e.stopPropagation();
                        textarea.onblur = () => this.finishEditing(true);
                        // Dynamically resize box as user types
                        textarea.oninput = () => this.resizeEditingBox();

                        foreignObject.appendChild(textarea);
                        g.appendChild(foreignObject);
                    } else {
                        const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                        text.setAttribute('x', 0);
                        text.setAttribute('text-anchor', 'start'); // Left-aligned for multiline
                        text.style.cursor = 'pointer';
                        text.style.fontFamily = this.fontFamily;
                        text.style.fontWeight = this.fontWeight;

                        // Add emoji status indicators to first line
                        let emoji = '';
                        if (task.currentlyWorking) {
                            emoji = '🔄 ';
                        } else if (task.status === 'done') {
                            emoji = '✅ ';
                        }

                        // Calculate how many lines actually fit within rectHeight
                        const availableHeight = rectHeight - verticalPadding * 2;
                        const maxVisibleLines = Math.floor(availableHeight / this.lineHeight);
                        // Render all visible lines (truncate last line if overflowing)
                        const linesToRender = Math.min(lines.length, maxVisibleLines);

                        // Render only the lines that fit within the rectangle
                        for (let index = 0; index < linesToRender; index++) {
                            let lineText = lines[index];

                            // If this is the last visible line and text is overflowing, truncate it
                            if (isOverflowing && index === linesToRender - 1) {
                                // Truncate to make room for "..." (remove last 3 chars, add ellipsis)
                                lineText = lineText.length > 3 ? lineText.slice(0, -3) + '...' : lineText + '...';
                            }

                            const tspan = document.createElementNS('http://www.w3.org/2000/svg', 'tspan');
                            // Add emoji to first line only
                            tspan.textContent = (index === 0 ? emoji : '') + lineText;
                            tspan.setAttribute('x', -rectWidth / 2 + padding); // Left edge + padding (horizontal)
                            // Vertical position: start from top + verticalPadding, add lineHeight per line
                            const yOffset = -rectHeight / 2 + verticalPadding + this.lineHeight * (index + 0.75);
                            tspan.setAttribute('y', yOffset);
                            text.appendChild(tspan);
                        }


                        // Add dblclick handler directly to text element
                        text.addEventListener('dblclick', (e) => {
                            if (this.editingTaskId === null) {
                                if (e.shiftKey) {
                                    // Shift+double click: hide/show the node itself within its parent
                                    this.toggleHiddenSelf(task.id);
                                } else {
                                    // Normal double click: edit task name
                                    this.startEditing(task.id);
                                }
                                e.preventDefault();
                                e.stopPropagation();
                            }
                        });
                        g.appendChild(text);
                    }

                    // Add lock button for expanded text (only if long text and expanded)
                    if (isLongText && shouldExpand) {
                        const lockSize = 16;
                        // ⭐ NEW: Relative to group center
                        const lockX = -rectWidth / 2 - 20;  // 20px to the left of box
                        const lockY = 0;  // Vertically centered on node

                        // Create a group for the lock button
                        const lockGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
                        lockGroup.classList.add('lock-button');
                        lockGroup.style.cursor = task.currentlyWorking ? 'not-allowed' : 'pointer';
                        lockGroup.onclick = (e) => {
                            e.stopPropagation();
                            if (!task.currentlyWorking) {
                                this.toggleTextLock(task.id);
                            }
                        };

                        // Background circle for visibility
                        const lockBg = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                        lockBg.setAttribute('cx', lockX);
                        lockBg.setAttribute('cy', lockY);
                        lockBg.setAttribute('r', 14);
                        lockBg.setAttribute('fill', this.darkMode ? 'rgba(45, 55, 72, 0.9)' : 'rgba(255, 255, 255, 0.9)');
                        lockBg.setAttribute('stroke', this.darkMode ? '#4a5568' : '#ccc');
                        lockBg.setAttribute('stroke-width', '1');
                        lockGroup.appendChild(lockBg);

                        // Lock icon (emoji)
                        const lockText = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                        lockText.setAttribute('x', lockX);
                        lockText.setAttribute('y', lockY);
                        lockText.setAttribute('font-size', lockSize);
                        lockText.setAttribute('text-anchor', 'middle');
                        lockText.setAttribute('dominant-baseline', 'middle');
                        lockText.textContent = task.textLocked ? '🔒' : '🔓';
                        lockText.style.opacity = task.currentlyWorking ? '0.4' : '1';
                        lockGroup.appendChild(lockText);

                        g.appendChild(lockGroup);
                    }

                    // Add hidden children indicator badge
                    const hiddenCount = this.getHiddenChildrenCount(task.id);
                    if (hiddenCount > 0) {
                        const badgeRadius = 12;
                        // ⭐ NEW: Relative to group center
                        const badgeX = rectWidth / 2 - 5;
                        const badgeY = -rectHeight / 2 - 5;

                        // Create a group for the badge
                        const badgeGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
                        badgeGroup.style.cursor = 'pointer';
                        badgeGroup.onclick = (e) => {
                            e.stopPropagation();
                            this.toggleHidden(task.id);
                        };

                        // Badge circle
                        const badgeCircle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                        badgeCircle.setAttribute('cx', badgeX);
                        badgeCircle.setAttribute('cy', badgeY);
                        badgeCircle.setAttribute('r', badgeRadius);
                        badgeCircle.classList.add('hidden-indicator');
                        badgeGroup.appendChild(badgeCircle);

                        // Badge text
                        const badgeText = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                        badgeText.setAttribute('x', badgeX);
                        badgeText.setAttribute('y', badgeY);
                        badgeText.textContent = `+${hiddenCount}`;
                        badgeText.classList.add('hidden-indicator-text');
                        badgeGroup.appendChild(badgeText);

                        g.appendChild(badgeGroup);
                    }

                    // Add click handler on node to expand text (if long and truncated)
                    if (isLongText && !shouldExpand) {
                        g.style.cursor = 'pointer';
                        g.addEventListener('click', (e) => {
                            // Only expand if not clicking on other interactive elements
                            if (e.target.closest('.lock-button') || e.target.closest('.hidden-indicator')) {
                                return;
                            }
                            this.expandText(task.id);
                        });
                    }

                    nodesGroup.appendChild(g);
                });

                // Render preview node during create-child drag
                if (this.previewNode && this.dragMode === 'create-child') {
                    const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');
                    g.classList.add('preview-node');

                    // ⭐ NEW: Position with transform
                    g.setAttribute('transform', `translate(${this.previewNode.x}, ${this.previewNode.y})`);

                    // Calculate rect dimensions (same as regular nodes)
                    const padding = 10;
                    const charWidth = 8;
                    const minWidth = 80;
                    const rectWidth = Math.max(minWidth, this.previewNode.title.length * charWidth + padding * 2);
                    const rectHeight = 40;

                    // Draw ghosted rectangle (relative to group center)
                    const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                    rect.setAttribute('x', -rectWidth / 2);
                    rect.setAttribute('y', -rectHeight / 2);
                    rect.setAttribute('width', rectWidth);
                    rect.setAttribute('height', rectHeight);
                    rect.setAttribute('rx', 8);
                    rect.setAttribute('ry', 8);
                    g.appendChild(rect);

                    // Draw preview text (relative to group center)
                    const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                    text.setAttribute('x', 0);
                    text.setAttribute('y', 5);
                    text.setAttribute('text-anchor', 'middle');
                    text.textContent = this.previewNode.title;
                    text.style.cursor = 'pointer';
                    g.appendChild(text);

                    nodesGroup.appendChild(g);
                }
            },

            // Helper: Calculate task dimensions with multiline support
            calculateTaskDimensions(task) {
                const padding = this.nodePadding;
                const charWidth = this.charWidth;
                const minWidth = this.minNodeWidth;

                // Determine display text (same logic as main rendering)
                const charsOverLimit = task.title.length - this.textLengthThreshold;
                const shouldTruncate = charsOverLimit > 5;
                const shouldExpand = task.currentlyWorking || task.textLocked || (task.textExpanded && this.selectedTaskIds.has(task.id));
                const displayTitle = (shouldTruncate && !shouldExpand) ? task.title.substring(0, this.textLengthThreshold) + '...' : task.title;

                // Use full text for multiline, truncated for single-line
                const textForSizing = this.enableMultiline ? task.title : displayTitle;

                // Wrap text into lines
                const lines = this.wrapText(textForSizing, this.maxNodeWidth, charWidth, this.wordWrap);

                // Calculate width
                const longestLineWidth = Math.max(...lines.map(line => line.length * charWidth + padding * 2));
                const rectWidth = Math.max(minWidth, Math.min(this.maxNodeWidth, longestLineWidth));

                // Calculate height (use fixed vertical padding, not nodePadding)
                const verticalPadding = 10;
                const calculatedHeight = lines.length * this.lineHeight + verticalPadding * 2;
                const rectHeight = this.maxNodeHeight > 0
                    ? Math.min(this.maxNodeHeight, calculatedHeight)
                    : calculatedHeight;

                return { rectWidth, rectHeight, lines };
            },

            // Calculate line endpoint at rectangle edge for pixel-perfect arrows
            getLineEndAtRectEdge(x1, y1, x2, y2, rectWidth, rectHeight) {
                // Direction vector from point 1 to point 2
                const dx = x2 - x1;
                const dy = y2 - y1;
                const distance = Math.sqrt(dx * dx + dy * dy);

                if (distance === 0) {
                    // Same point, no direction
                    return { x: x2, y: y2 };
                }

                // Normalize to unit vector
                const ux = dx / distance;
                const uy = dy / distance;

                // Rectangle half-dimensions (rect is centered at x2, y2)
                const halfWidth = rectWidth / 2;
                const halfHeight = rectHeight / 2;

                // Find which edge the line hits first
                // Compare using cross-multiplication to avoid division
                const absUx = Math.abs(ux);
                const absUy = Math.abs(uy);

                let edgeDistance;
                if (absUx * halfHeight > absUy * halfWidth) {
                    // Hit vertical edge (left/right) first
                    edgeDistance = halfWidth / absUx;
                } else {
                    // Hit horizontal edge (top/bottom) first
                    edgeDistance = halfHeight / absUy;
                }

                // Calculate endpoint at rectangle edge
                return {
                    x: x2 - ux * edgeDistance,
                    y: y2 - uy * edgeDistance
                };
            },

            createLine(x1, y1, x2, y2, className) {
                // Dispatch to appropriate renderer based on arrow style
                if (this.arrowStyle === 'curved') {
                    return this.createCurvedPath(x1, y1, x2, y2, className);
                } else {
                    // Default: straight line
                    const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                    line.setAttribute('x1', x1);
                    line.setAttribute('y1', y1);
                    line.setAttribute('x2', x2);
                    line.setAttribute('y2', y2);
                    line.setAttribute('class', className);
                    return line;
                }
            },

            createCurvedPath(x1, y1, x2, y2, className) {
                const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');

                // Calculate curve control points
                const dx = x2 - x1;
                const dy = y2 - y1;
                const distance = Math.sqrt(dx * dx + dy * dy);

                // Curve intensity based on distance and user setting
                const curveAmount = distance * this.arrowCurvature;

                // Create perpendicular offset for smooth curve
                // Use perpendicular direction to curve sideways
                const angle = Math.atan2(dy, dx);
                const perpAngle = angle + Math.PI / 2;

                // Control points offset perpendicular to the line
                const offsetX = Math.cos(perpAngle) * curveAmount;
                const offsetY = Math.sin(perpAngle) * curveAmount;

                // Midpoint for control
                const midX = (x1 + x2) / 2;
                const midY = (y1 + y2) / 2;

                // Quadratic bezier curve through offset midpoint
                const d = `M ${x1} ${y1} Q ${midX + offsetX} ${midY + offsetY}, ${x2} ${y2}`;

                path.setAttribute('d', d);
                path.setAttribute('class', className);
                path.setAttribute('fill', 'none'); // Paths need fill=none to show stroke

                return path;
            },

            createCursorArrow() {
                // Create SVG element for custom cursor
                const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
                svg.classList.add('cursor-arrow');
                svg.setAttribute('width', '24px');
                svg.setAttribute('height', '24px');
                svg.setAttribute('viewBox', '0 0 24 24');
                svg.style.left = '0px';
                svg.style.top = '0px';
                svg.style.width = '24px';
                svg.style.height = '24px';

                // Create arrowhead path (pointing right by default, rotation will be applied)
                const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                path.setAttribute('d', 'M2,12 L22,12 M22,12 L15,5 M22,12 L15,19');
                path.setAttribute('stroke-width', '2');
                path.setAttribute('stroke-linecap', 'round');
                path.setAttribute('stroke-linejoin', 'round');
                path.setAttribute('fill', 'none');

                svg.appendChild(path);
                document.body.appendChild(svg);

                // Hide default cursor
                const container = document.getElementById('canvas-container');
                container.classList.add('dragging-relationship');

                return svg;
            },

            removeCursorArrow() {
                if (this.cursorArrow) {
                    this.cursorArrow.remove();
                    this.cursorArrow = null;
                }
                // Restore default cursor
                const container = document.getElementById('canvas-container');
                container.classList.remove('dragging-relationship');
            },

            updateCursorArrow(clientX, clientY, sourceTask) {
                if (!this.cursorArrow || !sourceTask) return;

                // Position the arrow at cursor (offset slightly so it doesn't block elementFromPoint)
                this.cursorArrow.style.left = `${clientX - 12}px`;
                this.cursorArrow.style.top = `${clientY - 12}px`;

                // Calculate rotation angle from source to cursor
                const pt = this.getSVGPoint({ clientX, clientY });
                const dx = pt.x - sourceTask.x;
                const dy = pt.y - sourceTask.y;
                const angle = Math.atan2(dy, dx) * (180 / Math.PI); // Convert to degrees

                // Apply rotation (rotate around center of SVG)
                this.cursorArrow.style.transform = `rotate(${angle}deg)`;
                this.cursorArrow.style.transformOrigin = '12px 12px';
            },

            markOrigin() {
                // Create or update "Origin Home" to current view
                const originHome = this.homes.find(h => h.name === "Origin Home");

                if (originHome) {
                    // Update existing Origin Home
                    this.updateHome(originHome.id);
                } else {
                    // Create new Origin Home
                    this.createHome("Origin Home");
                }
            },

            saveSnapshot(description, taskId = null) {
                // SNAPSHOT MECHANISM:
                // Call this BEFORE modifying this.tasks to save current state for undo
                // Creates deep clone of tasks array and stores it in undoStack
                // Clears redoStack (new action invalidates future states)
                //
                // PARAMETERS:
                // - description: Human-readable action description (e.g., "Created task")
                // - taskId: Optional - for smart grouping of repeated edits to same task
                //
                // SMART GROUPING:
                // If editing same task within 2 seconds, replaces last snapshot instead
                // of creating new one (prevents character-by-character undo when typing)

                // Don't save during undo/redo operations (prevents infinite loops)
                if (this.isUndoing) return;

                const now = Date.now();
                const timeSinceLastSnapshot = now - this.lastSnapshotTime;

                // Smart grouping: Replace last snapshot if editing same task within 2 seconds
                const shouldGroup =
                    taskId !== null &&
                    taskId === this.lastSnapshotTaskId &&
                    timeSinceLastSnapshot < 2000 &&
                    this.undoStack.length > 0 &&
                    this.undoStack[this.undoStack.length - 1].description.startsWith('Edited task');

                if (shouldGroup) {
                    // Replace the last snapshot instead of creating a new one
                    this.undoStack[this.undoStack.length - 1] = {
                        tasks: JSON.parse(JSON.stringify(this.tasks)),
                        description: description,
                        timestamp: now
                    };
                } else {
                    // Create new snapshot
                    const snapshot = {
                        tasks: JSON.parse(JSON.stringify(this.tasks)),
                        description: description,
                        timestamp: now
                    };

                    this.undoStack.push(snapshot);

                    // Enforce undo limit
                    this.enforceUndoLimit();
                }

                // Clear redo stack when new action is performed
                this.redoStack = [];

                // Update tracking for grouping
                this.lastSnapshotTime = now;
                this.lastSnapshotTaskId = taskId;
            },

            // ========================================================================
            // ⚠️ UNDO/REDO INTEGRATION CHECKLIST ⚠️
            // ========================================================================
            // When adding a NEW operation that modifies task data, you MUST call
            // this.saveSnapshot("Description") BEFORE the modification.
            //
            // CURRENT INTEGRATION POINTS (20 total):
            // ✅ addChildTask() - line 1112
            // ✅ createChildAtPosition() - line 1147
            // ✅ cycleStatus() - lines 1184, 1189, 1198 (3 state transitions)
            // ✅ toggleDone() - lines 1225, 1229 (done ↔ pending, also has flow-state logic)
            // ✅ toggleHidden() - line 1336
            // ✅ deleteTask() - line 1377
            // ✅ finishEditing() - line 1594 (with smart grouping)
            // ✅ clearAllData() - line 1611
            // ✅ importData() - line 2109
            // ✅ Ctrl+Click creation - line 2199
            // ✅ Right-click menu creation - line 2759
            // ✅ Move subtree - line 2454
            // ✅ Move single task - line 2473
            // ✅ addDependency() - lines 2579, 2596 (add & remove toggle)
            // ✅ removeDependency() - line 2608
            // ❌ Canvas panning - INTENTIONALLY NOT UNDOABLE (viewport navigation)
            //
            // TYPES OF OPERATIONS:
            // 1. Content Modification (MUST be undoable):
            //    - Create/delete tasks
            //    - Edit task properties
            //    - Change relationships (parent/child, dependencies)
            //    - Change task positions (moves individual tasks/subtrees)
            //    - Change status (pending/working/done)
            //    - Bulk operations (import, clear all)
            //
            // 2. Viewport Navigation (NOT undoable - doesn't clear redo stack):
            //    - Pan canvas
            //    - Zoom in/out
            //    - Fit to screen
            //
            // HOW TO ADD UNDO TO A NEW OPERATION:
            // 1. Identify: Is this a content modification or viewport navigation?
            // 2. If content modification: Add this.saveSnapshot("Action description")
            //    BEFORE modifying this.tasks
            // 3. Use descriptive text: "Created task", "Deleted task 'Title'", etc.
            // 4. For repeated edits to same task: Pass taskId as 2nd param for grouping
            // 5. Update this checklist with the new integration point
            // 6. Update README.md operation count and list
            //
            // TESTING YOUR INTEGRATION:
            // 1. Perform the new operation
            // 2. Press Ctrl+Z → Should undo the operation
            // 3. Press Ctrl+Shift+Z → Should redo the operation
            // 4. Do operation, pan canvas, undo → Redo should still work (redo not cleared)
            // ========================================================================

            // Development helper: Detect if tasks array was modified without snapshot
            // Uncomment during development to catch missing saveSnapshot() calls
            /*
            _trackTasksModification() {
                const currentHash = JSON.stringify(this.tasks.map(t => ({id: t.id, title: t.title, status: t.status})));
                if (this._lastTasksHash && this._lastTasksHash !== currentHash && !this.isUndoing) {
                    console.warn('⚠️ UNDO/REDO WARNING: tasks array modified without saveSnapshot() call!');
                    console.warn('Current stack:', new Error().stack);
                }
                this._lastTasksHash = currentHash;
            }
            */

            enforceUndoLimit() {
                // Trim undoStack if it exceeds user-configured limit
                // Called after adding new snapshot and when user changes maxUndoSteps in Settings
                while (this.undoStack.length > this.maxUndoSteps) {
                    this.undoStack.shift(); // Remove oldest snapshot
                }
            },

            clearUndoHistory() {
                // Clear all undo/redo history (called from Settings modal)
                const undoCount = this.undoStack.length;
                const redoCount = this.redoStack.length;

                if (undoCount === 0 && redoCount === 0) {
                    this.showToast('History is already empty', 'info');
                    return;
                }

                // Show confirmation dialog
                this.showConfirm(
                    'Clear Undo/Redo History?',
                    `This will remove ${undoCount} undo steps and ${redoCount} redo steps. This action cannot be undone.`,
                    () => {
                        // On confirm
                        this.undoStack = [];
                        this.redoStack = [];
                        this.saveToStorage();
                        this.updateStatusBar();
                        this.showToast(`✓ History cleared (${undoCount + redoCount} steps removed)`, 'success');

                        // Update stats in settings modal if it's open
                        const modal = document.getElementById('settings-modal');
                        if (modal && modal.classList.contains('show')) {
                            document.getElementById('undo-count').textContent = '0';
                            document.getElementById('redo-count').textContent = '0';
                            document.getElementById('history-size').textContent = '0';
                        }
                    }
                );
            },

            undo() {
                // UNDO MECHANISM:
                // 1. Save current state to redoStack (so we can redo later)
                // 2. Pop snapshot from undoStack (the previous state)
                // 3. Restore tasks array from snapshot (deep clone)
                // 4. isUndoing flag prevents saveSnapshot() from being called during this process
                //    (otherwise saveToStorage() would trigger saveSnapshot() → clear redoStack!)

                if (this.undoStack.length === 0) {
                    this.showToast('Nothing to undo', 'error');
                    return;
                }

                // Save current state to redo stack (so redo can restore it)
                this.isUndoing = true;  // Prevents saveSnapshot() from clearing redoStack
                const currentState = {
                    tasks: JSON.parse(JSON.stringify(this.tasks)),  // Deep clone
                    description: 'Current state',
                    timestamp: Date.now()
                };
                this.redoStack.push(currentState);

                // Restore previous state from undo stack
                const snapshot = this.undoStack.pop();
                this.tasks = JSON.parse(JSON.stringify(snapshot.tasks));  // Deep clone

                this.isUndoing = false;
                this.saveToStorage();  // Persist both stacks to localStorage
                this.render();
                this.updateStatusBar();

                // Show what was undone
                const desc = snapshot.description.length > 50
                    ? snapshot.description.substring(0, 47) + '...'
                    : snapshot.description;
                this.showToast(`✓ Undone: ${desc}`, 'success');
            },

            redo() {
                // REDO MECHANISM:
                // 1. Save current state to undoStack (so we can undo the redo)
                // 2. Pop snapshot from redoStack (the "future" state we undid earlier)
                // 3. Restore tasks array from snapshot (deep clone)
                // 4. isUndoing flag prevents saveSnapshot() during this process
                //
                // SYMMETRY WITH UNDO:
                // - undo() moves snapshots: undoStack → redoStack
                // - redo() moves snapshots: redoStack → undoStack
                // Both save current state to opposite stack before restoring

                if (this.redoStack.length === 0) {
                    this.showToast('Nothing to redo', 'error');
                    return;
                }

                // Save current state to undo stack (so we can undo this redo)
                this.isUndoing = true;  // Prevents saveSnapshot() from clearing stacks
                const currentState = {
                    tasks: JSON.parse(JSON.stringify(this.tasks)),  // Deep clone
                    description: 'Current state',
                    timestamp: Date.now()
                };
                this.undoStack.push(currentState);

                // Restore "future" state from redo stack
                const snapshot = this.redoStack.pop();
                this.tasks = JSON.parse(JSON.stringify(snapshot.tasks));  // Deep clone

                this.isUndoing = false;
                this.saveToStorage();  // Persist both stacks to localStorage
                this.render();
                this.updateStatusBar();

                // Show what was redone
                const desc = snapshot.description.length > 50
                    ? snapshot.description.substring(0, 47) + '...'
                    : snapshot.description;
                this.showToast(`✓ Redone: ${desc}`, 'success');
            },

            debouncedSaveToStorage(delay = 500) {
                // Debounced save for performance optimization
                // Used for operations that happen frequently (like canvas panning)
                // Waits 'delay' ms after last call before actually saving
                // This prevents excessive localStorage writes during rapid interactions

                // Clear existing timer if any
                if (this.saveDebounceTimer) {
                    clearTimeout(this.saveDebounceTimer);
                }

                // Set new timer
                this.saveDebounceTimer = setTimeout(() => {
                    this.saveToStorage();
                    this.saveDebounceTimer = null;
                }, delay);
            },

            saveToStorage() {
                try {
                    localStorage.setItem('taskTree', JSON.stringify({
                        // Task data
                        tasks: this.tasks,
                        taskIdCounter: this.taskIdCounter,
                        // Multi-project working state
                        workingTasksByRoot: this.workingTasksByRoot,
                        // View state
                        darkMode: this.darkMode,
                        zoomLevel: this.zoomLevel,
                        // Homes - named bookmarks
                        homes: this.homes,
                        homeIdCounter: this.homeIdCounter,
                        // User preferences & configuration
                        textLengthThreshold: this.textLengthThreshold,
                        charWidth: this.charWidth,
                        nodePadding: this.nodePadding,
                        minNodeWidth: this.minNodeWidth,
                        fontFamily: this.fontFamily,
                        fontWeight: this.fontWeight,
                        showDeleteConfirmation: this.showDeleteConfirmation,
                        autoHideCompletedNodes: this.autoHideCompletedNodes,
                        enableMultiline: this.enableMultiline,
                        maxNodeWidth: this.maxNodeWidth,
                        maxNodeHeight: this.maxNodeHeight,
                        lineHeight: this.lineHeight,
                        wordWrap: this.wordWrap,
                        arrowStyle: this.arrowStyle,
                        arrowCurvature: this.arrowCurvature,
                        // Undo/redo history
                        undoStack: this.undoStack,
                        redoStack: this.redoStack
                    }));
                } catch (e) {
                    // Handle quota exceeded error
                    if (e.name === 'QuotaExceededError') {
                        // Trim undo history and try again
                        this.undoStack = this.undoStack.slice(-10); // Keep only last 10
                        this.redoStack = [];
                        try {
                            localStorage.setItem('taskTree', JSON.stringify({
                                tasks: this.tasks,
                                taskIdCounter: this.taskIdCounter,
                                workingTasksByRoot: this.workingTasksByRoot,
                                darkMode: this.darkMode,
                                zoomLevel: this.zoomLevel,
                                homes: this.homes,
                                homeIdCounter: this.homeIdCounter,
                                textLengthThreshold: this.textLengthThreshold,
                                charWidth: this.charWidth,
                                nodePadding: this.nodePadding,
                                minNodeWidth: this.minNodeWidth,
                                fontFamily: this.fontFamily,
                                fontWeight: this.fontWeight,
                                showDeleteConfirmation: this.showDeleteConfirmation,
                                autoHideCompletedNodes: this.autoHideCompletedNodes,
                                enableMultiline: this.enableMultiline,
                                maxNodeWidth: this.maxNodeWidth,
                                maxNodeHeight: this.maxNodeHeight,
                                lineHeight: this.lineHeight,
                                wordWrap: this.wordWrap,
                                arrowStyle: this.arrowStyle,
                                arrowCurvature: this.arrowCurvature,
                                undoStack: this.undoStack,
                                redoStack: this.redoStack
                            }));
                            this.showToast('Undo history trimmed due to storage limits', 'error', 3000);
                        } catch (e2) {
                            console.error('Storage error:', e2);
                        }
                    }
                }
            },

            loadFromStorage() {
                const data = localStorage.getItem('taskTree');
                if (data) {
                    const parsed = JSON.parse(data);
                    // Task data
                    this.tasks = parsed.tasks || [];
                    this.taskIdCounter = parsed.taskIdCounter || 0;
                    // Multi-project working state
                    this.workingTasksByRoot = parsed.workingTasksByRoot || {};
                    // View state
                    this.darkMode = parsed.darkMode || false;
                    this.zoomLevel = parsed.zoomLevel || 1;
                    // Homes - load and migrate from old origin system
                    this.homes = parsed.homes || [];
                    this.homeIdCounter = parsed.homeIdCounter || 1;

                    // MIGRATION: Convert old origin system to "Origin Home"
                    if (parsed.originMarked && this.homes.length === 0) {
                        this.homes.push({
                            id: this.homeIdCounter++,
                            name: "Origin Home",
                            centerX: parsed.originX || 0,
                            centerY: parsed.originY || 0,
                            zoomLevel: parsed.originZoomLevel || 1,
                            timestamp: Date.now()
                        });
                        // Save immediately to persist migration
                        setTimeout(() => {
                            this.saveToStorage();
                            this.showToast('✓ Migrated to Homes system', 'info', 2000);
                        }, 100);
                    }

                    // User preferences & configuration (use ?? for proper defaults)
                    this.textLengthThreshold = parsed.textLengthThreshold ?? 80;
                    this.charWidth = parsed.charWidth ?? 8.5;
                    this.nodePadding = parsed.nodePadding ?? 30;
                    this.minNodeWidth = parsed.minNodeWidth ?? 100;
                    this.fontFamily = parsed.fontFamily ?? "'Fira Code', 'Consolas', 'Monaco', 'Courier New', monospace";
                    this.fontWeight = parsed.fontWeight ?? 700;
                    this.showDeleteConfirmation = parsed.showDeleteConfirmation ?? true;
                    this.autoHideCompletedNodes = parsed.autoHideCompletedNodes ?? true;
                    this.enableMultiline = parsed.enableMultiline ?? true;
                    this.maxNodeWidth = parsed.maxNodeWidth ?? 600;
                    this.maxNodeHeight = parsed.maxNodeHeight ?? 0;
                    this.lineHeight = parsed.lineHeight ?? 20;
                    this.wordWrap = parsed.wordWrap ?? true;
                    this.arrowStyle = parsed.arrowStyle ?? 'straight';
                    this.arrowCurvature = parsed.arrowCurvature ?? 0.25;
                    // Undo/redo history
                    this.undoStack = parsed.undoStack || [];
                    this.redoStack = parsed.redoStack || [];

                    // Update dark mode button and apply dark mode
                    const darkModeBtn = document.getElementById('darkModeToggle');
                    if (this.darkMode) {
                        document.body.classList.add('dark-mode');
                        if (darkModeBtn) darkModeBtn.textContent = '☀️ Light Mode';
                    } else {
                        document.body.classList.remove('dark-mode');
                        if (darkModeBtn) darkModeBtn.textContent = '🌙 Dark Mode';
                    }

                    // Update zoom display
                    this.updateZoomDisplay();

                    // Update text length input
                    const textLengthInput = document.getElementById('textLengthInput');
                    if (textLengthInput) {
                        textLengthInput.value = this.textLengthThreshold;
                    }
                }
            },

            // ============== HOME MANAGEMENT FUNCTIONS ==============

            createHome(name) {
                // Create a new home bookmark at current view position
                // Validates unique name and warns if >20 homes

                if (!name || name.trim() === '') {
                    this.showToast('Home name cannot be empty', 'error');
                    return false;
                }

                const trimmedName = name.trim();

                // Check for duplicate name (case-insensitive)
                const duplicate = this.homes.find(h => h.name.toLowerCase() === trimmedName.toLowerCase());
                if (duplicate) {
                    this.showToast(`Home "${trimmedName}" already exists`, 'error');
                    return false;
                }

                // Calculate center of current view
                const centerX = this.tasks.length > 0
                    ? this.tasks.reduce((sum, t) => sum + t.x, 0) / this.tasks.length
                    : this.viewBox.width / 2;
                const centerY = this.tasks.length > 0
                    ? this.tasks.reduce((sum, t) => sum + t.y, 0) / this.tasks.length
                    : this.viewBox.height / 2;

                // Create new home
                const newHome = {
                    id: this.homeIdCounter++,
                    name: trimmedName,
                    centerX: centerX,
                    centerY: centerY,
                    zoomLevel: this.zoomLevel,
                    timestamp: Date.now(),
                    keybind: null  // No keybind by default
                };

                this.homes.push(newHome);
                this.saveToStorage();

                // Warn if >20 homes
                if (this.homes.length > 20) {
                    this.showToast(`⚠️ Home "${trimmedName}" created (${this.homes.length} homes - consider organizing)`, 'warning', 3000);
                } else {
                    this.showToast(`✓ Home "${trimmedName}" created`, 'success');
                }

                return true;
            },

            jumpToHome(homeId, animate = true) {
                // Navigate to a saved home bookmark
                // Smoothly animates pan and zoom if animate=true

                const home = this.homes.find(h => h.id === homeId);
                if (!home) {
                    this.showToast('Home not found', 'error');
                    return;
                }

                if (this.tasks.length === 0) {
                    this.showToast(`No tasks to navigate. Home "${home.name}" will apply when tasks exist.`, 'warning');
                    return;
                }

                // Calculate current center
                const currentCenterX = this.tasks.reduce((sum, t) => sum + t.x, 0) / this.tasks.length;
                const currentCenterY = this.tasks.reduce((sum, t) => sum + t.y, 0) / this.tasks.length;

                // Calculate offset to move current center to home position
                const dx = home.centerX - currentCenterX;
                const dy = home.centerY - currentCenterY;

                if (animate) {
                    // Cinematic 3-phase animation: zoom out → pan → zoom in
                    const svg = document.getElementById('canvas');
                    svg.classList.add('animating-view');

                    const startZoom = this.zoomLevel;
                    const endZoom = home.zoomLevel;
                    const overviewZoom = Math.min(startZoom, endZoom) * 0.5; // Zoom out to 50% of minimum

                    const totalDuration = 1300; // ms
                    const zoomOutDuration = 300;
                    const panDuration = 500;
                    const zoomInDuration = 500;
                    const startTime = performance.now();
                    let panTriggered = false;

                    // Animation phases
                    const animatePhases = (currentTime) => {
                        const elapsed = currentTime - startTime;

                        if (elapsed < zoomOutDuration) {
                            // Phase 1: Zoom out (0-300ms)
                            const progress = elapsed / zoomOutDuration;
                            const eased = 1 - Math.pow(1 - progress, 3); // ease-out
                            this.zoomLevel = startZoom + (overviewZoom - startZoom) * eased;
                            this.updateZoomDisplay();
                            this.updateViewBoxOnly();
                            requestAnimationFrame(animatePhases);

                        } else if (elapsed < zoomOutDuration + panDuration) {
                            // Phase 2: Pan while zoomed out (300-800ms)
                            if (!panTriggered) {
                                panTriggered = true;
                                // Update data model and trigger CSS transition for nodes
                                this.tasks.forEach(task => {
                                    task.x += dx;
                                    task.y += dy;
                                });

                                // Update node transforms to trigger smooth CSS animation
                                this.tasks.forEach(task => {
                                    const node = document.querySelector(`.task-node[data-id="${task.id}"]`);
                                    if (node) {
                                        node.setAttribute('transform', `translate(${task.x}, ${task.y})`);
                                    }
                                });
                            }
                            // Stay at overview zoom during pan
                            this.zoomLevel = overviewZoom;
                            this.updateZoomDisplay();
                            this.updateViewBoxOnly();
                            requestAnimationFrame(animatePhases);

                        } else if (elapsed < totalDuration) {
                            // Phase 3: Zoom in to target (800-1300ms)
                            const progress = (elapsed - zoomOutDuration - panDuration) / zoomInDuration;
                            const eased = 1 - Math.pow(1 - progress, 3); // ease-out
                            this.zoomLevel = overviewZoom + (endZoom - overviewZoom) * eased;
                            this.updateZoomDisplay();
                            this.updateViewBoxOnly();
                            requestAnimationFrame(animatePhases);

                        } else {
                            // Animation complete
                            this.zoomLevel = endZoom;
                            this.updateZoomDisplay();
                            svg.classList.remove('animating-view');
                            this.render(); // Lines reappear with perfect edge-to-edge arrows

                            // Save after animation completes to persist new positions and zoom
                            this.saveToStorage();
                        }
                    };

                    requestAnimationFrame(animatePhases);

                    // Note: Lines fade out via CSS (opacity: 0 on .animating-view line)
                    // They'll be re-rendered perfectly after animation completes

                    this.showToast(`→ Jumped to "${home.name}"`, 'success');
                } else {
                    // Instant jump (no animation)
                    this.tasks.forEach(task => {
                        task.x += dx;
                        task.y += dy;
                    });

                    this.zoomLevel = home.zoomLevel;
                    this.updateZoomDisplay();

                    this.saveToStorage();
                    this.render();

                    this.showToast(`→ Jumped to "${home.name}"`, 'success');
                }
            },

            updateHome(homeId) {
                // Update an existing home to current view position and zoom

                const home = this.homes.find(h => h.id === homeId);
                if (!home) {
                    this.showToast('Home not found', 'error');
                    return;
                }

                // Calculate center of current view
                const centerX = this.tasks.length > 0
                    ? this.tasks.reduce((sum, t) => sum + t.x, 0) / this.tasks.length
                    : this.viewBox.width / 2;
                const centerY = this.tasks.length > 0
                    ? this.tasks.reduce((sum, t) => sum + t.y, 0) / this.tasks.length
                    : this.viewBox.height / 2;

                home.centerX = centerX;
                home.centerY = centerY;
                home.zoomLevel = this.zoomLevel;
                home.timestamp = Date.now();

                this.saveToStorage();
                this.showToast(`✓ Updated "${home.name}" to current view`, 'success');
            },

            deleteHome(homeId) {
                // Delete a home bookmark (with confirmation if enabled)

                const home = this.homes.find(h => h.id === homeId);
                if (!home) {
                    this.showToast('Home not found', 'error');
                    return;
                }

                const confirmDelete = () => {
                    this.homes = this.homes.filter(h => h.id !== homeId);
                    this.saveToStorage();
                    this.showToast(`✓ Deleted home "${home.name}"`, 'success');
                };

                if (this.showDeleteConfirmation) {
                    this.showConfirmDialog(
                        `Delete home "${home.name}"?`,
                        'This action cannot be undone.',
                        confirmDelete
                    );
                } else {
                    confirmDelete();
                }
            },

            setKeybindForHome(homeId) {
                // Set a keyboard shortcut for a home
                const home = this.homes.find(h => h.id === homeId);
                if (!home) return;

                // Show alert instructing user to press a key
                const message = home.keybind
                    ? `Current keybind for "${home.name}": ${home.keybind}\n\nPress a key (0-9) to set new keybind, or press Escape to clear keybind.`
                    : `Press a key (0-9) to set keybind for "${home.name}", or press Escape to cancel.`;

                this.showAlert('Set Keybind', message);

                // Capture next keypress
                const keyHandler = (e) => {
                    // Remove listener immediately
                    document.removeEventListener('keydown', keyHandler);

                    // Close alert modal
                    this.hideAlert();

                    // Handle Escape key
                    if (e.key === 'Escape') {
                        if (home.keybind) {
                            // Clear existing keybind
                            home.keybind = null;
                            this.saveToStorage();
                            this.renderManageHomesModal();
                            this.showToast(`✓ Keybind cleared for "${home.name}"`, 'success');
                        }
                        // Otherwise just cancel
                        return;
                    }

                    // Only allow 0-9 keys
                    if (!/^[0-9]$/.test(e.key)) {
                        this.showToast('Only keys 0-9 are allowed for keybinds', 'error');
                        return;
                    }

                    // Check if keybind is already used by another home
                    const existingHome = this.homes.find(h => h.id !== homeId && h.keybind === e.key);
                    if (existingHome) {
                        this.showConfirm(
                            'Keybind Conflict',
                            `Key "${e.key}" is already assigned to "${existingHome.name}". Reassign it to "${home.name}"?`,
                            () => {
                                // Remove from old home
                                existingHome.keybind = null;
                                // Assign to new home
                                home.keybind = e.key;
                                this.saveToStorage();
                                this.renderManageHomesModal();
                                this.showToast(`✓ Keybind "${e.key}" assigned to "${home.name}"`, 'success');
                            }
                        );
                    } else {
                        // No conflict, assign keybind
                        home.keybind = e.key;
                        this.saveToStorage();
                        this.renderManageHomesModal();
                        this.showToast(`✓ Keybind "${e.key}" assigned to "${home.name}"`, 'success');
                    }
                };

                // Add listener for next keypress
                document.addEventListener('keydown', keyHandler);
            },

            renameHome(homeId, newName) {
                // Rename a home bookmark (validates unique name)

                const home = this.homes.find(h => h.id === homeId);
                if (!home) {
                    this.showToast('Home not found', 'error');
                    return false;
                }

                if (!newName || newName.trim() === '') {
                    this.showToast('Home name cannot be empty', 'error');
                    return false;
                }

                const trimmedName = newName.trim();

                // Check for duplicate name (case-insensitive), excluding current home
                const duplicate = this.homes.find(h =>
                    h.id !== homeId && h.name.toLowerCase() === trimmedName.toLowerCase()
                );
                if (duplicate) {
                    this.showToast(`Home "${trimmedName}" already exists`, 'error');
                    return false;
                }

                const oldName = home.name;
                home.name = trimmedName;
                home.timestamp = Date.now();

                this.saveToStorage();
                this.showToast(`✓ Renamed "${oldName}" to "${trimmedName}"`, 'success');
                return true;
            },

            toggleHomesDropdown(event) {
                // Toggle the Homes dropdown menu
                event.stopPropagation();
                const dropdown = document.getElementById('homesDropdown');

                if (dropdown.classList.contains('show')) {
                    dropdown.classList.remove('show');
                } else {
                    this.renderHomesDropdown();
                    dropdown.classList.add('show');

                    // Close dropdown when clicking outside
                    const closeDropdown = (e) => {
                        if (!dropdown.contains(e.target) && !e.target.closest('.dropdown button')) {
                            dropdown.classList.remove('show');
                            document.removeEventListener('click', closeDropdown);
                        }
                    };
                    setTimeout(() => document.addEventListener('click', closeDropdown), 0);
                }
            },

            renderHomesDropdown() {
                // Populate the Homes dropdown with current homes
                const dropdown = document.getElementById('homesDropdown');
                dropdown.innerHTML = '';

                if (this.homes.length === 0) {
                    dropdown.innerHTML = '<div class="dropdown-empty">No homes created yet</div>';
                } else {
                    // Sort homes: "Origin Home" first, then alphabetically
                    const sortedHomes = [...this.homes].sort((a, b) => {
                        if (a.name === "Origin Home") return -1;
                        if (b.name === "Origin Home") return 1;
                        return a.name.localeCompare(b.name);
                    });

                    sortedHomes.forEach(home => {
                        const item = document.createElement('div');
                        item.className = 'dropdown-item';
                        if (home.name === "Origin Home") {
                            item.classList.add('special');
                        }

                        // Display home name with keybind if it exists
                        const nameText = home.keybind ? `${home.name} [${home.keybind}]` : home.name;
                        item.textContent = nameText;

                        item.onclick = (e) => {
                            e.stopPropagation();
                            this.jumpToHome(home.id);
                            dropdown.classList.remove('show');
                        };
                        dropdown.appendChild(item);
                    });
                }

                // Add divider and actions
                if (this.homes.length > 0) {
                    const divider = document.createElement('div');
                    divider.className = 'dropdown-divider';
                    dropdown.appendChild(divider);
                }

                const createItem = document.createElement('div');
                createItem.className = 'dropdown-item special';
                createItem.innerHTML = '+ Create New Home';
                createItem.onclick = (e) => {
                    e.stopPropagation();
                    this.showCreateHomeModal();
                    dropdown.classList.remove('show');
                };
                dropdown.appendChild(createItem);

                const manageItem = document.createElement('div');
                manageItem.className = 'dropdown-item';
                manageItem.innerHTML = '⚙️ Manage Homes';
                manageItem.onclick = (e) => {
                    e.stopPropagation();
                    this.showManageHomesModal();
                    dropdown.classList.remove('show');
                };
                dropdown.appendChild(manageItem);
            },

            showCreateHomeModal() {
                // Show the Create Home modal
                const modal = document.getElementById('create-home-modal');
                const input = document.getElementById('home-name-input');
                input.value = '';
                modal.style.display = 'flex';
                setTimeout(() => input.focus(), 100);
            },

            hideCreateHomeModal() {
                // Hide the Create Home modal
                document.getElementById('create-home-modal').style.display = 'none';
            },

            createHomeFromModal() {
                // Create a new home from the modal input
                const input = document.getElementById('home-name-input');
                const name = input.value.trim();

                if (this.createHome(name)) {
                    this.hideCreateHomeModal();
                }
            },

            showManageHomesModal() {
                // Show the Manage Homes modal
                const modal = document.getElementById('manage-homes-modal');
                this.renderManageHomesModal();
                modal.style.display = 'flex';
            },

            hideManageHomesModal() {
                // Hide the Manage Homes modal
                document.getElementById('manage-homes-modal').style.display = 'none';
            },

            renderManageHomesModal() {
                // Populate the Manage Homes modal with current homes
                const container = document.getElementById('homes-list');
                container.innerHTML = '';

                if (this.homes.length === 0) {
                    container.innerHTML = '<div style="text-align: center; color: #999; padding: 40px; font-style: italic;">No homes created yet</div>';
                    return;
                }

                // Sort homes: "Origin Home" first, then alphabetically
                const sortedHomes = [...this.homes].sort((a, b) => {
                    if (a.name === "Origin Home") return -1;
                    if (b.name === "Origin Home") return 1;
                    return a.name.localeCompare(b.name);
                });

                sortedHomes.forEach(home => {
                    const homeCard = document.createElement('div');
                    homeCard.style.cssText = `
                        background: ${home.name === "Origin Home" ? 'rgba(156, 39, 176, 0.1)' : 'rgba(255, 255, 255, 0.05)'};
                        border: 1px solid ${home.name === "Origin Home" ? 'rgba(156, 39, 176, 0.3)' : 'rgba(255, 255, 255, 0.1)'};
                        border-radius: 8px;
                        padding: 16px;
                        margin-bottom: 12px;
                        display: flex;
                        justify-content: space-between;
                        align-items: center;
                    `;

                    const infoDiv = document.createElement('div');
                    infoDiv.style.cssText = 'flex: 1;';

                    const nameSpan = document.createElement('div');
                    nameSpan.textContent = home.name;
                    // Use light colors in dark mode for visibility
                    const isDarkMode = document.body.classList.contains('dark-mode');
                    const nameColor = home.name === "Origin Home" ? '#9c27b0' : (isDarkMode ? '#e2e8f0' : '#333');
                    nameSpan.style.cssText = `
                        font-weight: 600;
                        font-size: 15px;
                        margin-bottom: 6px;
                        color: ${nameColor};
                    `;

                    const detailsSpan = document.createElement('div');
                    const keybindText = home.keybind ? ` • Keybind: ${home.keybind}` : '';
                    detailsSpan.textContent = `Zoom: ${home.zoomLevel.toFixed(1)}x • Position: (${Math.round(home.centerX)}, ${Math.round(home.centerY)})${keybindText}`;
                    const detailsColor = isDarkMode ? '#94a3b8' : '#666';
                    detailsSpan.style.cssText = `font-size: 12px; color: ${detailsColor};`;

                    infoDiv.appendChild(nameSpan);
                    infoDiv.appendChild(detailsSpan);

                    const actionsDiv = document.createElement('div');
                    actionsDiv.style.cssText = 'display: flex; gap: 8px;';

                    // Jump button
                    const jumpBtn = document.createElement('button');
                    jumpBtn.textContent = '→ Jump';
                    jumpBtn.style.cssText = 'padding: 6px 12px; font-size: 13px;';
                    jumpBtn.onclick = () => {
                        this.jumpToHome(home.id);
                        this.hideManageHomesModal();
                    };
                    actionsDiv.appendChild(jumpBtn);

                    // Update button
                    const updateBtn = document.createElement('button');
                    updateBtn.className = 'secondary';
                    updateBtn.textContent = '↻ Update';
                    updateBtn.style.cssText = 'padding: 6px 12px; font-size: 13px;';
                    updateBtn.onclick = () => {
                        this.updateHome(home.id);
                        this.renderManageHomesModal();
                    };
                    actionsDiv.appendChild(updateBtn);

                    // Keybind button
                    const keybindBtn = document.createElement('button');
                    keybindBtn.className = 'secondary';
                    keybindBtn.textContent = home.keybind ? `⌨ ${home.keybind}` : '⌨ Set Key';
                    keybindBtn.style.cssText = 'padding: 6px 12px; font-size: 13px;';
                    keybindBtn.onclick = () => {
                        this.setKeybindForHome(home.id);
                    };
                    actionsDiv.appendChild(keybindBtn);

                    // Rename button
                    const renameBtn = document.createElement('button');
                    renameBtn.className = 'secondary';
                    renameBtn.textContent = '✎ Rename';
                    renameBtn.style.cssText = 'padding: 6px 12px; font-size: 13px;';
                    renameBtn.onclick = () => {
                        const newName = prompt(`Rename "${home.name}" to:`, home.name);
                        if (newName) {
                            if (this.renameHome(home.id, newName)) {
                                this.renderManageHomesModal();
                            }
                        }
                    };
                    actionsDiv.appendChild(renameBtn);

                    // Delete button
                    const deleteBtn = document.createElement('button');
                    deleteBtn.className = 'secondary';
                    deleteBtn.textContent = '✕ Delete';
                    deleteBtn.style.cssText = 'padding: 6px 12px; font-size: 13px; color: #f44336;';
                    deleteBtn.onclick = () => {
                        this.deleteHome(home.id);
                        this.renderManageHomesModal();
                    };
                    actionsDiv.appendChild(deleteBtn);

                    homeCard.appendChild(infoDiv);
                    homeCard.appendChild(actionsDiv);
                    container.appendChild(homeCard);
                });
            },

            // ============== END HOME MANAGEMENT FUNCTIONS ==============

            updateTextLengthThreshold() {
                const input = document.getElementById('textLengthInput');
                if (!input) return; // Input removed, use Settings modal instead
                const value = parseInt(input.value);
                if (value >= 10 && value <= 100) {
                    this.textLengthThreshold = value;
                    this.saveToStorage();
                    this.render();
                }
            },

            expandText(taskId) {
                // Expand text on click
                const task = this.tasks.find(t => t.id === taskId);
                if (task) {
                    task.textExpanded = true;
                    this.saveToStorage();
                    this.render();
                }
            },

            toggleTextLock(taskId) {
                // Toggle lock state
                const task = this.tasks.find(t => t.id === taskId);
                if (task) {
                    task.textLocked = !task.textLocked;

                    // If unlocking and node is NOT selected, collapse immediately
                    if (!task.textLocked && !this.selectedTaskIds.has(taskId) && !task.currentlyWorking) {
                        task.textExpanded = false;
                    }

                    this.saveToStorage();
                    this.render();
                }
            }
        };

        document.addEventListener('DOMContentLoaded', () => app.init());
    </script>
</body>
</html>
